<?php
namespace Hypertable_ThriftGen;

/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;

/**
 * Specifies options for a scan
 * 
 * <dl>
 *   <dt>row_intervals</dt>
 *   <dd>A list of ranges of rows to scan. Mutually exclusive with
 *   cell_interval</dd>
 * 
 *   <dt>cell_intervals</dt>
 *   <dd>A list of ranges of cells to scan. Mutually exclusive with
 *   row_intervals</dd>
 * 
 *   <dt>return_deletes</dt>
 *   <dd>Indicates whether cells pending delete are returned</dd>
 * 
 *   <dt>revs</dt>
 *   <dd>Specifies max number of revisions of cells to return</dd>
 * 
 *   <dt>row_limit</dt>
 *   <dd>Specifies max number of rows to return</dd>
 * 
 *   <dt>start_time</dt>
 *   <dd>Specifies start time in nanoseconds since epoch for cells to
 *   return</dd>
 * 
 *   <dt>end_time</dt>
 *   <dd>Specifies end time in nanoseconds since epoch for cells to return</dd>
 * 
 *   <dt>columns</dt>
 *   <dd>Specifies the names of the columns to return</dd>
 * 
 *   <dt>cell_limit</dt>
 *   <dd>Specifies max number of cells to return</dd>
 * 
 *   <dt>cell_limit_per_family</dt>
 *   <dd>Specifies max number of cells to return per column family</dd>
 * 
 *   <dt>row_regexp</dt>
 *   <dd>Specifies a regexp used to filter by rowkey</dd>
 * 
 *   <dt>value_regexp</dt>
 *   <dd>Specifies a regexp used to filter by cell value</dd>
 * 
 *   <dt>scan_and_filter_rows</dt>
 *   <dd>Indicates whether table scan filters the rows specified instead of individual look up</dd>
 * 
 *   <dt>row_offset</dt>
 *   <dd>Specifies number of rows to be skipped</dd>
 * 
 *   <dt>cell_offset</dt>
 *   <dd>Specifies number of cells to be skipped</dd>
 * </dl>
 */
class ScanSpec
{
    static public $isValidate = false;

    static public $_TSPEC = array(
        1 => array(
            'var' => 'row_intervals',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\Hypertable_ThriftGen\RowInterval',
                ),
        ),
        2 => array(
            'var' => 'cell_intervals',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\Hypertable_ThriftGen\CellInterval',
                ),
        ),
        3 => array(
            'var' => 'return_deletes',
            'isRequired' => false,
            'type' => TType::BOOL,
        ),
        4 => array(
            'var' => 'versions',
            'isRequired' => false,
            'type' => TType::I32,
        ),
        5 => array(
            'var' => 'row_limit',
            'isRequired' => false,
            'type' => TType::I32,
        ),
        6 => array(
            'var' => 'start_time',
            'isRequired' => false,
            'type' => TType::I64,
        ),
        7 => array(
            'var' => 'end_time',
            'isRequired' => false,
            'type' => TType::I64,
        ),
        8 => array(
            'var' => 'columns',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::STRING,
            'elem' => array(
                'type' => TType::STRING,
                ),
        ),
        9 => array(
            'var' => 'keys_only',
            'isRequired' => false,
            'type' => TType::BOOL,
        ),
        14 => array(
            'var' => 'cell_limit',
            'isRequired' => false,
            'type' => TType::I32,
        ),
        10 => array(
            'var' => 'cell_limit_per_family',
            'isRequired' => false,
            'type' => TType::I32,
        ),
        11 => array(
            'var' => 'row_regexp',
            'isRequired' => false,
            'type' => TType::STRING,
        ),
        12 => array(
            'var' => 'value_regexp',
            'isRequired' => false,
            'type' => TType::STRING,
        ),
        13 => array(
            'var' => 'scan_and_filter_rows',
            'isRequired' => false,
            'type' => TType::BOOL,
        ),
        15 => array(
            'var' => 'row_offset',
            'isRequired' => false,
            'type' => TType::I32,
        ),
        16 => array(
            'var' => 'cell_offset',
            'isRequired' => false,
            'type' => TType::I32,
        ),
        17 => array(
            'var' => 'column_predicates',
            'isRequired' => false,
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\Hypertable_ThriftGen\ColumnPredicate',
                ),
        ),
        18 => array(
            'var' => 'do_not_cache',
            'isRequired' => false,
            'type' => TType::BOOL,
        ),
        19 => array(
            'var' => 'and_column_predicates',
            'isRequired' => false,
            'type' => TType::BOOL,
        ),
    );

    /**
     * @var \Hypertable_ThriftGen\RowInterval[]
     */
    public $row_intervals = null;
    /**
     * @var \Hypertable_ThriftGen\CellInterval[]
     */
    public $cell_intervals = null;
    /**
     * @var bool
     */
    public $return_deletes = false;
    /**
     * @var int
     */
    public $versions = 0;
    /**
     * @var int
     */
    public $row_limit = 0;
    /**
     * @var int
     */
    public $start_time = null;
    /**
     * @var int
     */
    public $end_time = null;
    /**
     * @var string[]
     */
    public $columns = null;
    /**
     * @var bool
     */
    public $keys_only = false;
    /**
     * @var int
     */
    public $cell_limit = 0;
    /**
     * @var int
     */
    public $cell_limit_per_family = 0;
    /**
     * @var string
     */
    public $row_regexp = null;
    /**
     * @var string
     */
    public $value_regexp = null;
    /**
     * @var bool
     */
    public $scan_and_filter_rows = false;
    /**
     * @var int
     */
    public $row_offset = 0;
    /**
     * @var int
     */
    public $cell_offset = 0;
    /**
     * @var \Hypertable_ThriftGen\ColumnPredicate[]
     */
    public $column_predicates = null;
    /**
     * @var bool
     */
    public $do_not_cache = false;
    /**
     * @var bool
     */
    public $and_column_predicates = false;

    public function __construct($vals = null)
    {
        if (is_array($vals)) {
            if (isset($vals['row_intervals'])) {
                $this->row_intervals = $vals['row_intervals'];
            }
            if (isset($vals['cell_intervals'])) {
                $this->cell_intervals = $vals['cell_intervals'];
            }
            if (isset($vals['return_deletes'])) {
                $this->return_deletes = $vals['return_deletes'];
            }
            if (isset($vals['versions'])) {
                $this->versions = $vals['versions'];
            }
            if (isset($vals['row_limit'])) {
                $this->row_limit = $vals['row_limit'];
            }
            if (isset($vals['start_time'])) {
                $this->start_time = $vals['start_time'];
            }
            if (isset($vals['end_time'])) {
                $this->end_time = $vals['end_time'];
            }
            if (isset($vals['columns'])) {
                $this->columns = $vals['columns'];
            }
            if (isset($vals['keys_only'])) {
                $this->keys_only = $vals['keys_only'];
            }
            if (isset($vals['cell_limit'])) {
                $this->cell_limit = $vals['cell_limit'];
            }
            if (isset($vals['cell_limit_per_family'])) {
                $this->cell_limit_per_family = $vals['cell_limit_per_family'];
            }
            if (isset($vals['row_regexp'])) {
                $this->row_regexp = $vals['row_regexp'];
            }
            if (isset($vals['value_regexp'])) {
                $this->value_regexp = $vals['value_regexp'];
            }
            if (isset($vals['scan_and_filter_rows'])) {
                $this->scan_and_filter_rows = $vals['scan_and_filter_rows'];
            }
            if (isset($vals['row_offset'])) {
                $this->row_offset = $vals['row_offset'];
            }
            if (isset($vals['cell_offset'])) {
                $this->cell_offset = $vals['cell_offset'];
            }
            if (isset($vals['column_predicates'])) {
                $this->column_predicates = $vals['column_predicates'];
            }
            if (isset($vals['do_not_cache'])) {
                $this->do_not_cache = $vals['do_not_cache'];
            }
            if (isset($vals['and_column_predicates'])) {
                $this->and_column_predicates = $vals['and_column_predicates'];
            }
        }
    }

    public function getName()
    {
        return 'ScanSpec';
    }


    public function read($input)
    {
        $xfer = 0;
        $fname = null;
        $ftype = 0;
        $fid = 0;
        $xfer += $input->readStructBegin($fname);
        while (true) {
            $xfer += $input->readFieldBegin($fname, $ftype, $fid);
            if ($ftype == TType::STOP) {
                break;
            }
            switch ($fid) {
                case 1:
                    if ($ftype == TType::LST) {
                        $this->row_intervals = array();
                        $_size0 = 0;
                        $_etype3 = 0;
                        $xfer += $input->readListBegin($_etype3, $_size0);
                        for ($_i4 = 0; $_i4 < $_size0; ++$_i4) {
                            $elem5 = null;
                            $elem5 = new \Hypertable_ThriftGen\RowInterval();
                            $xfer += $elem5->read($input);
                            $this->row_intervals []= $elem5;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 2:
                    if ($ftype == TType::LST) {
                        $this->cell_intervals = array();
                        $_size6 = 0;
                        $_etype9 = 0;
                        $xfer += $input->readListBegin($_etype9, $_size6);
                        for ($_i10 = 0; $_i10 < $_size6; ++$_i10) {
                            $elem11 = null;
                            $elem11 = new \Hypertable_ThriftGen\CellInterval();
                            $xfer += $elem11->read($input);
                            $this->cell_intervals []= $elem11;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 3:
                    if ($ftype == TType::BOOL) {
                        $xfer += $input->readBool($this->return_deletes);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 4:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->versions);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 5:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->row_limit);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 6:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->start_time);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 7:
                    if ($ftype == TType::I64) {
                        $xfer += $input->readI64($this->end_time);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 8:
                    if ($ftype == TType::LST) {
                        $this->columns = array();
                        $_size12 = 0;
                        $_etype15 = 0;
                        $xfer += $input->readListBegin($_etype15, $_size12);
                        for ($_i16 = 0; $_i16 < $_size12; ++$_i16) {
                            $elem17 = null;
                            $xfer += $input->readString($elem17);
                            $this->columns []= $elem17;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 9:
                    if ($ftype == TType::BOOL) {
                        $xfer += $input->readBool($this->keys_only);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 14:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->cell_limit);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 10:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->cell_limit_per_family);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 11:
                    if ($ftype == TType::STRING) {
                        $xfer += $input->readString($this->row_regexp);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 12:
                    if ($ftype == TType::STRING) {
                        $xfer += $input->readString($this->value_regexp);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 13:
                    if ($ftype == TType::BOOL) {
                        $xfer += $input->readBool($this->scan_and_filter_rows);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 15:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->row_offset);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 16:
                    if ($ftype == TType::I32) {
                        $xfer += $input->readI32($this->cell_offset);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 17:
                    if ($ftype == TType::LST) {
                        $this->column_predicates = array();
                        $_size18 = 0;
                        $_etype21 = 0;
                        $xfer += $input->readListBegin($_etype21, $_size18);
                        for ($_i22 = 0; $_i22 < $_size18; ++$_i22) {
                            $elem23 = null;
                            $elem23 = new \Hypertable_ThriftGen\ColumnPredicate();
                            $xfer += $elem23->read($input);
                            $this->column_predicates []= $elem23;
                        }
                        $xfer += $input->readListEnd();
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 18:
                    if ($ftype == TType::BOOL) {
                        $xfer += $input->readBool($this->do_not_cache);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                case 19:
                    if ($ftype == TType::BOOL) {
                        $xfer += $input->readBool($this->and_column_predicates);
                    } else {
                        $xfer += $input->skip($ftype);
                    }
                    break;
                default:
                    $xfer += $input->skip($ftype);
                    break;
            }
            $xfer += $input->readFieldEnd();
        }
        $xfer += $input->readStructEnd();
        return $xfer;
    }

    public function write($output)
    {
        $xfer = 0;
        $xfer += $output->writeStructBegin('ScanSpec');
        if ($this->row_intervals !== null) {
            if (!is_array($this->row_intervals)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('row_intervals', TType::LST, 1);
            $output->writeListBegin(TType::STRUCT, count($this->row_intervals));
            foreach ($this->row_intervals as $iter24) {
                $xfer += $iter24->write($output);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->cell_intervals !== null) {
            if (!is_array($this->cell_intervals)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('cell_intervals', TType::LST, 2);
            $output->writeListBegin(TType::STRUCT, count($this->cell_intervals));
            foreach ($this->cell_intervals as $iter25) {
                $xfer += $iter25->write($output);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->return_deletes !== null) {
            $xfer += $output->writeFieldBegin('return_deletes', TType::BOOL, 3);
            $xfer += $output->writeBool($this->return_deletes);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->versions !== null) {
            $xfer += $output->writeFieldBegin('versions', TType::I32, 4);
            $xfer += $output->writeI32($this->versions);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->row_limit !== null) {
            $xfer += $output->writeFieldBegin('row_limit', TType::I32, 5);
            $xfer += $output->writeI32($this->row_limit);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->start_time !== null) {
            $xfer += $output->writeFieldBegin('start_time', TType::I64, 6);
            $xfer += $output->writeI64($this->start_time);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->end_time !== null) {
            $xfer += $output->writeFieldBegin('end_time', TType::I64, 7);
            $xfer += $output->writeI64($this->end_time);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->columns !== null) {
            if (!is_array($this->columns)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('columns', TType::LST, 8);
            $output->writeListBegin(TType::STRING, count($this->columns));
            foreach ($this->columns as $iter26) {
                $xfer += $output->writeString($iter26);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->keys_only !== null) {
            $xfer += $output->writeFieldBegin('keys_only', TType::BOOL, 9);
            $xfer += $output->writeBool($this->keys_only);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->cell_limit_per_family !== null) {
            $xfer += $output->writeFieldBegin('cell_limit_per_family', TType::I32, 10);
            $xfer += $output->writeI32($this->cell_limit_per_family);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->row_regexp !== null) {
            $xfer += $output->writeFieldBegin('row_regexp', TType::STRING, 11);
            $xfer += $output->writeString($this->row_regexp);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->value_regexp !== null) {
            $xfer += $output->writeFieldBegin('value_regexp', TType::STRING, 12);
            $xfer += $output->writeString($this->value_regexp);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->scan_and_filter_rows !== null) {
            $xfer += $output->writeFieldBegin('scan_and_filter_rows', TType::BOOL, 13);
            $xfer += $output->writeBool($this->scan_and_filter_rows);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->cell_limit !== null) {
            $xfer += $output->writeFieldBegin('cell_limit', TType::I32, 14);
            $xfer += $output->writeI32($this->cell_limit);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->row_offset !== null) {
            $xfer += $output->writeFieldBegin('row_offset', TType::I32, 15);
            $xfer += $output->writeI32($this->row_offset);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->cell_offset !== null) {
            $xfer += $output->writeFieldBegin('cell_offset', TType::I32, 16);
            $xfer += $output->writeI32($this->cell_offset);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->column_predicates !== null) {
            if (!is_array($this->column_predicates)) {
                throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
            }
            $xfer += $output->writeFieldBegin('column_predicates', TType::LST, 17);
            $output->writeListBegin(TType::STRUCT, count($this->column_predicates));
            foreach ($this->column_predicates as $iter27) {
                $xfer += $iter27->write($output);
            }
            $output->writeListEnd();
            $xfer += $output->writeFieldEnd();
        }
        if ($this->do_not_cache !== null) {
            $xfer += $output->writeFieldBegin('do_not_cache', TType::BOOL, 18);
            $xfer += $output->writeBool($this->do_not_cache);
            $xfer += $output->writeFieldEnd();
        }
        if ($this->and_column_predicates !== null) {
            $xfer += $output->writeFieldBegin('and_column_predicates', TType::BOOL, 19);
            $xfer += $output->writeBool($this->and_column_predicates);
            $xfer += $output->writeFieldEnd();
        }
        $xfer += $output->writeFieldStop();
        $xfer += $output->writeStructEnd();
        return $xfer;
    }
}
