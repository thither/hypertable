#
# Autogenerated by Thrift Compiler (0.12.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
use 5.10.0;
use strict;
use warnings;
use Thrift::Exception;
use Thrift::MessageType;
use Thrift::Type;

use Hypertable::ThriftGen::Types;


# HELPER FUNCTIONS AND STRUCTURES

package Hypertable::ThriftGen::ClientService_namespace_create_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_create_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_create_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_create_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_create_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_create_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_create_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_create_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_create_namespace_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_create_namespace_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_create_namespace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_namespace_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_create_namespace_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_create_namespace_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_create_namespace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_namespace_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_create_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_create_args->mk_accessors( qw( ns table_name schema ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{schema} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{schema}) {
      $self->{schema} = $vals->{schema};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_create_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{schema} = Hypertable::ThriftGen::Schema->new();
        $xfer += $self->{schema}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_create_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{schema}) {
    $xfer += $output->writeFieldBegin('schema', Thrift::TType::STRUCT, 3);
    $xfer += $self->{schema}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_create_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_create_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_create_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_create_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_alter_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_alter_args->mk_accessors( qw( ns table_name schema ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{schema} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{schema}) {
      $self->{schema} = $vals->{schema};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_alter_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{schema} = Hypertable::ThriftGen::Schema->new();
        $xfer += $self->{schema}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_alter_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{schema}) {
    $xfer += $output->writeFieldBegin('schema', Thrift::TType::STRUCT, 3);
    $xfer += $self->{schema}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_alter_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_alter_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_alter_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_alter_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_refresh_table_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_refresh_table_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_refresh_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_refresh_table_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_refresh_table_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_refresh_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_refresh_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_refresh_table_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_open_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_open_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_open_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_open_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_open_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_open_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_open_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_open_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_namespace_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_namespace_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_namespace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_namespace_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_namespace_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_namespace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_namespace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_namespace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_close_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_close_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_close_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_close_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_close_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_close_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_close_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_close_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_namespace_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_namespace_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_namespace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_namespace_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_namespace_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_namespace_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_namespace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_namespace_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_open_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_open_args->mk_accessors( qw( capacity ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{capacity} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{capacity}) {
      $self->{capacity} = $vals->{capacity};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_open_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{capacity});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_open_args');
  if (defined $self->{capacity}) {
    $xfer += $output->writeFieldBegin('capacity', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{capacity});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_open_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_open_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_open_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_open_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_future_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_future_args->mk_accessors( qw( capacity ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{capacity} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{capacity}) {
      $self->{capacity} = $vals->{capacity};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_future_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{capacity});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_future_args');
  if (defined $self->{capacity}) {
    $xfer += $output->writeFieldBegin('capacity', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{capacity});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_future_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_future_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_future_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_future_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_cancel_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_cancel_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_cancel_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_cancel_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_cancel_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_cancel_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_cancel_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_cancel_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_cancel_future_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_cancel_future_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_cancel_future_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_cancel_future_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_cancel_future_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_cancel_future_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_cancel_future_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_cancel_future_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_get_result_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_get_result_args->mk_accessors( qw( ff timeout_millis ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  $self->{timeout_millis} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
    if (defined $vals->{timeout_millis}) {
      $self->{timeout_millis} = $vals->{timeout_millis};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_get_result_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{timeout_millis});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_get_result_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timeout_millis}) {
    $xfer += $output->writeFieldBegin('timeout_millis', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{timeout_millis});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_get_result_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_get_result_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_get_result_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = Hypertable::ThriftGen::Result->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_get_result_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_future_result_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_future_result_args->mk_accessors( qw( ff timeout_millis ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  $self->{timeout_millis} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
    if (defined $vals->{timeout_millis}) {
      $self->{timeout_millis} = $vals->{timeout_millis};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_future_result_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{timeout_millis});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_future_result_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timeout_millis}) {
    $xfer += $output->writeFieldBegin('timeout_millis', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{timeout_millis});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_future_result_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_future_result_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_future_result_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = Hypertable::ThriftGen::Result->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_future_result_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_args->mk_accessors( qw( ff timeout_millis ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  $self->{timeout_millis} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
    if (defined $vals->{timeout_millis}) {
      $self->{timeout_millis} = $vals->{timeout_millis};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_get_result_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{timeout_millis});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_get_result_as_arrays_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timeout_millis}) {
    $xfer += $output->writeFieldBegin('timeout_millis', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{timeout_millis});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_get_result_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = Hypertable::ThriftGen::ResultAsArrays->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_get_result_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_args->mk_accessors( qw( ff timeout_millis ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  $self->{timeout_millis} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
    if (defined $vals->{timeout_millis}) {
      $self->{timeout_millis} = $vals->{timeout_millis};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_future_result_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{timeout_millis});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_future_result_as_arrays_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timeout_millis}) {
    $xfer += $output->writeFieldBegin('timeout_millis', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{timeout_millis});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_future_result_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = Hypertable::ThriftGen::ResultAsArrays->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_future_result_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_get_result_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_get_result_serialized_args->mk_accessors( qw( ff timeout_millis ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  $self->{timeout_millis} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
    if (defined $vals->{timeout_millis}) {
      $self->{timeout_millis} = $vals->{timeout_millis};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_get_result_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{timeout_millis});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_get_result_serialized_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timeout_millis}) {
    $xfer += $output->writeFieldBegin('timeout_millis', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{timeout_millis});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_get_result_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_get_result_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_get_result_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = Hypertable::ThriftGen::ResultSerialized->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_get_result_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_future_result_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_future_result_serialized_args->mk_accessors( qw( ff timeout_millis ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  $self->{timeout_millis} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
    if (defined $vals->{timeout_millis}) {
      $self->{timeout_millis} = $vals->{timeout_millis};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_future_result_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{timeout_millis});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_future_result_serialized_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timeout_millis}) {
    $xfer += $output->writeFieldBegin('timeout_millis', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{timeout_millis});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_future_result_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_future_result_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_future_result_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = Hypertable::ThriftGen::ResultSerialized->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_future_result_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_is_empty_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_is_empty_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_is_empty_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_is_empty_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_is_empty_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_is_empty_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_is_empty_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_is_empty_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_is_full_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_is_full_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_is_full_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_is_full_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_is_full_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_is_full_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_is_full_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_is_full_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_is_cancelled_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_is_cancelled_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_is_cancelled_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_is_cancelled_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_is_cancelled_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_is_cancelled_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_is_cancelled_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_is_cancelled_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_has_outstanding_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_has_outstanding_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_has_outstanding_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_has_outstanding_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_has_outstanding_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_has_outstanding_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_has_outstanding_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_has_outstanding_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_close_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_close_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_close_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_close_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_close_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_close_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_close_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_close_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_future_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_future_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_future_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_future_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_future_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_future_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_future_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_future_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_open_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_open_args->mk_accessors( qw( ns table_name scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_open_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{scan_spec} = Hypertable::ThriftGen::ScanSpec->new();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_open_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', Thrift::TType::STRUCT, 3);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_open_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_open_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_open_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_open_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_scanner_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_scanner_args->mk_accessors( qw( ns table_name scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_scanner_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{scan_spec} = Hypertable::ThriftGen::ScanSpec->new();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_scanner_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', Thrift::TType::STRUCT, 3);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_scanner_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_scanner_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_scanner_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_scanner_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_scanner_open_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_scanner_open_args->mk_accessors( qw( ns table_name future scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{future} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{future}) {
      $self->{future} = $vals->{future};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_scanner_open_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{future});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{scan_spec} = Hypertable::ThriftGen::ScanSpec->new();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_scanner_open_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{future}) {
    $xfer += $output->writeFieldBegin('future', Thrift::TType::I64, 3);
    $xfer += $output->writeI64($self->{future});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', Thrift::TType::STRUCT, 4);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_scanner_open_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_scanner_open_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_scanner_open_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_scanner_open_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_scanner_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_scanner_async_args->mk_accessors( qw( ns table_name future scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{future} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{future}) {
      $self->{future} = $vals->{future};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_scanner_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{future});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{scan_spec} = Hypertable::ThriftGen::ScanSpec->new();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_scanner_async_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{future}) {
    $xfer += $output->writeFieldBegin('future', Thrift::TType::I64, 3);
    $xfer += $output->writeI64($self->{future});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', Thrift::TType::STRUCT, 4);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_scanner_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_scanner_async_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_scanner_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_scanner_async_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_close_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_close_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_close_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_close_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_close_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_close_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_close_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_close_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_scanner_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_scanner_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_scanner_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_scanner_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_scanner_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_scanner_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_scanner_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_scanner_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_scanner_cancel_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_scanner_cancel_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_scanner_cancel_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_scanner_cancel_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_scanner_cancel_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_scanner_cancel_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_scanner_cancel_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_scanner_cancel_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_cancel_scanner_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_cancel_scanner_async_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_cancel_scanner_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_cancel_scanner_async_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_cancel_scanner_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_cancel_scanner_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_cancel_scanner_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_cancel_scanner_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_scanner_close_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_scanner_close_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_scanner_close_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_scanner_close_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_scanner_close_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_scanner_close_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_scanner_close_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_scanner_close_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_scanner_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_scanner_async_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_scanner_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_scanner_async_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_scanner_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_scanner_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_scanner_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_scanner_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_cells_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_cells_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_cells_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size67 = 0;
          $self->{success} = [];
          my $_etype70 = 0;
          $xfer += $input->readListBegin(\$_etype70, \$_size67);
          for (my $_i71 = 0; $_i71 < $_size67; ++$_i71)
          {
            my $elem72 = undef;
            $elem72 = Hypertable::ThriftGen::Cell->new();
            $xfer += $elem72->read($input);
            push(@{$self->{success}},$elem72);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_cells_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter73 (@{$self->{success}}) 
        {
          $xfer += ${iter73}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size74 = 0;
          $self->{success} = [];
          my $_etype77 = 0;
          $xfer += $input->readListBegin(\$_etype77, \$_size74);
          for (my $_i78 = 0; $_i78 < $_size74; ++$_i78)
          {
            my $elem79 = undef;
            $elem79 = Hypertable::ThriftGen::Cell->new();
            $xfer += $elem79->read($input);
            push(@{$self->{success}},$elem79);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter80 (@{$self->{success}}) 
        {
          $xfer += ${iter80}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_cells_as_arrays_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size81 = 0;
          $self->{success} = [];
          my $_etype84 = 0;
          $xfer += $input->readListBegin(\$_etype84, \$_size81);
          for (my $_i85 = 0; $_i85 < $_size81; ++$_i85)
          {
            my $elem86 = undef;
            {
              my $_size87 = 0;
              $elem86 = [];
              my $_etype90 = 0;
              $xfer += $input->readListBegin(\$_etype90, \$_size87);
              for (my $_i91 = 0; $_i91 < $_size87; ++$_i91)
              {
                my $elem92 = undef;
                $xfer += $input->readString(\$elem92);
                push(@{$elem86},$elem92);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem86);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_cells_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter93 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{${iter93}}));
            {
              foreach my $iter94 (@{${iter93}}) 
              {
                $xfer += $output->writeString($iter94);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_as_arrays_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_as_arrays_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size95 = 0;
          $self->{success} = [];
          my $_etype98 = 0;
          $xfer += $input->readListBegin(\$_etype98, \$_size95);
          for (my $_i99 = 0; $_i99 < $_size95; ++$_i99)
          {
            my $elem100 = undef;
            {
              my $_size101 = 0;
              $elem100 = [];
              my $_etype104 = 0;
              $xfer += $input->readListBegin(\$_etype104, \$_size101);
              for (my $_i105 = 0; $_i105 < $_size101; ++$_i105)
              {
                my $elem106 = undef;
                $xfer += $input->readString(\$elem106);
                push(@{$elem100},$elem106);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem100);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter107 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{${iter107}}));
            {
              foreach my $iter108 (@{${iter107}}) 
              {
                $xfer += $output->writeString($iter108);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_cells_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_cells_serialized_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_cells_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_cells_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_serialized_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_serialized_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_row_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_row_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_row_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_row_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_row_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_row_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_row_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size109 = 0;
          $self->{success} = [];
          my $_etype112 = 0;
          $xfer += $input->readListBegin(\$_etype112, \$_size109);
          for (my $_i113 = 0; $_i113 < $_size109; ++$_i113)
          {
            my $elem114 = undef;
            $elem114 = Hypertable::ThriftGen::Cell->new();
            $xfer += $elem114->read($input);
            push(@{$self->{success}},$elem114);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_row_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter115 (@{$self->{success}}) 
        {
          $xfer += ${iter115}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size116 = 0;
          $self->{success} = [];
          my $_etype119 = 0;
          $xfer += $input->readListBegin(\$_etype119, \$_size116);
          for (my $_i120 = 0; $_i120 < $_size116; ++$_i120)
          {
            my $elem121 = undef;
            $elem121 = Hypertable::ThriftGen::Cell->new();
            $xfer += $elem121->read($input);
            push(@{$self->{success}},$elem121);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter122 (@{$self->{success}}) 
        {
          $xfer += ${iter122}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_row_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_row_as_arrays_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_row_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size123 = 0;
          $self->{success} = [];
          my $_etype126 = 0;
          $xfer += $input->readListBegin(\$_etype126, \$_size123);
          for (my $_i127 = 0; $_i127 < $_size123; ++$_i127)
          {
            my $elem128 = undef;
            {
              my $_size129 = 0;
              $elem128 = [];
              my $_etype132 = 0;
              $xfer += $input->readListBegin(\$_etype132, \$_size129);
              for (my $_i133 = 0; $_i133 < $_size129; ++$_i133)
              {
                my $elem134 = undef;
                $xfer += $input->readString(\$elem134);
                push(@{$elem128},$elem134);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem128);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_row_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter135 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{${iter135}}));
            {
              foreach my $iter136 (@{${iter135}}) 
              {
                $xfer += $output->writeString($iter136);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_as_arrays_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_as_arrays_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size137 = 0;
          $self->{success} = [];
          my $_etype140 = 0;
          $xfer += $input->readListBegin(\$_etype140, \$_size137);
          for (my $_i141 = 0; $_i141 < $_size137; ++$_i141)
          {
            my $elem142 = undef;
            {
              my $_size143 = 0;
              $elem142 = [];
              my $_etype146 = 0;
              $xfer += $input->readListBegin(\$_etype146, \$_size143);
              for (my $_i147 = 0; $_i147 < $_size143; ++$_i147)
              {
                my $elem148 = undef;
                $xfer += $input->readString(\$elem148);
                push(@{$elem142},$elem148);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem142);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter149 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{${iter149}}));
            {
              foreach my $iter150 (@{${iter149}}) 
              {
                $xfer += $output->writeString($iter150);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_row_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_row_serialized_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_row_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_row_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_serialized_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_serialized_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_args->mk_accessors( qw( ns table_name row ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{row} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size151 = 0;
          $self->{success} = [];
          my $_etype154 = 0;
          $xfer += $input->readListBegin(\$_etype154, \$_size151);
          for (my $_i155 = 0; $_i155 < $_size151; ++$_i155)
          {
            my $elem156 = undef;
            $elem156 = Hypertable::ThriftGen::Cell->new();
            $xfer += $elem156->read($input);
            push(@{$self->{success}},$elem156);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter157 (@{$self->{success}}) 
        {
          $xfer += ${iter157}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_as_arrays_args->mk_accessors( qw( ns name row ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  $self->{row} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_as_arrays_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size158 = 0;
          $self->{success} = [];
          my $_etype161 = 0;
          $xfer += $input->readListBegin(\$_etype161, \$_size158);
          for (my $_i162 = 0; $_i162 < $_size158; ++$_i162)
          {
            my $elem163 = undef;
            {
              my $_size164 = 0;
              $elem163 = [];
              my $_etype167 = 0;
              $xfer += $input->readListBegin(\$_etype167, \$_size164);
              for (my $_i168 = 0; $_i168 < $_size164; ++$_i168)
              {
                my $elem169 = undef;
                $xfer += $input->readString(\$elem169);
                push(@{$elem163},$elem169);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem163);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter170 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{${iter170}}));
            {
              foreach my $iter171 (@{${iter170}}) 
              {
                $xfer += $output->writeString($iter171);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_serialized_args->mk_accessors( qw( ns table_name row ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{row} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_serialized_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cell_args->mk_accessors( qw( ns table_name row column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cell_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', Thrift::TType::STRING, 4);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cell_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cell_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_args->mk_accessors( qw( ns table_name scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{scan_spec} = Hypertable::ThriftGen::ScanSpec->new();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', Thrift::TType::STRUCT, 3);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size172 = 0;
          $self->{success} = [];
          my $_etype175 = 0;
          $xfer += $input->readListBegin(\$_etype175, \$_size172);
          for (my $_i176 = 0; $_i176 < $_size172; ++$_i176)
          {
            my $elem177 = undef;
            $elem177 = Hypertable::ThriftGen::Cell->new();
            $xfer += $elem177->read($input);
            push(@{$self->{success}},$elem177);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter178 (@{$self->{success}}) 
        {
          $xfer += ${iter178}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_as_arrays_args->mk_accessors( qw( ns name scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{scan_spec} = Hypertable::ThriftGen::ScanSpec->new();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_as_arrays_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', Thrift::TType::STRUCT, 3);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size179 = 0;
          $self->{success} = [];
          my $_etype182 = 0;
          $xfer += $input->readListBegin(\$_etype182, \$_size179);
          for (my $_i183 = 0; $_i183 < $_size179; ++$_i183)
          {
            my $elem184 = undef;
            {
              my $_size185 = 0;
              $elem184 = [];
              my $_etype188 = 0;
              $xfer += $input->readListBegin(\$_etype188, \$_size185);
              for (my $_i189 = 0; $_i189 < $_size185; ++$_i189)
              {
                my $elem190 = undef;
                $xfer += $input->readString(\$elem190);
                push(@{$elem184},$elem190);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem184);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter191 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{${iter191}}));
            {
              foreach my $iter192 (@{${iter191}}) 
              {
                $xfer += $output->writeString($iter192);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_serialized_args->mk_accessors( qw( ns name scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{scan_spec} = Hypertable::ThriftGen::ScanSpec->new();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_serialized_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', Thrift::TType::STRUCT, 3);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_refresh_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_refresh_args->mk_accessors( qw( ns table_name mutate_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_refresh_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{mutate_spec} = Hypertable::ThriftGen::MutateSpec->new();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_refresh_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', Thrift::TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_refresh_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_refresh_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_refresh_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_refresh_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_refresh_shared_mutator_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_refresh_shared_mutator_args->mk_accessors( qw( ns table_name mutate_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_refresh_shared_mutator_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{mutate_spec} = Hypertable::ThriftGen::MutateSpec->new();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_refresh_shared_mutator_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', Thrift::TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_refresh_shared_mutator_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_refresh_shared_mutator_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_refresh_shared_mutator_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_refresh_shared_mutator_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_args->mk_accessors( qw( ns table_name mutate_spec cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_set_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{mutate_spec} = Hypertable::ThriftGen::MutateSpec->new();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size193 = 0;
          $self->{cells} = [];
          my $_etype196 = 0;
          $xfer += $input->readListBegin(\$_etype196, \$_size193);
          for (my $_i197 = 0; $_i197 < $_size193; ++$_i197)
          {
            my $elem198 = undef;
            $elem198 = Hypertable::ThriftGen::Cell->new();
            $xfer += $elem198->read($input);
            push(@{$self->{cells}},$elem198);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_set_cells_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', Thrift::TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', Thrift::TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter199 (@{$self->{cells}}) 
        {
          $xfer += ${iter199}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_set_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_set_cells_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cells_args->mk_accessors( qw( ns table_name mutate_spec cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{mutate_spec} = Hypertable::ThriftGen::MutateSpec->new();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size200 = 0;
          $self->{cells} = [];
          my $_etype203 = 0;
          $xfer += $input->readListBegin(\$_etype203, \$_size200);
          for (my $_i204 = 0; $_i204 < $_size200; ++$_i204)
          {
            my $elem205 = undef;
            $elem205 = Hypertable::ThriftGen::Cell->new();
            $xfer += $elem205->read($input);
            push(@{$self->{cells}},$elem205);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cells_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', Thrift::TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', Thrift::TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter206 (@{$self->{cells}}) 
        {
          $xfer += ${iter206}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cells_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cells_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_as_arrays_args->mk_accessors( qw( ns table_name mutate_spec cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_set_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{mutate_spec} = Hypertable::ThriftGen::MutateSpec->new();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size207 = 0;
          $self->{cells} = [];
          my $_etype210 = 0;
          $xfer += $input->readListBegin(\$_etype210, \$_size207);
          for (my $_i211 = 0; $_i211 < $_size207; ++$_i211)
          {
            my $elem212 = undef;
            {
              my $_size213 = 0;
              $elem212 = [];
              my $_etype216 = 0;
              $xfer += $input->readListBegin(\$_etype216, \$_size213);
              for (my $_i217 = 0; $_i217 < $_size213; ++$_i217)
              {
                my $elem218 = undef;
                $xfer += $input->readString(\$elem218);
                push(@{$elem212},$elem218);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem212);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_set_cells_as_arrays_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', Thrift::TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', Thrift::TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(Thrift::TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter219 (@{$self->{cells}}) 
        {
          {
            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{${iter219}}));
            {
              foreach my $iter220 (@{${iter219}}) 
              {
                $xfer += $output->writeString($iter220);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_as_arrays_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_set_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_set_cells_as_arrays_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_args->mk_accessors( qw( ns table_name mutate_spec cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{mutate_spec} = Hypertable::ThriftGen::MutateSpec->new();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size221 = 0;
          $self->{cells} = [];
          my $_etype224 = 0;
          $xfer += $input->readListBegin(\$_etype224, \$_size221);
          for (my $_i225 = 0; $_i225 < $_size221; ++$_i225)
          {
            my $elem226 = undef;
            {
              my $_size227 = 0;
              $elem226 = [];
              my $_etype230 = 0;
              $xfer += $input->readListBegin(\$_etype230, \$_size227);
              for (my $_i231 = 0; $_i231 < $_size227; ++$_i231)
              {
                my $elem232 = undef;
                $xfer += $input->readString(\$elem232);
                push(@{$elem226},$elem232);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem226);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cells_as_arrays_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', Thrift::TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', Thrift::TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(Thrift::TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter233 (@{$self->{cells}}) 
        {
          {
            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{${iter233}}));
            {
              foreach my $iter234 (@{${iter233}}) 
              {
                $xfer += $output->writeString($iter234);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cells_as_arrays_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_args->mk_accessors( qw( ns table_name mutate_spec cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_set_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{mutate_spec} = Hypertable::ThriftGen::MutateSpec->new();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{cell} = Hypertable::ThriftGen::Cell->new();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_set_cell_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', Thrift::TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', Thrift::TType::STRUCT, 4);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_set_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_set_cell_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cell_args->mk_accessors( qw( ns table_name mutate_spec cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{mutate_spec} = Hypertable::ThriftGen::MutateSpec->new();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{cell} = Hypertable::ThriftGen::Cell->new();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cell_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', Thrift::TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', Thrift::TType::STRUCT, 4);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cell_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cell_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_as_array_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_as_array_args->mk_accessors( qw( ns table_name mutate_spec cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_set_cell_as_array_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{mutate_spec} = Hypertable::ThriftGen::MutateSpec->new();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size235 = 0;
          $self->{cell} = [];
          my $_etype238 = 0;
          $xfer += $input->readListBegin(\$_etype238, \$_size235);
          for (my $_i239 = 0; $_i239 < $_size235; ++$_i239)
          {
            my $elem240 = undef;
            $xfer += $input->readString(\$elem240);
            push(@{$self->{cell}},$elem240);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_set_cell_as_array_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', Thrift::TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', Thrift::TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{cell}}));
      {
        foreach my $iter241 (@{$self->{cell}}) 
        {
          $xfer += $output->writeString($iter241);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_as_array_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_as_array_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shared_mutator_set_cell_as_array_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shared_mutator_set_cell_as_array_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cell_as_array_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cell_as_array_args->mk_accessors( qw( ns table_name mutate_spec cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cell_as_array_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{mutate_spec} = Hypertable::ThriftGen::MutateSpec->new();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size242 = 0;
          $self->{cell} = [];
          my $_etype245 = 0;
          $xfer += $input->readListBegin(\$_etype245, \$_size242);
          for (my $_i246 = 0; $_i246 < $_size242; ++$_i246)
          {
            my $elem247 = undef;
            $xfer += $input->readString(\$elem247);
            push(@{$self->{cell}},$elem247);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cell_as_array_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', Thrift::TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', Thrift::TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{cell}}));
      {
        foreach my $iter248 (@{$self->{cell}}) 
        {
          $xfer += $output->writeString($iter248);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cell_as_array_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cell_as_array_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cell_as_array_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cell_as_array_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_open_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_open_args->mk_accessors( qw( ns table_name flags flush_interval ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{flags} = 0;
  $self->{flush_interval} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{flags}) {
      $self->{flags} = $vals->{flags};
    }
    if (defined $vals->{flush_interval}) {
      $self->{flush_interval} = $vals->{flush_interval};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_open_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{flags});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{flush_interval});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_open_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flags}) {
    $xfer += $output->writeFieldBegin('flags', Thrift::TType::I32, 3);
    $xfer += $output->writeI32($self->{flags});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush_interval}) {
    $xfer += $output->writeFieldBegin('flush_interval', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{flush_interval});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_open_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_open_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_open_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_open_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_mutator_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_mutator_args->mk_accessors( qw( ns table_name flags flush_interval ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{flags} = 0;
  $self->{flush_interval} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{flags}) {
      $self->{flags} = $vals->{flags};
    }
    if (defined $vals->{flush_interval}) {
      $self->{flush_interval} = $vals->{flush_interval};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_mutator_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{flags});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{flush_interval});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_mutator_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flags}) {
    $xfer += $output->writeFieldBegin('flags', Thrift::TType::I32, 3);
    $xfer += $output->writeI32($self->{flags});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush_interval}) {
    $xfer += $output->writeFieldBegin('flush_interval', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{flush_interval});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_mutator_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_mutator_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_mutator_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_mutator_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_open_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_open_args->mk_accessors( qw( ns table_name future flags ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{future} = undef;
  $self->{flags} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{future}) {
      $self->{future} = $vals->{future};
    }
    if (defined $vals->{flags}) {
      $self->{flags} = $vals->{flags};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_open_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{future});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{flags});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_open_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{future}) {
    $xfer += $output->writeFieldBegin('future', Thrift::TType::I64, 3);
    $xfer += $output->writeI64($self->{future});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flags}) {
    $xfer += $output->writeFieldBegin('flags', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{flags});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_open_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_open_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_open_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_open_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_mutator_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_mutator_async_args->mk_accessors( qw( ns table_name future flags ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{future} = undef;
  $self->{flags} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{future}) {
      $self->{future} = $vals->{future};
    }
    if (defined $vals->{flags}) {
      $self->{flags} = $vals->{flags};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_mutator_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{future});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{flags});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_mutator_async_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{future}) {
    $xfer += $output->writeFieldBegin('future', Thrift::TType::I64, 3);
    $xfer += $output->writeI64($self->{future});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flags}) {
    $xfer += $output->writeFieldBegin('flags', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{flags});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_mutator_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_mutator_async_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_mutator_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_mutator_async_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_close_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_close_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_close_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_close_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_close_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_close_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_close_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_close_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_mutator_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_mutator_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_mutator_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_mutator_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_mutator_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_mutator_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_mutator_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_mutator_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_cancel_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_cancel_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_cancel_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_cancel_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_cancel_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_cancel_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_cancel_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_cancel_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_cancel_mutator_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_cancel_mutator_async_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_cancel_mutator_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_cancel_mutator_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_cancel_mutator_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_cancel_mutator_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_cancel_mutator_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_cancel_mutator_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_close_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_close_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_close_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_close_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_close_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_close_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_close_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_close_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_mutator_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_mutator_async_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_mutator_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_mutator_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_mutator_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_mutator_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_mutator_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_mutator_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cell_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{cell} = Hypertable::ThriftGen::Cell->new();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cell_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', Thrift::TType::STRUCT, 2);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cell_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cell_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_args->mk_accessors( qw( ns table_name cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{cell} = Hypertable::ThriftGen::Cell->new();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', Thrift::TType::STRUCT, 3);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cell_as_array_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size249 = 0;
          $self->{cell} = [];
          my $_etype252 = 0;
          $xfer += $input->readListBegin(\$_etype252, \$_size249);
          for (my $_i253 = 0; $_i253 < $_size249; ++$_i253)
          {
            my $elem254 = undef;
            $xfer += $input->readString(\$elem254);
            push(@{$self->{cell}},$elem254);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cell_as_array_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{cell}}));
      {
        foreach my $iter255 (@{$self->{cell}}) 
        {
          $xfer += $output->writeString($iter255);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cell_as_array_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cell_as_array_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_as_array_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_as_array_args->mk_accessors( qw( ns table_name cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_as_array_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size256 = 0;
          $self->{cell} = [];
          my $_etype259 = 0;
          $xfer += $input->readListBegin(\$_etype259, \$_size256);
          for (my $_i260 = 0; $_i260 < $_size256; ++$_i260)
          {
            my $elem261 = undef;
            $xfer += $input->readString(\$elem261);
            push(@{$self->{cell}},$elem261);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_as_array_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', Thrift::TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{cell}}));
      {
        foreach my $iter262 (@{$self->{cell}}) 
        {
          $xfer += $output->writeString($iter262);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_as_array_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_as_array_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_as_array_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_as_array_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cells_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size263 = 0;
          $self->{cells} = [];
          my $_etype266 = 0;
          $xfer += $input->readListBegin(\$_etype266, \$_size263);
          for (my $_i267 = 0; $_i267 < $_size263; ++$_i267)
          {
            my $elem268 = undef;
            $elem268 = Hypertable::ThriftGen::Cell->new();
            $xfer += $elem268->read($input);
            push(@{$self->{cells}},$elem268);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cells_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter269 (@{$self->{cells}}) 
        {
          $xfer += ${iter269}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cells_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cells_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_args->mk_accessors( qw( ns table_name cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size270 = 0;
          $self->{cells} = [];
          my $_etype273 = 0;
          $xfer += $input->readListBegin(\$_etype273, \$_size270);
          for (my $_i274 = 0; $_i274 < $_size270; ++$_i274)
          {
            my $elem275 = undef;
            $elem275 = Hypertable::ThriftGen::Cell->new();
            $xfer += $elem275->read($input);
            push(@{$self->{cells}},$elem275);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', Thrift::TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter276 (@{$self->{cells}}) 
        {
          $xfer += ${iter276}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size277 = 0;
          $self->{cells} = [];
          my $_etype280 = 0;
          $xfer += $input->readListBegin(\$_etype280, \$_size277);
          for (my $_i281 = 0; $_i281 < $_size277; ++$_i281)
          {
            my $elem282 = undef;
            {
              my $_size283 = 0;
              $elem282 = [];
              my $_etype286 = 0;
              $xfer += $input->readListBegin(\$_etype286, \$_size283);
              for (my $_i287 = 0; $_i287 < $_size283; ++$_i287)
              {
                my $elem288 = undef;
                $xfer += $input->readString(\$elem288);
                push(@{$elem282},$elem288);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem282);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cells_as_arrays_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter289 (@{$self->{cells}}) 
        {
          {
            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{${iter289}}));
            {
              foreach my $iter290 (@{${iter289}}) 
              {
                $xfer += $output->writeString($iter290);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cells_as_arrays_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_as_arrays_args->mk_accessors( qw( ns table_name cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size291 = 0;
          $self->{cells} = [];
          my $_etype294 = 0;
          $xfer += $input->readListBegin(\$_etype294, \$_size291);
          for (my $_i295 = 0; $_i295 < $_size291; ++$_i295)
          {
            my $elem296 = undef;
            {
              my $_size297 = 0;
              $elem296 = [];
              my $_etype300 = 0;
              $xfer += $input->readListBegin(\$_etype300, \$_size297);
              for (my $_i301 = 0; $_i301 < $_size297; ++$_i301)
              {
                my $elem302 = undef;
                $xfer += $input->readString(\$elem302);
                push(@{$elem296},$elem302);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem296);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_as_arrays_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', Thrift::TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(Thrift::TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter303 (@{$self->{cells}}) 
        {
          {
            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{${iter303}}));
            {
              foreach my $iter304 (@{${iter303}}) 
              {
                $xfer += $output->writeString($iter304);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_as_arrays_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_as_arrays_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_args->mk_accessors( qw( mutator cells flush ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  $self->{flush} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
    if (defined $vals->{flush}) {
      $self->{flush} = $vals->{flush};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cells_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{cells});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{flush});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cells_serialized_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{cells});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush}) {
    $xfer += $output->writeFieldBegin('flush', Thrift::TType::BOOL, 3);
    $xfer += $output->writeBool($self->{flush});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cells_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cells_serialized_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_serialized_args->mk_accessors( qw( ns table_name cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{cells});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_serialized_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{cells});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_serialized_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_serialized_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_flush_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_flush_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_flush_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_flush_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_flush_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_flush_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_flush_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_flush_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_flush_mutator_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_flush_mutator_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_flush_mutator_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_flush_mutator_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_flush_mutator_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_flush_mutator_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_flush_mutator_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_flush_mutator_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cell_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{cell} = Hypertable::ThriftGen::Cell->new();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cell_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', Thrift::TType::STRUCT, 2);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cell_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cell_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_async_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{cell} = Hypertable::ThriftGen::Cell->new();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', Thrift::TType::STRUCT, 2);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cell_as_array_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size305 = 0;
          $self->{cell} = [];
          my $_etype308 = 0;
          $xfer += $input->readListBegin(\$_etype308, \$_size305);
          for (my $_i309 = 0; $_i309 < $_size305; ++$_i309)
          {
            my $elem310 = undef;
            $xfer += $input->readString(\$elem310);
            push(@{$self->{cell}},$elem310);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cell_as_array_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{cell}}));
      {
        foreach my $iter311 (@{$self->{cell}}) 
        {
          $xfer += $output->writeString($iter311);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cell_as_array_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cell_as_array_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_as_array_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_as_array_async_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_as_array_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size312 = 0;
          $self->{cell} = [];
          my $_etype315 = 0;
          $xfer += $input->readListBegin(\$_etype315, \$_size312);
          for (my $_i316 = 0; $_i316 < $_size312; ++$_i316)
          {
            my $elem317 = undef;
            $xfer += $input->readString(\$elem317);
            push(@{$self->{cell}},$elem317);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_as_array_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{cell}}));
      {
        foreach my $iter318 (@{$self->{cell}}) 
        {
          $xfer += $output->writeString($iter318);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_as_array_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_as_array_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_as_array_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_as_array_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cells_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size319 = 0;
          $self->{cells} = [];
          my $_etype322 = 0;
          $xfer += $input->readListBegin(\$_etype322, \$_size319);
          for (my $_i323 = 0; $_i323 < $_size319; ++$_i323)
          {
            my $elem324 = undef;
            $elem324 = Hypertable::ThriftGen::Cell->new();
            $xfer += $elem324->read($input);
            push(@{$self->{cells}},$elem324);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cells_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter325 (@{$self->{cells}}) 
        {
          $xfer += ${iter325}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cells_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cells_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_async_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size326 = 0;
          $self->{cells} = [];
          my $_etype329 = 0;
          $xfer += $input->readListBegin(\$_etype329, \$_size326);
          for (my $_i330 = 0; $_i330 < $_size326; ++$_i330)
          {
            my $elem331 = undef;
            $elem331 = Hypertable::ThriftGen::Cell->new();
            $xfer += $elem331->read($input);
            push(@{$self->{cells}},$elem331);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter332 (@{$self->{cells}}) 
        {
          $xfer += ${iter332}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size333 = 0;
          $self->{cells} = [];
          my $_etype336 = 0;
          $xfer += $input->readListBegin(\$_etype336, \$_size333);
          for (my $_i337 = 0; $_i337 < $_size333; ++$_i337)
          {
            my $elem338 = undef;
            {
              my $_size339 = 0;
              $elem338 = [];
              my $_etype342 = 0;
              $xfer += $input->readListBegin(\$_etype342, \$_size339);
              for (my $_i343 = 0; $_i343 < $_size339; ++$_i343)
              {
                my $elem344 = undef;
                $xfer += $input->readString(\$elem344);
                push(@{$elem338},$elem344);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem338);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cells_as_arrays_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter345 (@{$self->{cells}}) 
        {
          {
            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{${iter345}}));
            {
              foreach my $iter346 (@{${iter345}}) 
              {
                $xfer += $output->writeString($iter346);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cells_as_arrays_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_as_arrays_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size347 = 0;
          $self->{cells} = [];
          my $_etype350 = 0;
          $xfer += $input->readListBegin(\$_etype350, \$_size347);
          for (my $_i351 = 0; $_i351 < $_size347; ++$_i351)
          {
            my $elem352 = undef;
            {
              my $_size353 = 0;
              $elem352 = [];
              my $_etype356 = 0;
              $xfer += $input->readListBegin(\$_etype356, \$_size353);
              for (my $_i357 = 0; $_i357 < $_size353; ++$_i357)
              {
                my $elem358 = undef;
                $xfer += $input->readString(\$elem358);
                push(@{$elem352},$elem358);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem352);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_as_arrays_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter359 (@{$self->{cells}}) 
        {
          {
            $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{${iter359}}));
            {
              foreach my $iter360 (@{${iter359}}) 
              {
                $xfer += $output->writeString($iter360);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_as_arrays_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_as_arrays_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_args->mk_accessors( qw( mutator cells flush ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  $self->{flush} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
    if (defined $vals->{flush}) {
      $self->{flush} = $vals->{flush};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cells_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{cells});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{flush});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cells_serialized_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{cells});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush}) {
    $xfer += $output->writeFieldBegin('flush', Thrift::TType::BOOL, 3);
    $xfer += $output->writeBool($self->{flush});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cells_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cells_serialized_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_serialized_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_serialized_async_args->mk_accessors( qw( mutator cells flush ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  $self->{flush} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
    if (defined $vals->{flush}) {
      $self->{flush} = $vals->{flush};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_serialized_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{cells});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{flush});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_serialized_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{cells});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush}) {
    $xfer += $output->writeFieldBegin('flush', Thrift::TType::BOOL, 3);
    $xfer += $output->writeBool($self->{flush});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_serialized_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_serialized_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_serialized_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_serialized_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_flush_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_flush_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_flush_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_flush_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_flush_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_flush_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_flush_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_flush_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_flush_mutator_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_flush_mutator_async_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_flush_mutator_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_flush_mutator_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_flush_mutator_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_flush_mutator_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_flush_mutator_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_flush_mutator_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_exists_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_exists_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_exists_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_exists_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_exists_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_exists_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_exists_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_exists_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_exists_namespace_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_exists_namespace_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_exists_namespace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_exists_namespace_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_exists_namespace_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_exists_namespace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_exists_namespace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_exists_namespace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_exists_table_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_exists_table_args->mk_accessors( qw( ns name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_exists_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_exists_table_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_exists_table_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_exists_table_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_exists_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_exists_table_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_exists_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_exists_args->mk_accessors( qw( ns name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_exists_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_exists_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_exists_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_exists_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_exists_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_exists_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_id_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_id_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_id_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_id_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_id_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_id_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_id_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_id_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_table_id_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_table_id_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_table_id_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_table_id_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_table_id_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_table_id_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_table_id_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_table_id_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_schema_str_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_schema_str_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_schema_str_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_schema_str_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_schema_str_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_schema_str_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_schema_str_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_schema_str_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_str_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_str_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_str_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_str_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_str_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_str_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_str_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_str_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_schema_str_with_ids_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_schema_str_with_ids_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_schema_str_with_ids_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_schema_str_with_ids_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_schema_str_with_ids_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_schema_str_with_ids_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_schema_str_with_ids_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_schema_str_with_ids_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_str_with_ids_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_str_with_ids_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_str_with_ids_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_str_with_ids_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_schema_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_schema_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_schema_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_schema_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_schema_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_schema_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_schema_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = Hypertable::ThriftGen::Schema->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_schema_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = Hypertable::ThriftGen::Schema->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_tables_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_tables_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_tables_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_tables_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_tables_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_tables_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_tables_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size361 = 0;
          $self->{success} = [];
          my $_etype364 = 0;
          $xfer += $input->readListBegin(\$_etype364, \$_size361);
          for (my $_i365 = 0; $_i365 < $_size361; ++$_i365)
          {
            my $elem366 = undef;
            $xfer += $input->readString(\$elem366);
            push(@{$self->{success}},$elem366);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_tables_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter367 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter367);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_get_listing_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_get_listing_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_get_listing_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_get_listing_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_get_listing_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_get_listing_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_get_listing_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size368 = 0;
          $self->{success} = [];
          my $_etype371 = 0;
          $xfer += $input->readListBegin(\$_etype371, \$_size368);
          for (my $_i372 = 0; $_i372 < $_size368; ++$_i372)
          {
            my $elem373 = undef;
            $elem373 = Hypertable::ThriftGen::NamespaceListing->new();
            $xfer += $elem373->read($input);
            push(@{$self->{success}},$elem373);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_get_listing_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter374 (@{$self->{success}}) 
        {
          $xfer += ${iter374}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_listing_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_listing_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_listing_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_listing_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_listing_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_listing_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_listing_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size375 = 0;
          $self->{success} = [];
          my $_etype378 = 0;
          $xfer += $input->readListBegin(\$_etype378, \$_size375);
          for (my $_i379 = 0; $_i379 < $_size375; ++$_i379)
          {
            my $elem380 = undef;
            $elem380 = Hypertable::ThriftGen::NamespaceListing->new();
            $xfer += $elem380->read($input);
            push(@{$self->{success}},$elem380);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_listing_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter381 (@{$self->{success}}) 
        {
          $xfer += ${iter381}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_splits_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_splits_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_splits_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_splits_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_get_splits_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_get_splits_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_get_splits_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size382 = 0;
          $self->{success} = [];
          my $_etype385 = 0;
          $xfer += $input->readListBegin(\$_etype385, \$_size382);
          for (my $_i386 = 0; $_i386 < $_size382; ++$_i386)
          {
            my $elem387 = undef;
            $elem387 = Hypertable::ThriftGen::TableSplit->new();
            $xfer += $elem387->read($input);
            push(@{$self->{success}},$elem387);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_get_splits_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter388 (@{$self->{success}}) 
        {
          $xfer += ${iter388}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_table_splits_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_table_splits_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_table_splits_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_table_splits_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_table_splits_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_table_splits_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_table_splits_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size389 = 0;
          $self->{success} = [];
          my $_etype392 = 0;
          $xfer += $input->readListBegin(\$_etype392, \$_size389);
          for (my $_i393 = 0; $_i393 < $_size389; ++$_i393)
          {
            my $elem394 = undef;
            $elem394 = Hypertable::ThriftGen::TableSplit->new();
            $xfer += $elem394->read($input);
            push(@{$self->{success}},$elem394);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_table_splits_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter395 (@{$self->{success}}) 
        {
          $xfer += ${iter395}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_drop_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_drop_args->mk_accessors( qw( ns if_exists ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{if_exists} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{if_exists}) {
      $self->{if_exists} = $vals->{if_exists};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_drop_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{if_exists});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_drop_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{if_exists}) {
    $xfer += $output->writeFieldBegin('if_exists', Thrift::TType::BOOL, 2);
    $xfer += $output->writeBool($self->{if_exists});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_drop_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_drop_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_drop_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_drop_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_drop_namespace_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_drop_namespace_args->mk_accessors( qw( ns if_exists ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{if_exists} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{if_exists}) {
      $self->{if_exists} = $vals->{if_exists};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_drop_namespace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{if_exists});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_drop_namespace_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{if_exists}) {
    $xfer += $output->writeFieldBegin('if_exists', Thrift::TType::BOOL, 2);
    $xfer += $output->writeBool($self->{if_exists});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_drop_namespace_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_drop_namespace_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_drop_namespace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_drop_namespace_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_rename_table_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_rename_table_args->mk_accessors( qw( ns name new_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  $self->{new_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{new_name}) {
      $self->{new_name} = $vals->{new_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_rename_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{new_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_rename_table_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{new_name}) {
    $xfer += $output->writeFieldBegin('new_name', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{new_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_rename_table_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_rename_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_rename_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_rename_table_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_rename_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_rename_args->mk_accessors( qw( ns name new_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  $self->{new_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{new_name}) {
      $self->{new_name} = $vals->{new_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_rename_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{new_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_rename_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{new_name}) {
    $xfer += $output->writeFieldBegin('new_name', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{new_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_rename_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_rename_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_rename_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_rename_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_drop_table_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_drop_table_args->mk_accessors( qw( ns name if_exists ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  $self->{if_exists} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{if_exists}) {
      $self->{if_exists} = $vals->{if_exists};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_drop_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{if_exists});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_drop_table_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{if_exists}) {
    $xfer += $output->writeFieldBegin('if_exists', Thrift::TType::BOOL, 3);
    $xfer += $output->writeBool($self->{if_exists});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_drop_table_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_drop_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_drop_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_drop_table_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_drop_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_drop_args->mk_accessors( qw( ns name if_exists ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  $self->{if_exists} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{if_exists}) {
      $self->{if_exists} = $vals->{if_exists};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_drop_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{if_exists});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_drop_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{if_exists}) {
    $xfer += $output->writeFieldBegin('if_exists', Thrift::TType::BOOL, 3);
    $xfer += $output->writeBool($self->{if_exists});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_table_drop_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_table_drop_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_table_drop_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_table_drop_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_generate_guid_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_generate_guid_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_generate_guid_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_generate_guid_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_generate_guid_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_generate_guid_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_generate_guid_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_create_cell_unique_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_create_cell_unique_args->mk_accessors( qw( ns table_name key value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{key} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_create_cell_unique_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{key} = Hypertable::ThriftGen::Key->new();
        $xfer += $self->{key}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_cell_unique_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Thrift::TType::STRUCT, 3);
    $xfer += $self->{key}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', Thrift::TType::STRING, 4);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_create_cell_unique_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_create_cell_unique_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_create_cell_unique_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_cell_unique_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_error_get_text_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_error_get_text_args->mk_accessors( qw( error_code ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{error_code} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{error_code}) {
      $self->{error_code} = $vals->{error_code};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_error_get_text_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{error_code});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_error_get_text_args');
  if (defined $self->{error_code}) {
    $xfer += $output->writeFieldBegin('error_code', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{error_code});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_error_get_text_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_error_get_text_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_error_get_text_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_error_get_text_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_status_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_status_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_status_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_status_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_status_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_status_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = Hypertable::ThriftGen::Status->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_status_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shutdown_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shutdown_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shutdown_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_shutdown_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_shutdown_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_shutdown_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{e} = Hypertable::ThriftGen::ClientException->new();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_shutdown_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', Thrift::TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientServiceIf;

use strict;


sub namespace_create{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub create_namespace{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub table_create{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

  die 'implement interface';
}

sub table_alter{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

  die 'implement interface';
}

sub refresh_table{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub namespace_open{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub open_namespace{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub namespace_close{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub close_namespace{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub future_open{
  my $self = shift;
  my $capacity = shift;

  die 'implement interface';
}

sub open_future{
  my $self = shift;
  my $capacity = shift;

  die 'implement interface';
}

sub future_cancel{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub cancel_future{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub future_get_result{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  die 'implement interface';
}

sub get_future_result{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  die 'implement interface';
}

sub future_get_result_as_arrays{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  die 'implement interface';
}

sub get_future_result_as_arrays{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  die 'implement interface';
}

sub future_get_result_serialized{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  die 'implement interface';
}

sub get_future_result_serialized{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  die 'implement interface';
}

sub future_is_empty{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub future_is_full{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub future_is_cancelled{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub future_has_outstanding{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub future_close{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub close_future{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub scanner_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub open_scanner{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub async_scanner_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub open_scanner_async{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub scanner_close{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub close_scanner{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub async_scanner_cancel{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub cancel_scanner_async{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub async_scanner_close{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub close_scanner_async{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub scanner_get_cells{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_cells{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub scanner_get_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub scanner_get_cells_serialized{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_cells_serialized{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub scanner_get_row{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_row{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub scanner_get_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub scanner_get_row_serialized{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_row_serialized{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub get_row{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;

  die 'implement interface';
}

sub get_row_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $row = shift;

  die 'implement interface';
}

sub get_row_serialized{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;

  die 'implement interface';
}

sub get_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;
  my $column = shift;

  die 'implement interface';
}

sub get_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub get_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub get_cells_serialized{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub shared_mutator_refresh{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;

  die 'implement interface';
}

sub refresh_shared_mutator{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;

  die 'implement interface';
}

sub shared_mutator_set_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  die 'implement interface';
}

sub offer_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  die 'implement interface';
}

sub shared_mutator_set_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  die 'implement interface';
}

sub offer_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  die 'implement interface';
}

sub shared_mutator_set_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  die 'implement interface';
}

sub offer_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  die 'implement interface';
}

sub shared_mutator_set_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  die 'implement interface';
}

sub offer_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  die 'implement interface';
}

sub mutator_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $flags = shift;
  my $flush_interval = shift;

  die 'implement interface';
}

sub open_mutator{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $flags = shift;
  my $flush_interval = shift;

  die 'implement interface';
}

sub async_mutator_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $flags = shift;

  die 'implement interface';
}

sub open_mutator_async{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $flags = shift;

  die 'implement interface';
}

sub mutator_close{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub close_mutator{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub async_mutator_cancel{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub cancel_mutator_async{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub async_mutator_close{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub close_mutator_async{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub mutator_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub set_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cell = shift;

  die 'implement interface';
}

sub mutator_set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub set_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cell = shift;

  die 'implement interface';
}

sub mutator_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub set_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

  die 'implement interface';
}

sub mutator_set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub set_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

  die 'implement interface';
}

sub mutator_set_cells_serialized{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

  die 'implement interface';
}

sub set_cells_serialized{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

  die 'implement interface';
}

sub mutator_flush{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub flush_mutator{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub async_mutator_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub set_cell_async{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub async_mutator_set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub set_cell_as_array_async{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub async_mutator_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub set_cells_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub async_mutator_set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub set_cells_as_arrays_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub async_mutator_set_cells_serialized{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

  die 'implement interface';
}

sub set_cells_serialized_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

  die 'implement interface';
}

sub async_mutator_flush{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub flush_mutator_async{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub namespace_exists{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub exists_namespace{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub exists_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;

  die 'implement interface';
}

sub table_exists{
  my $self = shift;
  my $ns = shift;
  my $name = shift;

  die 'implement interface';
}

sub table_get_id{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub get_table_id{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub table_get_schema_str{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub get_schema_str{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub table_get_schema_str_with_ids{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub get_schema_str_with_ids{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub table_get_schema{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub get_schema{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub get_tables{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub namespace_get_listing{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub get_listing{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub table_get_splits{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub get_table_splits{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub namespace_drop{
  my $self = shift;
  my $ns = shift;
  my $if_exists = shift;

  die 'implement interface';
}

sub drop_namespace{
  my $self = shift;
  my $ns = shift;
  my $if_exists = shift;

  die 'implement interface';
}

sub rename_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $new_name = shift;

  die 'implement interface';
}

sub table_rename{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $new_name = shift;

  die 'implement interface';
}

sub drop_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $if_exists = shift;

  die 'implement interface';
}

sub table_drop{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $if_exists = shift;

  die 'implement interface';
}

sub generate_guid{
  my $self = shift;

  die 'implement interface';
}

sub create_cell_unique{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $key = shift;
  my $value = shift;

  die 'implement interface';
}

sub error_get_text{
  my $self = shift;
  my $error_code = shift;

  die 'implement interface';
}

sub status{
  my $self = shift;

  die 'implement interface';
}

sub shutdown{
  my $self = shift;

  die 'implement interface';
}

package Hypertable::ThriftGen::ClientServiceRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub namespace_create{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->namespace_create($ns);
}

sub create_namespace{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->create_namespace($ns);
}

sub table_create{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $schema = ($request->{'schema'}) ? $request->{'schema'} : undef;
  return $self->{impl}->table_create($ns, $table_name, $schema);
}

sub table_alter{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $schema = ($request->{'schema'}) ? $request->{'schema'} : undef;
  return $self->{impl}->table_alter($ns, $table_name, $schema);
}

sub refresh_table{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->refresh_table($ns, $table_name);
}

sub namespace_open{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->namespace_open($ns);
}

sub open_namespace{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->open_namespace($ns);
}

sub namespace_close{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->namespace_close($ns);
}

sub close_namespace{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->close_namespace($ns);
}

sub future_open{
  my ($self, $request) = @_;

  my $capacity = ($request->{'capacity'}) ? $request->{'capacity'} : undef;
  return $self->{impl}->future_open($capacity);
}

sub open_future{
  my ($self, $request) = @_;

  my $capacity = ($request->{'capacity'}) ? $request->{'capacity'} : undef;
  return $self->{impl}->open_future($capacity);
}

sub future_cancel{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_cancel($ff);
}

sub cancel_future{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->cancel_future($ff);
}

sub future_get_result{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  my $timeout_millis = ($request->{'timeout_millis'}) ? $request->{'timeout_millis'} : undef;
  return $self->{impl}->future_get_result($ff, $timeout_millis);
}

sub get_future_result{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  my $timeout_millis = ($request->{'timeout_millis'}) ? $request->{'timeout_millis'} : undef;
  return $self->{impl}->get_future_result($ff, $timeout_millis);
}

sub future_get_result_as_arrays{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  my $timeout_millis = ($request->{'timeout_millis'}) ? $request->{'timeout_millis'} : undef;
  return $self->{impl}->future_get_result_as_arrays($ff, $timeout_millis);
}

sub get_future_result_as_arrays{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  my $timeout_millis = ($request->{'timeout_millis'}) ? $request->{'timeout_millis'} : undef;
  return $self->{impl}->get_future_result_as_arrays($ff, $timeout_millis);
}

sub future_get_result_serialized{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  my $timeout_millis = ($request->{'timeout_millis'}) ? $request->{'timeout_millis'} : undef;
  return $self->{impl}->future_get_result_serialized($ff, $timeout_millis);
}

sub get_future_result_serialized{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  my $timeout_millis = ($request->{'timeout_millis'}) ? $request->{'timeout_millis'} : undef;
  return $self->{impl}->get_future_result_serialized($ff, $timeout_millis);
}

sub future_is_empty{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_is_empty($ff);
}

sub future_is_full{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_is_full($ff);
}

sub future_is_cancelled{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_is_cancelled($ff);
}

sub future_has_outstanding{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_has_outstanding($ff);
}

sub future_close{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_close($ff);
}

sub close_future{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->close_future($ff);
}

sub scanner_open{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->scanner_open($ns, $table_name, $scan_spec);
}

sub open_scanner{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->open_scanner($ns, $table_name, $scan_spec);
}

sub async_scanner_open{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $future = ($request->{'future'}) ? $request->{'future'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->async_scanner_open($ns, $table_name, $future, $scan_spec);
}

sub open_scanner_async{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $future = ($request->{'future'}) ? $request->{'future'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->open_scanner_async($ns, $table_name, $future, $scan_spec);
}

sub scanner_close{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_close($scanner);
}

sub close_scanner{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->close_scanner($scanner);
}

sub async_scanner_cancel{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->async_scanner_cancel($scanner);
}

sub cancel_scanner_async{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->cancel_scanner_async($scanner);
}

sub async_scanner_close{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->async_scanner_close($scanner);
}

sub close_scanner_async{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->close_scanner_async($scanner);
}

sub scanner_get_cells{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_get_cells($scanner);
}

sub next_cells{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_cells($scanner);
}

sub scanner_get_cells_as_arrays{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_get_cells_as_arrays($scanner);
}

sub next_cells_as_arrays{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_cells_as_arrays($scanner);
}

sub scanner_get_cells_serialized{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_get_cells_serialized($scanner);
}

sub next_cells_serialized{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_cells_serialized($scanner);
}

sub scanner_get_row{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_get_row($scanner);
}

sub next_row{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_row($scanner);
}

sub scanner_get_row_as_arrays{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_get_row_as_arrays($scanner);
}

sub next_row_as_arrays{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_row_as_arrays($scanner);
}

sub scanner_get_row_serialized{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_get_row_serialized($scanner);
}

sub next_row_serialized{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_row_serialized($scanner);
}

sub get_row{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  return $self->{impl}->get_row($ns, $table_name, $row);
}

sub get_row_as_arrays{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  return $self->{impl}->get_row_as_arrays($ns, $name, $row);
}

sub get_row_serialized{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  return $self->{impl}->get_row_serialized($ns, $table_name, $row);
}

sub get_cell{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  return $self->{impl}->get_cell($ns, $table_name, $row, $column);
}

sub get_cells{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->get_cells($ns, $table_name, $scan_spec);
}

sub get_cells_as_arrays{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->get_cells_as_arrays($ns, $name, $scan_spec);
}

sub get_cells_serialized{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->get_cells_serialized($ns, $name, $scan_spec);
}

sub shared_mutator_refresh{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  return $self->{impl}->shared_mutator_refresh($ns, $table_name, $mutate_spec);
}

sub refresh_shared_mutator{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  return $self->{impl}->refresh_shared_mutator($ns, $table_name, $mutate_spec);
}

sub shared_mutator_set_cells{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->shared_mutator_set_cells($ns, $table_name, $mutate_spec, $cells);
}

sub offer_cells{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->offer_cells($ns, $table_name, $mutate_spec, $cells);
}

sub shared_mutator_set_cells_as_arrays{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->shared_mutator_set_cells_as_arrays($ns, $table_name, $mutate_spec, $cells);
}

sub offer_cells_as_arrays{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->offer_cells_as_arrays($ns, $table_name, $mutate_spec, $cells);
}

sub shared_mutator_set_cell{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->shared_mutator_set_cell($ns, $table_name, $mutate_spec, $cell);
}

sub offer_cell{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->offer_cell($ns, $table_name, $mutate_spec, $cell);
}

sub shared_mutator_set_cell_as_array{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->shared_mutator_set_cell_as_array($ns, $table_name, $mutate_spec, $cell);
}

sub offer_cell_as_array{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->offer_cell_as_array($ns, $table_name, $mutate_spec, $cell);
}

sub mutator_open{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $flags = ($request->{'flags'}) ? $request->{'flags'} : undef;
  my $flush_interval = ($request->{'flush_interval'}) ? $request->{'flush_interval'} : undef;
  return $self->{impl}->mutator_open($ns, $table_name, $flags, $flush_interval);
}

sub open_mutator{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $flags = ($request->{'flags'}) ? $request->{'flags'} : undef;
  my $flush_interval = ($request->{'flush_interval'}) ? $request->{'flush_interval'} : undef;
  return $self->{impl}->open_mutator($ns, $table_name, $flags, $flush_interval);
}

sub async_mutator_open{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $future = ($request->{'future'}) ? $request->{'future'} : undef;
  my $flags = ($request->{'flags'}) ? $request->{'flags'} : undef;
  return $self->{impl}->async_mutator_open($ns, $table_name, $future, $flags);
}

sub open_mutator_async{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $future = ($request->{'future'}) ? $request->{'future'} : undef;
  my $flags = ($request->{'flags'}) ? $request->{'flags'} : undef;
  return $self->{impl}->open_mutator_async($ns, $table_name, $future, $flags);
}

sub mutator_close{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->mutator_close($mutator);
}

sub close_mutator{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->close_mutator($mutator);
}

sub async_mutator_cancel{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->async_mutator_cancel($mutator);
}

sub cancel_mutator_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->cancel_mutator_async($mutator);
}

sub async_mutator_close{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->async_mutator_close($mutator);
}

sub close_mutator_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->close_mutator_async($mutator);
}

sub mutator_set_cell{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->mutator_set_cell($mutator, $cell);
}

sub set_cell{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->set_cell($ns, $table_name, $cell);
}

sub mutator_set_cell_as_array{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->mutator_set_cell_as_array($mutator, $cell);
}

sub set_cell_as_array{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->set_cell_as_array($ns, $table_name, $cell);
}

sub mutator_set_cells{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->mutator_set_cells($mutator, $cells);
}

sub set_cells{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->set_cells($ns, $table_name, $cells);
}

sub mutator_set_cells_as_arrays{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->mutator_set_cells_as_arrays($mutator, $cells);
}

sub set_cells_as_arrays{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->set_cells_as_arrays($ns, $table_name, $cells);
}

sub mutator_set_cells_serialized{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  my $flush = ($request->{'flush'}) ? $request->{'flush'} : undef;
  return $self->{impl}->mutator_set_cells_serialized($mutator, $cells, $flush);
}

sub set_cells_serialized{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->set_cells_serialized($ns, $table_name, $cells);
}

sub mutator_flush{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->mutator_flush($mutator);
}

sub flush_mutator{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->flush_mutator($mutator);
}

sub async_mutator_set_cell{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->async_mutator_set_cell($mutator, $cell);
}

sub set_cell_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->set_cell_async($mutator, $cell);
}

sub async_mutator_set_cell_as_array{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->async_mutator_set_cell_as_array($mutator, $cell);
}

sub set_cell_as_array_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->set_cell_as_array_async($mutator, $cell);
}

sub async_mutator_set_cells{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->async_mutator_set_cells($mutator, $cells);
}

sub set_cells_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->set_cells_async($mutator, $cells);
}

sub async_mutator_set_cells_as_arrays{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->async_mutator_set_cells_as_arrays($mutator, $cells);
}

sub set_cells_as_arrays_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->set_cells_as_arrays_async($mutator, $cells);
}

sub async_mutator_set_cells_serialized{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  my $flush = ($request->{'flush'}) ? $request->{'flush'} : undef;
  return $self->{impl}->async_mutator_set_cells_serialized($mutator, $cells, $flush);
}

sub set_cells_serialized_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  my $flush = ($request->{'flush'}) ? $request->{'flush'} : undef;
  return $self->{impl}->set_cells_serialized_async($mutator, $cells, $flush);
}

sub async_mutator_flush{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->async_mutator_flush($mutator);
}

sub flush_mutator_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->flush_mutator_async($mutator);
}

sub namespace_exists{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->namespace_exists($ns);
}

sub exists_namespace{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->exists_namespace($ns);
}

sub exists_table{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->exists_table($ns, $name);
}

sub table_exists{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->table_exists($ns, $name);
}

sub table_get_id{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->table_get_id($ns, $table_name);
}

sub get_table_id{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_table_id($ns, $table_name);
}

sub table_get_schema_str{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->table_get_schema_str($ns, $table_name);
}

sub get_schema_str{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_schema_str($ns, $table_name);
}

sub table_get_schema_str_with_ids{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->table_get_schema_str_with_ids($ns, $table_name);
}

sub get_schema_str_with_ids{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_schema_str_with_ids($ns, $table_name);
}

sub table_get_schema{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->table_get_schema($ns, $table_name);
}

sub get_schema{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_schema($ns, $table_name);
}

sub get_tables{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->get_tables($ns);
}

sub namespace_get_listing{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->namespace_get_listing($ns);
}

sub get_listing{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->get_listing($ns);
}

sub table_get_splits{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->table_get_splits($ns, $table_name);
}

sub get_table_splits{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_table_splits($ns, $table_name);
}

sub namespace_drop{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $if_exists = ($request->{'if_exists'}) ? $request->{'if_exists'} : undef;
  return $self->{impl}->namespace_drop($ns, $if_exists);
}

sub drop_namespace{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $if_exists = ($request->{'if_exists'}) ? $request->{'if_exists'} : undef;
  return $self->{impl}->drop_namespace($ns, $if_exists);
}

sub rename_table{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $new_name = ($request->{'new_name'}) ? $request->{'new_name'} : undef;
  return $self->{impl}->rename_table($ns, $name, $new_name);
}

sub table_rename{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $new_name = ($request->{'new_name'}) ? $request->{'new_name'} : undef;
  return $self->{impl}->table_rename($ns, $name, $new_name);
}

sub drop_table{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $if_exists = ($request->{'if_exists'}) ? $request->{'if_exists'} : undef;
  return $self->{impl}->drop_table($ns, $name, $if_exists);
}

sub table_drop{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $if_exists = ($request->{'if_exists'}) ? $request->{'if_exists'} : undef;
  return $self->{impl}->table_drop($ns, $name, $if_exists);
}

sub generate_guid{
  my ($self, $request) = @_;

  return $self->{impl}->generate_guid();
}

sub create_cell_unique{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $value = ($request->{'value'}) ? $request->{'value'} : undef;
  return $self->{impl}->create_cell_unique($ns, $table_name, $key, $value);
}

sub error_get_text{
  my ($self, $request) = @_;

  my $error_code = ($request->{'error_code'}) ? $request->{'error_code'} : undef;
  return $self->{impl}->error_get_text($error_code);
}

sub status{
  my ($self, $request) = @_;

  return $self->{impl}->status();
}

sub shutdown{
  my ($self, $request) = @_;

  return $self->{impl}->shutdown();
}

package Hypertable::ThriftGen::ClientServiceClient;


use base qw(Hypertable::ThriftGen::ClientServiceIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub namespace_create{
  my $self = shift;
  my $ns = shift;

    $self->send_namespace_create($ns);
  $self->recv_namespace_create();
}

sub send_namespace_create{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('namespace_create', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_namespace_create_args->new();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_namespace_create{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_namespace_create_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub create_namespace{
  my $self = shift;
  my $ns = shift;

    $self->send_create_namespace($ns);
  $self->recv_create_namespace();
}

sub send_create_namespace{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('create_namespace', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_create_namespace_args->new();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_namespace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_create_namespace_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub table_create{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

    $self->send_table_create($ns, $table_name, $schema);
  $self->recv_table_create();
}

sub send_table_create{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

  $self->{output}->writeMessageBegin('table_create', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_table_create_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{schema} = $schema;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_create{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_table_create_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub table_alter{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

    $self->send_table_alter($ns, $table_name, $schema);
  $self->recv_table_alter();
}

sub send_table_alter{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

  $self->{output}->writeMessageBegin('table_alter', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_table_alter_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{schema} = $schema;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_alter{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_table_alter_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub refresh_table{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_refresh_table($ns, $table_name);
  $self->recv_refresh_table();
}

sub send_refresh_table{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('refresh_table', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_refresh_table_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_refresh_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_refresh_table_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub namespace_open{
  my $self = shift;
  my $ns = shift;

    $self->send_namespace_open($ns);
  return $self->recv_namespace_open();
}

sub send_namespace_open{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('namespace_open', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_namespace_open_args->new();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_namespace_open{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_namespace_open_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "namespace_open failed: unknown result";
}
sub open_namespace{
  my $self = shift;
  my $ns = shift;

    $self->send_open_namespace($ns);
  return $self->recv_open_namespace();
}

sub send_open_namespace{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('open_namespace', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_open_namespace_args->new();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_namespace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_open_namespace_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_namespace failed: unknown result";
}
sub namespace_close{
  my $self = shift;
  my $ns = shift;

    $self->send_namespace_close($ns);
  $self->recv_namespace_close();
}

sub send_namespace_close{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('namespace_close', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_namespace_close_args->new();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_namespace_close{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_namespace_close_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub close_namespace{
  my $self = shift;
  my $ns = shift;

    $self->send_close_namespace($ns);
  $self->recv_close_namespace();
}

sub send_close_namespace{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('close_namespace', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_close_namespace_args->new();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_namespace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_close_namespace_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub future_open{
  my $self = shift;
  my $capacity = shift;

    $self->send_future_open($capacity);
  return $self->recv_future_open();
}

sub send_future_open{
  my $self = shift;
  my $capacity = shift;

  $self->{output}->writeMessageBegin('future_open', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_future_open_args->new();
  $args->{capacity} = $capacity;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_open{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_future_open_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_open failed: unknown result";
}
sub open_future{
  my $self = shift;
  my $capacity = shift;

    $self->send_open_future($capacity);
  return $self->recv_open_future();
}

sub send_open_future{
  my $self = shift;
  my $capacity = shift;

  $self->{output}->writeMessageBegin('open_future', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_open_future_args->new();
  $args->{capacity} = $capacity;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_future{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_open_future_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_future failed: unknown result";
}
sub future_cancel{
  my $self = shift;
  my $ff = shift;

    $self->send_future_cancel($ff);
  $self->recv_future_cancel();
}

sub send_future_cancel{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_cancel', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_future_cancel_args->new();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_cancel{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_future_cancel_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub cancel_future{
  my $self = shift;
  my $ff = shift;

    $self->send_cancel_future($ff);
  $self->recv_cancel_future();
}

sub send_cancel_future{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('cancel_future', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_cancel_future_args->new();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_cancel_future{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_cancel_future_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub future_get_result{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

    $self->send_future_get_result($ff, $timeout_millis);
  return $self->recv_future_get_result();
}

sub send_future_get_result{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  $self->{output}->writeMessageBegin('future_get_result', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_future_get_result_args->new();
  $args->{ff} = $ff;
  $args->{timeout_millis} = $timeout_millis;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_get_result{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_future_get_result_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_get_result failed: unknown result";
}
sub get_future_result{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

    $self->send_get_future_result($ff, $timeout_millis);
  return $self->recv_get_future_result();
}

sub send_get_future_result{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  $self->{output}->writeMessageBegin('get_future_result', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_get_future_result_args->new();
  $args->{ff} = $ff;
  $args->{timeout_millis} = $timeout_millis;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_future_result{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_get_future_result_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_future_result failed: unknown result";
}
sub future_get_result_as_arrays{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

    $self->send_future_get_result_as_arrays($ff, $timeout_millis);
  return $self->recv_future_get_result_as_arrays();
}

sub send_future_get_result_as_arrays{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  $self->{output}->writeMessageBegin('future_get_result_as_arrays', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_args->new();
  $args->{ff} = $ff;
  $args->{timeout_millis} = $timeout_millis;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_get_result_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_get_result_as_arrays failed: unknown result";
}
sub get_future_result_as_arrays{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

    $self->send_get_future_result_as_arrays($ff, $timeout_millis);
  return $self->recv_get_future_result_as_arrays();
}

sub send_get_future_result_as_arrays{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  $self->{output}->writeMessageBegin('get_future_result_as_arrays', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_args->new();
  $args->{ff} = $ff;
  $args->{timeout_millis} = $timeout_millis;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_future_result_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_future_result_as_arrays failed: unknown result";
}
sub future_get_result_serialized{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

    $self->send_future_get_result_serialized($ff, $timeout_millis);
  return $self->recv_future_get_result_serialized();
}

sub send_future_get_result_serialized{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  $self->{output}->writeMessageBegin('future_get_result_serialized', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_future_get_result_serialized_args->new();
  $args->{ff} = $ff;
  $args->{timeout_millis} = $timeout_millis;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_get_result_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_future_get_result_serialized_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_get_result_serialized failed: unknown result";
}
sub get_future_result_serialized{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

    $self->send_get_future_result_serialized($ff, $timeout_millis);
  return $self->recv_get_future_result_serialized();
}

sub send_get_future_result_serialized{
  my $self = shift;
  my $ff = shift;
  my $timeout_millis = shift;

  $self->{output}->writeMessageBegin('get_future_result_serialized', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_get_future_result_serialized_args->new();
  $args->{ff} = $ff;
  $args->{timeout_millis} = $timeout_millis;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_future_result_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_get_future_result_serialized_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_future_result_serialized failed: unknown result";
}
sub future_is_empty{
  my $self = shift;
  my $ff = shift;

    $self->send_future_is_empty($ff);
  return $self->recv_future_is_empty();
}

sub send_future_is_empty{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_is_empty', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_future_is_empty_args->new();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_is_empty{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_future_is_empty_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_is_empty failed: unknown result";
}
sub future_is_full{
  my $self = shift;
  my $ff = shift;

    $self->send_future_is_full($ff);
  return $self->recv_future_is_full();
}

sub send_future_is_full{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_is_full', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_future_is_full_args->new();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_is_full{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_future_is_full_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_is_full failed: unknown result";
}
sub future_is_cancelled{
  my $self = shift;
  my $ff = shift;

    $self->send_future_is_cancelled($ff);
  return $self->recv_future_is_cancelled();
}

sub send_future_is_cancelled{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_is_cancelled', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_future_is_cancelled_args->new();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_is_cancelled{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_future_is_cancelled_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_is_cancelled failed: unknown result";
}
sub future_has_outstanding{
  my $self = shift;
  my $ff = shift;

    $self->send_future_has_outstanding($ff);
  return $self->recv_future_has_outstanding();
}

sub send_future_has_outstanding{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_has_outstanding', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_future_has_outstanding_args->new();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_has_outstanding{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_future_has_outstanding_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_has_outstanding failed: unknown result";
}
sub future_close{
  my $self = shift;
  my $ff = shift;

    $self->send_future_close($ff);
  $self->recv_future_close();
}

sub send_future_close{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_close', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_future_close_args->new();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_close{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_future_close_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub close_future{
  my $self = shift;
  my $ff = shift;

    $self->send_close_future($ff);
  $self->recv_close_future();
}

sub send_close_future{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('close_future', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_close_future_args->new();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_future{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_close_future_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub scanner_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

    $self->send_scanner_open($ns, $table_name, $scan_spec);
  return $self->recv_scanner_open();
}

sub send_scanner_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('scanner_open', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_scanner_open_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_open{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_scanner_open_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_open failed: unknown result";
}
sub open_scanner{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

    $self->send_open_scanner($ns, $table_name, $scan_spec);
  return $self->recv_open_scanner();
}

sub send_open_scanner{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('open_scanner', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_open_scanner_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_scanner{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_open_scanner_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_scanner failed: unknown result";
}
sub async_scanner_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $scan_spec = shift;

    $self->send_async_scanner_open($ns, $table_name, $future, $scan_spec);
  return $self->recv_async_scanner_open();
}

sub send_async_scanner_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('async_scanner_open', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_async_scanner_open_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{future} = $future;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_scanner_open{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_async_scanner_open_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "async_scanner_open failed: unknown result";
}
sub open_scanner_async{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $scan_spec = shift;

    $self->send_open_scanner_async($ns, $table_name, $future, $scan_spec);
  return $self->recv_open_scanner_async();
}

sub send_open_scanner_async{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('open_scanner_async', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_open_scanner_async_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{future} = $future;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_scanner_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_open_scanner_async_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_scanner_async failed: unknown result";
}
sub scanner_close{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_close($scanner);
  $self->recv_scanner_close();
}

sub send_scanner_close{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_close', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_scanner_close_args->new();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_close{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_scanner_close_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub close_scanner{
  my $self = shift;
  my $scanner = shift;

    $self->send_close_scanner($scanner);
  $self->recv_close_scanner();
}

sub send_close_scanner{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('close_scanner', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_close_scanner_args->new();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_scanner{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_close_scanner_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_scanner_cancel{
  my $self = shift;
  my $scanner = shift;

    $self->send_async_scanner_cancel($scanner);
  $self->recv_async_scanner_cancel();
}

sub send_async_scanner_cancel{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('async_scanner_cancel', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_async_scanner_cancel_args->new();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_scanner_cancel{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_async_scanner_cancel_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub cancel_scanner_async{
  my $self = shift;
  my $scanner = shift;

    $self->send_cancel_scanner_async($scanner);
  $self->recv_cancel_scanner_async();
}

sub send_cancel_scanner_async{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('cancel_scanner_async', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_cancel_scanner_async_args->new();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_cancel_scanner_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_cancel_scanner_async_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_scanner_close{
  my $self = shift;
  my $scanner = shift;

    $self->send_async_scanner_close($scanner);
  $self->recv_async_scanner_close();
}

sub send_async_scanner_close{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('async_scanner_close', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_async_scanner_close_args->new();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_scanner_close{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_async_scanner_close_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub close_scanner_async{
  my $self = shift;
  my $scanner = shift;

    $self->send_close_scanner_async($scanner);
  $self->recv_close_scanner_async();
}

sub send_close_scanner_async{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('close_scanner_async', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_close_scanner_async_args->new();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_scanner_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_close_scanner_async_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub scanner_get_cells{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_get_cells($scanner);
  return $self->recv_scanner_get_cells();
}

sub send_scanner_get_cells{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_get_cells', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_scanner_get_cells_args->new();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_get_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_scanner_get_cells_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_get_cells failed: unknown result";
}
sub next_cells{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_cells($scanner);
  return $self->recv_next_cells();
}

sub send_next_cells{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_cells', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_next_cells_args->new();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_next_cells_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_cells failed: unknown result";
}
sub scanner_get_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_get_cells_as_arrays($scanner);
  return $self->recv_scanner_get_cells_as_arrays();
}

sub send_scanner_get_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_get_cells_as_arrays', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_args->new();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_get_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_get_cells_as_arrays failed: unknown result";
}
sub next_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_cells_as_arrays($scanner);
  return $self->recv_next_cells_as_arrays();
}

sub send_next_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_cells_as_arrays', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_next_cells_as_arrays_args->new();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_next_cells_as_arrays_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_cells_as_arrays failed: unknown result";
}
sub scanner_get_cells_serialized{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_get_cells_serialized($scanner);
  return $self->recv_scanner_get_cells_serialized();
}

sub send_scanner_get_cells_serialized{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_get_cells_serialized', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_args->new();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_get_cells_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_get_cells_serialized failed: unknown result";
}
sub next_cells_serialized{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_cells_serialized($scanner);
  return $self->recv_next_cells_serialized();
}

sub send_next_cells_serialized{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_cells_serialized', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_next_cells_serialized_args->new();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_cells_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_next_cells_serialized_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_cells_serialized failed: unknown result";
}
sub scanner_get_row{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_get_row($scanner);
  return $self->recv_scanner_get_row();
}

sub send_scanner_get_row{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_get_row', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_scanner_get_row_args->new();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_get_row{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_scanner_get_row_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_get_row failed: unknown result";
}
sub next_row{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_row($scanner);
  return $self->recv_next_row();
}

sub send_next_row{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_row', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_next_row_args->new();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_row{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_next_row_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_row failed: unknown result";
}
sub scanner_get_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_get_row_as_arrays($scanner);
  return $self->recv_scanner_get_row_as_arrays();
}

sub send_scanner_get_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_get_row_as_arrays', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_args->new();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_get_row_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_get_row_as_arrays failed: unknown result";
}
sub next_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_row_as_arrays($scanner);
  return $self->recv_next_row_as_arrays();
}

sub send_next_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_row_as_arrays', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_next_row_as_arrays_args->new();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_row_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_next_row_as_arrays_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_row_as_arrays failed: unknown result";
}
sub scanner_get_row_serialized{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_get_row_serialized($scanner);
  return $self->recv_scanner_get_row_serialized();
}

sub send_scanner_get_row_serialized{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_get_row_serialized', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_args->new();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_get_row_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_get_row_serialized failed: unknown result";
}
sub next_row_serialized{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_row_serialized($scanner);
  return $self->recv_next_row_serialized();
}

sub send_next_row_serialized{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_row_serialized', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_next_row_serialized_args->new();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_row_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_next_row_serialized_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_row_serialized failed: unknown result";
}
sub get_row{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;

    $self->send_get_row($ns, $table_name, $row);
  return $self->recv_get_row();
}

sub send_get_row{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;

  $self->{output}->writeMessageBegin('get_row', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_get_row_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{row} = $row;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_row{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_get_row_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_row failed: unknown result";
}
sub get_row_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $row = shift;

    $self->send_get_row_as_arrays($ns, $name, $row);
  return $self->recv_get_row_as_arrays();
}

sub send_get_row_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $row = shift;

  $self->{output}->writeMessageBegin('get_row_as_arrays', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_get_row_as_arrays_args->new();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->{row} = $row;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_row_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_get_row_as_arrays_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_row_as_arrays failed: unknown result";
}
sub get_row_serialized{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;

    $self->send_get_row_serialized($ns, $table_name, $row);
  return $self->recv_get_row_serialized();
}

sub send_get_row_serialized{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;

  $self->{output}->writeMessageBegin('get_row_serialized', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_get_row_serialized_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{row} = $row;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_row_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_get_row_serialized_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_row_serialized failed: unknown result";
}
sub get_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;
  my $column = shift;

    $self->send_get_cell($ns, $table_name, $row, $column);
  return $self->recv_get_cell();
}

sub send_get_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;
  my $column = shift;

  $self->{output}->writeMessageBegin('get_cell', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_get_cell_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_get_cell_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_cell failed: unknown result";
}
sub get_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

    $self->send_get_cells($ns, $table_name, $scan_spec);
  return $self->recv_get_cells();
}

sub send_get_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('get_cells', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_get_cells_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_get_cells_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_cells failed: unknown result";
}
sub get_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $scan_spec = shift;

    $self->send_get_cells_as_arrays($ns, $name, $scan_spec);
  return $self->recv_get_cells_as_arrays();
}

sub send_get_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('get_cells_as_arrays', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_get_cells_as_arrays_args->new();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_get_cells_as_arrays_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_cells_as_arrays failed: unknown result";
}
sub get_cells_serialized{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $scan_spec = shift;

    $self->send_get_cells_serialized($ns, $name, $scan_spec);
  return $self->recv_get_cells_serialized();
}

sub send_get_cells_serialized{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('get_cells_serialized', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_get_cells_serialized_args->new();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_cells_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_get_cells_serialized_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_cells_serialized failed: unknown result";
}
sub shared_mutator_refresh{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;

    $self->send_shared_mutator_refresh($ns, $table_name, $mutate_spec);
  $self->recv_shared_mutator_refresh();
}

sub send_shared_mutator_refresh{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;

  $self->{output}->writeMessageBegin('shared_mutator_refresh', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_shared_mutator_refresh_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shared_mutator_refresh{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_shared_mutator_refresh_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub refresh_shared_mutator{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;

    $self->send_refresh_shared_mutator($ns, $table_name, $mutate_spec);
  $self->recv_refresh_shared_mutator();
}

sub send_refresh_shared_mutator{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;

  $self->{output}->writeMessageBegin('refresh_shared_mutator', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_refresh_shared_mutator_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_refresh_shared_mutator{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_refresh_shared_mutator_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub shared_mutator_set_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

    $self->send_shared_mutator_set_cells($ns, $table_name, $mutate_spec, $cells);
  $self->recv_shared_mutator_set_cells();
}

sub send_shared_mutator_set_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('shared_mutator_set_cells', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shared_mutator_set_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub offer_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

    $self->send_offer_cells($ns, $table_name, $mutate_spec, $cells);
  $self->recv_offer_cells();
}

sub send_offer_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('offer_cells', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_offer_cells_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_offer_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_offer_cells_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub shared_mutator_set_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

    $self->send_shared_mutator_set_cells_as_arrays($ns, $table_name, $mutate_spec, $cells);
  $self->recv_shared_mutator_set_cells_as_arrays();
}

sub send_shared_mutator_set_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('shared_mutator_set_cells_as_arrays', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_as_arrays_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shared_mutator_set_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_as_arrays_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub offer_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

    $self->send_offer_cells_as_arrays($ns, $table_name, $mutate_spec, $cells);
  $self->recv_offer_cells_as_arrays();
}

sub send_offer_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('offer_cells_as_arrays', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_offer_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub shared_mutator_set_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

    $self->send_shared_mutator_set_cell($ns, $table_name, $mutate_spec, $cell);
  $self->recv_shared_mutator_set_cell();
}

sub send_shared_mutator_set_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('shared_mutator_set_cell', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shared_mutator_set_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub offer_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

    $self->send_offer_cell($ns, $table_name, $mutate_spec, $cell);
  $self->recv_offer_cell();
}

sub send_offer_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('offer_cell', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_offer_cell_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_offer_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_offer_cell_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub shared_mutator_set_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

    $self->send_shared_mutator_set_cell_as_array($ns, $table_name, $mutate_spec, $cell);
  $self->recv_shared_mutator_set_cell_as_array();
}

sub send_shared_mutator_set_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('shared_mutator_set_cell_as_array', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_as_array_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shared_mutator_set_cell_as_array{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_as_array_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub offer_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

    $self->send_offer_cell_as_array($ns, $table_name, $mutate_spec, $cell);
  $self->recv_offer_cell_as_array();
}

sub send_offer_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('offer_cell_as_array', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_offer_cell_as_array_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_offer_cell_as_array{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_offer_cell_as_array_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $flags = shift;
  my $flush_interval = shift;

    $self->send_mutator_open($ns, $table_name, $flags, $flush_interval);
  return $self->recv_mutator_open();
}

sub send_mutator_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $flags = shift;
  my $flush_interval = shift;

  $self->{output}->writeMessageBegin('mutator_open', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_mutator_open_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{flags} = $flags;
  $args->{flush_interval} = $flush_interval;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_open{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_mutator_open_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "mutator_open failed: unknown result";
}
sub open_mutator{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $flags = shift;
  my $flush_interval = shift;

    $self->send_open_mutator($ns, $table_name, $flags, $flush_interval);
  return $self->recv_open_mutator();
}

sub send_open_mutator{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $flags = shift;
  my $flush_interval = shift;

  $self->{output}->writeMessageBegin('open_mutator', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_open_mutator_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{flags} = $flags;
  $args->{flush_interval} = $flush_interval;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_mutator{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_open_mutator_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_mutator failed: unknown result";
}
sub async_mutator_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $flags = shift;

    $self->send_async_mutator_open($ns, $table_name, $future, $flags);
  return $self->recv_async_mutator_open();
}

sub send_async_mutator_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $flags = shift;

  $self->{output}->writeMessageBegin('async_mutator_open', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_async_mutator_open_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{future} = $future;
  $args->{flags} = $flags;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_open{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_async_mutator_open_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "async_mutator_open failed: unknown result";
}
sub open_mutator_async{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $flags = shift;

    $self->send_open_mutator_async($ns, $table_name, $future, $flags);
  return $self->recv_open_mutator_async();
}

sub send_open_mutator_async{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $flags = shift;

  $self->{output}->writeMessageBegin('open_mutator_async', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_open_mutator_async_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{future} = $future;
  $args->{flags} = $flags;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_mutator_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_open_mutator_async_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_mutator_async failed: unknown result";
}
sub mutator_close{
  my $self = shift;
  my $mutator = shift;

    $self->send_mutator_close($mutator);
  $self->recv_mutator_close();
}

sub send_mutator_close{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('mutator_close', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_mutator_close_args->new();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_close{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_mutator_close_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub close_mutator{
  my $self = shift;
  my $mutator = shift;

    $self->send_close_mutator($mutator);
  $self->recv_close_mutator();
}

sub send_close_mutator{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('close_mutator', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_close_mutator_args->new();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_mutator{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_close_mutator_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_cancel{
  my $self = shift;
  my $mutator = shift;

    $self->send_async_mutator_cancel($mutator);
  $self->recv_async_mutator_cancel();
}

sub send_async_mutator_cancel{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('async_mutator_cancel', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_async_mutator_cancel_args->new();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_cancel{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_async_mutator_cancel_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub cancel_mutator_async{
  my $self = shift;
  my $mutator = shift;

    $self->send_cancel_mutator_async($mutator);
  $self->recv_cancel_mutator_async();
}

sub send_cancel_mutator_async{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('cancel_mutator_async', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_cancel_mutator_async_args->new();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_cancel_mutator_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_cancel_mutator_async_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_close{
  my $self = shift;
  my $mutator = shift;

    $self->send_async_mutator_close($mutator);
  $self->recv_async_mutator_close();
}

sub send_async_mutator_close{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('async_mutator_close', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_async_mutator_close_args->new();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_close{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_async_mutator_close_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub close_mutator_async{
  my $self = shift;
  my $mutator = shift;

    $self->send_close_mutator_async($mutator);
  $self->recv_close_mutator_async();
}

sub send_close_mutator_async{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('close_mutator_async', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_close_mutator_async_args->new();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_mutator_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_close_mutator_async_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_mutator_set_cell($mutator, $cell);
  $self->recv_mutator_set_cell();
}

sub send_mutator_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('mutator_set_cell', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_mutator_set_cell_args->new();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_set_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_mutator_set_cell_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cell = shift;

    $self->send_set_cell($ns, $table_name, $cell);
  $self->recv_set_cell();
}

sub send_set_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('set_cell', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_set_cell_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_set_cell_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_mutator_set_cell_as_array($mutator, $cell);
  $self->recv_mutator_set_cell_as_array();
}

sub send_mutator_set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('mutator_set_cell_as_array', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_args->new();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_set_cell_as_array{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cell = shift;

    $self->send_set_cell_as_array($ns, $table_name, $cell);
  $self->recv_set_cell_as_array();
}

sub send_set_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('set_cell_as_array', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_set_cell_as_array_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cell_as_array{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_set_cell_as_array_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_mutator_set_cells($mutator, $cells);
  $self->recv_mutator_set_cells();
}

sub send_mutator_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('mutator_set_cells', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_mutator_set_cells_args->new();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_set_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_mutator_set_cells_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

    $self->send_set_cells($ns, $table_name, $cells);
  $self->recv_set_cells();
}

sub send_set_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('set_cells', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_set_cells_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_set_cells_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_mutator_set_cells_as_arrays($mutator, $cells);
  $self->recv_mutator_set_cells_as_arrays();
}

sub send_mutator_set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('mutator_set_cells_as_arrays', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_args->new();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_set_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

    $self->send_set_cells_as_arrays($ns, $table_name, $cells);
  $self->recv_set_cells_as_arrays();
}

sub send_set_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('set_cells_as_arrays', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_set_cells_as_arrays_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_set_cells_as_arrays_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_set_cells_serialized{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

    $self->send_mutator_set_cells_serialized($mutator, $cells, $flush);
  $self->recv_mutator_set_cells_serialized();
}

sub send_mutator_set_cells_serialized{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

  $self->{output}->writeMessageBegin('mutator_set_cells_serialized', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_args->new();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->{flush} = $flush;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_set_cells_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells_serialized{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

    $self->send_set_cells_serialized($ns, $table_name, $cells);
  $self->recv_set_cells_serialized();
}

sub send_set_cells_serialized{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('set_cells_serialized', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_set_cells_serialized_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_set_cells_serialized_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_flush{
  my $self = shift;
  my $mutator = shift;

    $self->send_mutator_flush($mutator);
  $self->recv_mutator_flush();
}

sub send_mutator_flush{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('mutator_flush', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_mutator_flush_args->new();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_flush{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_mutator_flush_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub flush_mutator{
  my $self = shift;
  my $mutator = shift;

    $self->send_flush_mutator($mutator);
  $self->recv_flush_mutator();
}

sub send_flush_mutator{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('flush_mutator', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_flush_mutator_args->new();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_flush_mutator{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_flush_mutator_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_async_mutator_set_cell($mutator, $cell);
  $self->recv_async_mutator_set_cell();
}

sub send_async_mutator_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('async_mutator_set_cell', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_async_mutator_set_cell_args->new();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_set_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_async_mutator_set_cell_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cell_async{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_set_cell_async($mutator, $cell);
  $self->recv_set_cell_async();
}

sub send_set_cell_async{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('set_cell_async', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_set_cell_async_args->new();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cell_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_set_cell_async_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_async_mutator_set_cell_as_array($mutator, $cell);
  $self->recv_async_mutator_set_cell_as_array();
}

sub send_async_mutator_set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('async_mutator_set_cell_as_array', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_args->new();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_set_cell_as_array{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cell_as_array_async{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_set_cell_as_array_async($mutator, $cell);
  $self->recv_set_cell_as_array_async();
}

sub send_set_cell_as_array_async{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('set_cell_as_array_async', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_set_cell_as_array_async_args->new();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cell_as_array_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_set_cell_as_array_async_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_async_mutator_set_cells($mutator, $cells);
  $self->recv_async_mutator_set_cells();
}

sub send_async_mutator_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('async_mutator_set_cells', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_async_mutator_set_cells_args->new();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_set_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_async_mutator_set_cells_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_set_cells_async($mutator, $cells);
  $self->recv_set_cells_async();
}

sub send_set_cells_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('set_cells_async', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_set_cells_async_args->new();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_set_cells_async_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_async_mutator_set_cells_as_arrays($mutator, $cells);
  $self->recv_async_mutator_set_cells_as_arrays();
}

sub send_async_mutator_set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('async_mutator_set_cells_as_arrays', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_args->new();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_set_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells_as_arrays_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_set_cells_as_arrays_async($mutator, $cells);
  $self->recv_set_cells_as_arrays_async();
}

sub send_set_cells_as_arrays_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('set_cells_as_arrays_async', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_args->new();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells_as_arrays_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_set_cells_serialized{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

    $self->send_async_mutator_set_cells_serialized($mutator, $cells, $flush);
  $self->recv_async_mutator_set_cells_serialized();
}

sub send_async_mutator_set_cells_serialized{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

  $self->{output}->writeMessageBegin('async_mutator_set_cells_serialized', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_args->new();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->{flush} = $flush;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_set_cells_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells_serialized_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

    $self->send_set_cells_serialized_async($mutator, $cells, $flush);
  $self->recv_set_cells_serialized_async();
}

sub send_set_cells_serialized_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

  $self->{output}->writeMessageBegin('set_cells_serialized_async', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_set_cells_serialized_async_args->new();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->{flush} = $flush;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells_serialized_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_set_cells_serialized_async_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_flush{
  my $self = shift;
  my $mutator = shift;

    $self->send_async_mutator_flush($mutator);
  $self->recv_async_mutator_flush();
}

sub send_async_mutator_flush{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('async_mutator_flush', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_async_mutator_flush_args->new();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_flush{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_async_mutator_flush_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub flush_mutator_async{
  my $self = shift;
  my $mutator = shift;

    $self->send_flush_mutator_async($mutator);
  $self->recv_flush_mutator_async();
}

sub send_flush_mutator_async{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('flush_mutator_async', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_flush_mutator_async_args->new();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_flush_mutator_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_flush_mutator_async_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub namespace_exists{
  my $self = shift;
  my $ns = shift;

    $self->send_namespace_exists($ns);
  return $self->recv_namespace_exists();
}

sub send_namespace_exists{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('namespace_exists', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_namespace_exists_args->new();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_namespace_exists{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_namespace_exists_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "namespace_exists failed: unknown result";
}
sub exists_namespace{
  my $self = shift;
  my $ns = shift;

    $self->send_exists_namespace($ns);
  return $self->recv_exists_namespace();
}

sub send_exists_namespace{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('exists_namespace', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_exists_namespace_args->new();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_exists_namespace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_exists_namespace_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "exists_namespace failed: unknown result";
}
sub exists_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;

    $self->send_exists_table($ns, $name);
  return $self->recv_exists_table();
}

sub send_exists_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('exists_table', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_exists_table_args->new();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_exists_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_exists_table_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "exists_table failed: unknown result";
}
sub table_exists{
  my $self = shift;
  my $ns = shift;
  my $name = shift;

    $self->send_table_exists($ns, $name);
  return $self->recv_table_exists();
}

sub send_table_exists{
  my $self = shift;
  my $ns = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('table_exists', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_table_exists_args->new();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_exists{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_table_exists_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "table_exists failed: unknown result";
}
sub table_get_id{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_table_get_id($ns, $table_name);
  return $self->recv_table_get_id();
}

sub send_table_get_id{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('table_get_id', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_table_get_id_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_get_id{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_table_get_id_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "table_get_id failed: unknown result";
}
sub get_table_id{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_get_table_id($ns, $table_name);
  return $self->recv_get_table_id();
}

sub send_get_table_id{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_table_id', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_get_table_id_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_table_id{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_get_table_id_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_table_id failed: unknown result";
}
sub table_get_schema_str{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_table_get_schema_str($ns, $table_name);
  return $self->recv_table_get_schema_str();
}

sub send_table_get_schema_str{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('table_get_schema_str', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_table_get_schema_str_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_get_schema_str{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_table_get_schema_str_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "table_get_schema_str failed: unknown result";
}
sub get_schema_str{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_get_schema_str($ns, $table_name);
  return $self->recv_get_schema_str();
}

sub send_get_schema_str{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_schema_str', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_get_schema_str_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_schema_str{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_get_schema_str_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_schema_str failed: unknown result";
}
sub table_get_schema_str_with_ids{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_table_get_schema_str_with_ids($ns, $table_name);
  return $self->recv_table_get_schema_str_with_ids();
}

sub send_table_get_schema_str_with_ids{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('table_get_schema_str_with_ids', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_table_get_schema_str_with_ids_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_get_schema_str_with_ids{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_table_get_schema_str_with_ids_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "table_get_schema_str_with_ids failed: unknown result";
}
sub get_schema_str_with_ids{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_get_schema_str_with_ids($ns, $table_name);
  return $self->recv_get_schema_str_with_ids();
}

sub send_get_schema_str_with_ids{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_schema_str_with_ids', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_schema_str_with_ids{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_schema_str_with_ids failed: unknown result";
}
sub table_get_schema{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_table_get_schema($ns, $table_name);
  return $self->recv_table_get_schema();
}

sub send_table_get_schema{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('table_get_schema', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_table_get_schema_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_get_schema{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_table_get_schema_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "table_get_schema failed: unknown result";
}
sub get_schema{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_get_schema($ns, $table_name);
  return $self->recv_get_schema();
}

sub send_get_schema{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_schema', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_get_schema_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_schema{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_get_schema_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_schema failed: unknown result";
}
sub get_tables{
  my $self = shift;
  my $ns = shift;

    $self->send_get_tables($ns);
  return $self->recv_get_tables();
}

sub send_get_tables{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('get_tables', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_get_tables_args->new();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_tables{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_get_tables_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_tables failed: unknown result";
}
sub namespace_get_listing{
  my $self = shift;
  my $ns = shift;

    $self->send_namespace_get_listing($ns);
  return $self->recv_namespace_get_listing();
}

sub send_namespace_get_listing{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('namespace_get_listing', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_namespace_get_listing_args->new();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_namespace_get_listing{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_namespace_get_listing_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "namespace_get_listing failed: unknown result";
}
sub get_listing{
  my $self = shift;
  my $ns = shift;

    $self->send_get_listing($ns);
  return $self->recv_get_listing();
}

sub send_get_listing{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('get_listing', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_get_listing_args->new();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_listing{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_get_listing_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_listing failed: unknown result";
}
sub table_get_splits{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_table_get_splits($ns, $table_name);
  return $self->recv_table_get_splits();
}

sub send_table_get_splits{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('table_get_splits', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_table_get_splits_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_get_splits{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_table_get_splits_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "table_get_splits failed: unknown result";
}
sub get_table_splits{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_get_table_splits($ns, $table_name);
  return $self->recv_get_table_splits();
}

sub send_get_table_splits{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_table_splits', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_get_table_splits_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_table_splits{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_get_table_splits_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_table_splits failed: unknown result";
}
sub namespace_drop{
  my $self = shift;
  my $ns = shift;
  my $if_exists = shift;

    $self->send_namespace_drop($ns, $if_exists);
  $self->recv_namespace_drop();
}

sub send_namespace_drop{
  my $self = shift;
  my $ns = shift;
  my $if_exists = shift;

  $self->{output}->writeMessageBegin('namespace_drop', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_namespace_drop_args->new();
  $args->{ns} = $ns;
  $args->{if_exists} = $if_exists;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_namespace_drop{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_namespace_drop_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub drop_namespace{
  my $self = shift;
  my $ns = shift;
  my $if_exists = shift;

    $self->send_drop_namespace($ns, $if_exists);
  $self->recv_drop_namespace();
}

sub send_drop_namespace{
  my $self = shift;
  my $ns = shift;
  my $if_exists = shift;

  $self->{output}->writeMessageBegin('drop_namespace', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_drop_namespace_args->new();
  $args->{ns} = $ns;
  $args->{if_exists} = $if_exists;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_namespace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_drop_namespace_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub rename_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $new_name = shift;

    $self->send_rename_table($ns, $name, $new_name);
  $self->recv_rename_table();
}

sub send_rename_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $new_name = shift;

  $self->{output}->writeMessageBegin('rename_table', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_rename_table_args->new();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->{new_name} = $new_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_rename_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_rename_table_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub table_rename{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $new_name = shift;

    $self->send_table_rename($ns, $name, $new_name);
  $self->recv_table_rename();
}

sub send_table_rename{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $new_name = shift;

  $self->{output}->writeMessageBegin('table_rename', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_table_rename_args->new();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->{new_name} = $new_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_rename{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_table_rename_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub drop_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $if_exists = shift;

    $self->send_drop_table($ns, $name, $if_exists);
  $self->recv_drop_table();
}

sub send_drop_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $if_exists = shift;

  $self->{output}->writeMessageBegin('drop_table', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_drop_table_args->new();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->{if_exists} = $if_exists;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_drop_table_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub table_drop{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $if_exists = shift;

    $self->send_table_drop($ns, $name, $if_exists);
  $self->recv_table_drop();
}

sub send_table_drop{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $if_exists = shift;

  $self->{output}->writeMessageBegin('table_drop', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_table_drop_args->new();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->{if_exists} = $if_exists;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_table_drop{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_table_drop_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub generate_guid{
  my $self = shift;

    $self->send_generate_guid();
  return $self->recv_generate_guid();
}

sub send_generate_guid{
  my $self = shift;

  $self->{output}->writeMessageBegin('generate_guid', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_generate_guid_args->new();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_generate_guid{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_generate_guid_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "generate_guid failed: unknown result";
}
sub create_cell_unique{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $key = shift;
  my $value = shift;

    $self->send_create_cell_unique($ns, $table_name, $key, $value);
  return $self->recv_create_cell_unique();
}

sub send_create_cell_unique{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $key = shift;
  my $value = shift;

  $self->{output}->writeMessageBegin('create_cell_unique', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_create_cell_unique_args->new();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{key} = $key;
  $args->{value} = $value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_cell_unique{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_create_cell_unique_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "create_cell_unique failed: unknown result";
}
sub error_get_text{
  my $self = shift;
  my $error_code = shift;

    $self->send_error_get_text($error_code);
  return $self->recv_error_get_text();
}

sub send_error_get_text{
  my $self = shift;
  my $error_code = shift;

  $self->{output}->writeMessageBegin('error_get_text', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_error_get_text_args->new();
  $args->{error_code} = $error_code;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_error_get_text{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_error_get_text_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "error_get_text failed: unknown result";
}
sub status{
  my $self = shift;

    $self->send_status();
  return $self->recv_status();
}

sub send_status{
  my $self = shift;

  $self->{output}->writeMessageBegin('status', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_status_args->new();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_status{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_status_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "status failed: unknown result";
}
sub shutdown{
  my $self = shift;

    $self->send_shutdown();
  $self->recv_shutdown();
}

sub send_shutdown{
  my $self = shift;

  $self->{output}->writeMessageBegin('shutdown', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hypertable::ThriftGen::ClientService_shutdown_args->new();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shutdown{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hypertable::ThriftGen::ClientService_shutdown_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
package Hypertable::ThriftGen::ClientServiceProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(Thrift::TType::STRUCT);
      $input->readMessageEnd();
      my $x = Thrift::TApplicationException->new('Function '.$fname.' not implemented.', Thrift::TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, Thrift::TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_namespace_create {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_namespace_create_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_namespace_create_result->new();
    eval {
      $self->{handler}->namespace_create($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('namespace_create', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('namespace_create', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_create_namespace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_create_namespace_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_create_namespace_result->new();
    eval {
      $self->{handler}->create_namespace($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('create_namespace', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('create_namespace', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_create {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_table_create_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_table_create_result->new();
    eval {
      $self->{handler}->table_create($args->ns, $args->table_name, $args->schema);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('table_create', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('table_create', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_alter {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_table_alter_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_table_alter_result->new();
    eval {
      $self->{handler}->table_alter($args->ns, $args->table_name, $args->schema);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('table_alter', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('table_alter', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_refresh_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_refresh_table_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_refresh_table_result->new();
    eval {
      $self->{handler}->refresh_table($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('refresh_table', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('refresh_table', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_namespace_open {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_namespace_open_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_namespace_open_result->new();
    eval {
      $result->{success} = $self->{handler}->namespace_open($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('namespace_open', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('namespace_open', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_namespace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_open_namespace_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_open_namespace_result->new();
    eval {
      $result->{success} = $self->{handler}->open_namespace($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('open_namespace', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('open_namespace', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_namespace_close {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_namespace_close_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_namespace_close_result->new();
    eval {
      $self->{handler}->namespace_close($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('namespace_close', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('namespace_close', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_namespace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_close_namespace_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_close_namespace_result->new();
    eval {
      $self->{handler}->close_namespace($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('close_namespace', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('close_namespace', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_open {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_future_open_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_future_open_result->new();
    eval {
      $result->{success} = $self->{handler}->future_open($args->capacity);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('future_open', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('future_open', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_future {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_open_future_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_open_future_result->new();
    eval {
      $result->{success} = $self->{handler}->open_future($args->capacity);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('open_future', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('open_future', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_cancel {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_future_cancel_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_future_cancel_result->new();
    eval {
      $self->{handler}->future_cancel($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('future_cancel', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('future_cancel', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_cancel_future {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_cancel_future_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_cancel_future_result->new();
    eval {
      $self->{handler}->cancel_future($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('cancel_future', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('cancel_future', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_get_result {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_future_get_result_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_future_get_result_result->new();
    eval {
      $result->{success} = $self->{handler}->future_get_result($args->ff, $args->timeout_millis);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('future_get_result', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('future_get_result', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_future_result {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_get_future_result_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_get_future_result_result->new();
    eval {
      $result->{success} = $self->{handler}->get_future_result($args->ff, $args->timeout_millis);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_future_result', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_future_result', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_get_result_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_result->new();
    eval {
      $result->{success} = $self->{handler}->future_get_result_as_arrays($args->ff, $args->timeout_millis);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('future_get_result_as_arrays', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('future_get_result_as_arrays', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_future_result_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_result->new();
    eval {
      $result->{success} = $self->{handler}->get_future_result_as_arrays($args->ff, $args->timeout_millis);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_future_result_as_arrays', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_future_result_as_arrays', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_get_result_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_future_get_result_serialized_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_future_get_result_serialized_result->new();
    eval {
      $result->{success} = $self->{handler}->future_get_result_serialized($args->ff, $args->timeout_millis);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('future_get_result_serialized', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('future_get_result_serialized', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_future_result_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_get_future_result_serialized_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_get_future_result_serialized_result->new();
    eval {
      $result->{success} = $self->{handler}->get_future_result_serialized($args->ff, $args->timeout_millis);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_future_result_serialized', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_future_result_serialized', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_is_empty {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_future_is_empty_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_future_is_empty_result->new();
    eval {
      $result->{success} = $self->{handler}->future_is_empty($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('future_is_empty', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('future_is_empty', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_is_full {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_future_is_full_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_future_is_full_result->new();
    eval {
      $result->{success} = $self->{handler}->future_is_full($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('future_is_full', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('future_is_full', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_is_cancelled {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_future_is_cancelled_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_future_is_cancelled_result->new();
    eval {
      $result->{success} = $self->{handler}->future_is_cancelled($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('future_is_cancelled', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('future_is_cancelled', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_has_outstanding {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_future_has_outstanding_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_future_has_outstanding_result->new();
    eval {
      $result->{success} = $self->{handler}->future_has_outstanding($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('future_has_outstanding', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('future_has_outstanding', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_close {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_future_close_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_future_close_result->new();
    eval {
      $self->{handler}->future_close($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('future_close', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('future_close', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_future {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_close_future_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_close_future_result->new();
    eval {
      $self->{handler}->close_future($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('close_future', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('close_future', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_open {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_scanner_open_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_scanner_open_result->new();
    eval {
      $result->{success} = $self->{handler}->scanner_open($args->ns, $args->table_name, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('scanner_open', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('scanner_open', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_scanner {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_open_scanner_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_open_scanner_result->new();
    eval {
      $result->{success} = $self->{handler}->open_scanner($args->ns, $args->table_name, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('open_scanner', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('open_scanner', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_scanner_open {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_async_scanner_open_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_async_scanner_open_result->new();
    eval {
      $result->{success} = $self->{handler}->async_scanner_open($args->ns, $args->table_name, $args->future, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('async_scanner_open', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('async_scanner_open', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_scanner_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_open_scanner_async_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_open_scanner_async_result->new();
    eval {
      $result->{success} = $self->{handler}->open_scanner_async($args->ns, $args->table_name, $args->future, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('open_scanner_async', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('open_scanner_async', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_close {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_scanner_close_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_scanner_close_result->new();
    eval {
      $self->{handler}->scanner_close($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('scanner_close', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('scanner_close', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_scanner {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_close_scanner_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_close_scanner_result->new();
    eval {
      $self->{handler}->close_scanner($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('close_scanner', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('close_scanner', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_scanner_cancel {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_async_scanner_cancel_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_async_scanner_cancel_result->new();
    eval {
      $self->{handler}->async_scanner_cancel($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('async_scanner_cancel', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('async_scanner_cancel', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_cancel_scanner_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_cancel_scanner_async_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_cancel_scanner_async_result->new();
    eval {
      $self->{handler}->cancel_scanner_async($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('cancel_scanner_async', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('cancel_scanner_async', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_scanner_close {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_async_scanner_close_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_async_scanner_close_result->new();
    eval {
      $self->{handler}->async_scanner_close($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('async_scanner_close', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('async_scanner_close', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_scanner_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_close_scanner_async_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_close_scanner_async_result->new();
    eval {
      $self->{handler}->close_scanner_async($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('close_scanner_async', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('close_scanner_async', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_get_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_scanner_get_cells_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_scanner_get_cells_result->new();
    eval {
      $result->{success} = $self->{handler}->scanner_get_cells($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('scanner_get_cells', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('scanner_get_cells', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_next_cells_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_next_cells_result->new();
    eval {
      $result->{success} = $self->{handler}->next_cells($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('next_cells', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('next_cells', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_get_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_result->new();
    eval {
      $result->{success} = $self->{handler}->scanner_get_cells_as_arrays($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('scanner_get_cells_as_arrays', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('scanner_get_cells_as_arrays', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_next_cells_as_arrays_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_next_cells_as_arrays_result->new();
    eval {
      $result->{success} = $self->{handler}->next_cells_as_arrays($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('next_cells_as_arrays', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('next_cells_as_arrays', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_get_cells_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_result->new();
    eval {
      $result->{success} = $self->{handler}->scanner_get_cells_serialized($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('scanner_get_cells_serialized', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('scanner_get_cells_serialized', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_cells_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_next_cells_serialized_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_next_cells_serialized_result->new();
    eval {
      $result->{success} = $self->{handler}->next_cells_serialized($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('next_cells_serialized', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('next_cells_serialized', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_get_row {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_scanner_get_row_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_scanner_get_row_result->new();
    eval {
      $result->{success} = $self->{handler}->scanner_get_row($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('scanner_get_row', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('scanner_get_row', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_row {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_next_row_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_next_row_result->new();
    eval {
      $result->{success} = $self->{handler}->next_row($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('next_row', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('next_row', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_get_row_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_result->new();
    eval {
      $result->{success} = $self->{handler}->scanner_get_row_as_arrays($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('scanner_get_row_as_arrays', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('scanner_get_row_as_arrays', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_row_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_next_row_as_arrays_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_next_row_as_arrays_result->new();
    eval {
      $result->{success} = $self->{handler}->next_row_as_arrays($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('next_row_as_arrays', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('next_row_as_arrays', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_get_row_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_result->new();
    eval {
      $result->{success} = $self->{handler}->scanner_get_row_serialized($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('scanner_get_row_serialized', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('scanner_get_row_serialized', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_row_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_next_row_serialized_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_next_row_serialized_result->new();
    eval {
      $result->{success} = $self->{handler}->next_row_serialized($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('next_row_serialized', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('next_row_serialized', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_row {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_get_row_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_get_row_result->new();
    eval {
      $result->{success} = $self->{handler}->get_row($args->ns, $args->table_name, $args->row);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_row', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_row', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_row_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_get_row_as_arrays_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_get_row_as_arrays_result->new();
    eval {
      $result->{success} = $self->{handler}->get_row_as_arrays($args->ns, $args->name, $args->row);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_row_as_arrays', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_row_as_arrays', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_row_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_get_row_serialized_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_get_row_serialized_result->new();
    eval {
      $result->{success} = $self->{handler}->get_row_serialized($args->ns, $args->table_name, $args->row);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_row_serialized', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_row_serialized', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_get_cell_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_get_cell_result->new();
    eval {
      $result->{success} = $self->{handler}->get_cell($args->ns, $args->table_name, $args->row, $args->column);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_cell', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_cell', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_get_cells_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_get_cells_result->new();
    eval {
      $result->{success} = $self->{handler}->get_cells($args->ns, $args->table_name, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_cells', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_cells', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_get_cells_as_arrays_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_get_cells_as_arrays_result->new();
    eval {
      $result->{success} = $self->{handler}->get_cells_as_arrays($args->ns, $args->name, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_cells_as_arrays', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_cells_as_arrays', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_cells_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_get_cells_serialized_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_get_cells_serialized_result->new();
    eval {
      $result->{success} = $self->{handler}->get_cells_serialized($args->ns, $args->name, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_cells_serialized', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_cells_serialized', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shared_mutator_refresh {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_shared_mutator_refresh_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_shared_mutator_refresh_result->new();
    eval {
      $self->{handler}->shared_mutator_refresh($args->ns, $args->table_name, $args->mutate_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('shared_mutator_refresh', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('shared_mutator_refresh', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_refresh_shared_mutator {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_refresh_shared_mutator_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_refresh_shared_mutator_result->new();
    eval {
      $self->{handler}->refresh_shared_mutator($args->ns, $args->table_name, $args->mutate_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('refresh_shared_mutator', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('refresh_shared_mutator', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shared_mutator_set_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_result->new();
    eval {
      $self->{handler}->shared_mutator_set_cells($args->ns, $args->table_name, $args->mutate_spec, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('shared_mutator_set_cells', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('shared_mutator_set_cells', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_offer_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_offer_cells_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_offer_cells_result->new();
    eval {
      $self->{handler}->offer_cells($args->ns, $args->table_name, $args->mutate_spec, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('offer_cells', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('offer_cells', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shared_mutator_set_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_as_arrays_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_shared_mutator_set_cells_as_arrays_result->new();
    eval {
      $self->{handler}->shared_mutator_set_cells_as_arrays($args->ns, $args->table_name, $args->mutate_spec, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('shared_mutator_set_cells_as_arrays', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('shared_mutator_set_cells_as_arrays', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_offer_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_result->new();
    eval {
      $self->{handler}->offer_cells_as_arrays($args->ns, $args->table_name, $args->mutate_spec, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('offer_cells_as_arrays', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('offer_cells_as_arrays', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shared_mutator_set_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_result->new();
    eval {
      $self->{handler}->shared_mutator_set_cell($args->ns, $args->table_name, $args->mutate_spec, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('shared_mutator_set_cell', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('shared_mutator_set_cell', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_offer_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_offer_cell_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_offer_cell_result->new();
    eval {
      $self->{handler}->offer_cell($args->ns, $args->table_name, $args->mutate_spec, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('offer_cell', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('offer_cell', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shared_mutator_set_cell_as_array {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_as_array_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_shared_mutator_set_cell_as_array_result->new();
    eval {
      $self->{handler}->shared_mutator_set_cell_as_array($args->ns, $args->table_name, $args->mutate_spec, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('shared_mutator_set_cell_as_array', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('shared_mutator_set_cell_as_array', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_offer_cell_as_array {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_offer_cell_as_array_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_offer_cell_as_array_result->new();
    eval {
      $self->{handler}->offer_cell_as_array($args->ns, $args->table_name, $args->mutate_spec, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('offer_cell_as_array', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('offer_cell_as_array', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_open {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_mutator_open_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_mutator_open_result->new();
    eval {
      $result->{success} = $self->{handler}->mutator_open($args->ns, $args->table_name, $args->flags, $args->flush_interval);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('mutator_open', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('mutator_open', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_mutator {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_open_mutator_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_open_mutator_result->new();
    eval {
      $result->{success} = $self->{handler}->open_mutator($args->ns, $args->table_name, $args->flags, $args->flush_interval);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('open_mutator', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('open_mutator', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_open {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_async_mutator_open_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_async_mutator_open_result->new();
    eval {
      $result->{success} = $self->{handler}->async_mutator_open($args->ns, $args->table_name, $args->future, $args->flags);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('async_mutator_open', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('async_mutator_open', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_mutator_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_open_mutator_async_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_open_mutator_async_result->new();
    eval {
      $result->{success} = $self->{handler}->open_mutator_async($args->ns, $args->table_name, $args->future, $args->flags);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('open_mutator_async', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('open_mutator_async', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_close {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_mutator_close_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_mutator_close_result->new();
    eval {
      $self->{handler}->mutator_close($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('mutator_close', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('mutator_close', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_mutator {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_close_mutator_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_close_mutator_result->new();
    eval {
      $self->{handler}->close_mutator($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('close_mutator', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('close_mutator', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_cancel {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_async_mutator_cancel_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_async_mutator_cancel_result->new();
    eval {
      $self->{handler}->async_mutator_cancel($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('async_mutator_cancel', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('async_mutator_cancel', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_cancel_mutator_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_cancel_mutator_async_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_cancel_mutator_async_result->new();
    eval {
      $self->{handler}->cancel_mutator_async($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('cancel_mutator_async', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('cancel_mutator_async', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_close {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_async_mutator_close_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_async_mutator_close_result->new();
    eval {
      $self->{handler}->async_mutator_close($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('async_mutator_close', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('async_mutator_close', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_mutator_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_close_mutator_async_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_close_mutator_async_result->new();
    eval {
      $self->{handler}->close_mutator_async($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('close_mutator_async', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('close_mutator_async', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_set_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_mutator_set_cell_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_mutator_set_cell_result->new();
    eval {
      $self->{handler}->mutator_set_cell($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('mutator_set_cell', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('mutator_set_cell', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_set_cell_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_set_cell_result->new();
    eval {
      $self->{handler}->set_cell($args->ns, $args->table_name, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('set_cell', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('set_cell', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_set_cell_as_array {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_result->new();
    eval {
      $self->{handler}->mutator_set_cell_as_array($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('mutator_set_cell_as_array', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('mutator_set_cell_as_array', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cell_as_array {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_set_cell_as_array_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_set_cell_as_array_result->new();
    eval {
      $self->{handler}->set_cell_as_array($args->ns, $args->table_name, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('set_cell_as_array', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('set_cell_as_array', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_set_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_mutator_set_cells_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_mutator_set_cells_result->new();
    eval {
      $self->{handler}->mutator_set_cells($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('mutator_set_cells', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('mutator_set_cells', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_set_cells_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_set_cells_result->new();
    eval {
      $self->{handler}->set_cells($args->ns, $args->table_name, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('set_cells', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('set_cells', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_set_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_result->new();
    eval {
      $self->{handler}->mutator_set_cells_as_arrays($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('mutator_set_cells_as_arrays', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('mutator_set_cells_as_arrays', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_set_cells_as_arrays_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_set_cells_as_arrays_result->new();
    eval {
      $self->{handler}->set_cells_as_arrays($args->ns, $args->table_name, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('set_cells_as_arrays', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('set_cells_as_arrays', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_set_cells_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_result->new();
    eval {
      $self->{handler}->mutator_set_cells_serialized($args->mutator, $args->cells, $args->flush);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('mutator_set_cells_serialized', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('mutator_set_cells_serialized', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_set_cells_serialized_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_set_cells_serialized_result->new();
    eval {
      $self->{handler}->set_cells_serialized($args->ns, $args->table_name, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('set_cells_serialized', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('set_cells_serialized', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_flush {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_mutator_flush_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_mutator_flush_result->new();
    eval {
      $self->{handler}->mutator_flush($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('mutator_flush', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('mutator_flush', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_flush_mutator {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_flush_mutator_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_flush_mutator_result->new();
    eval {
      $self->{handler}->flush_mutator($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('flush_mutator', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('flush_mutator', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_set_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_async_mutator_set_cell_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_async_mutator_set_cell_result->new();
    eval {
      $self->{handler}->async_mutator_set_cell($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('async_mutator_set_cell', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('async_mutator_set_cell', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cell_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_set_cell_async_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_set_cell_async_result->new();
    eval {
      $self->{handler}->set_cell_async($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('set_cell_async', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('set_cell_async', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_set_cell_as_array {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_result->new();
    eval {
      $self->{handler}->async_mutator_set_cell_as_array($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('async_mutator_set_cell_as_array', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('async_mutator_set_cell_as_array', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cell_as_array_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_set_cell_as_array_async_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_set_cell_as_array_async_result->new();
    eval {
      $self->{handler}->set_cell_as_array_async($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('set_cell_as_array_async', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('set_cell_as_array_async', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_set_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_async_mutator_set_cells_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_async_mutator_set_cells_result->new();
    eval {
      $self->{handler}->async_mutator_set_cells($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('async_mutator_set_cells', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('async_mutator_set_cells', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_set_cells_async_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_set_cells_async_result->new();
    eval {
      $self->{handler}->set_cells_async($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('set_cells_async', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('set_cells_async', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_set_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_result->new();
    eval {
      $self->{handler}->async_mutator_set_cells_as_arrays($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('async_mutator_set_cells_as_arrays', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('async_mutator_set_cells_as_arrays', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells_as_arrays_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_result->new();
    eval {
      $self->{handler}->set_cells_as_arrays_async($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('set_cells_as_arrays_async', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('set_cells_as_arrays_async', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_set_cells_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_result->new();
    eval {
      $self->{handler}->async_mutator_set_cells_serialized($args->mutator, $args->cells, $args->flush);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('async_mutator_set_cells_serialized', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('async_mutator_set_cells_serialized', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells_serialized_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_set_cells_serialized_async_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_set_cells_serialized_async_result->new();
    eval {
      $self->{handler}->set_cells_serialized_async($args->mutator, $args->cells, $args->flush);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('set_cells_serialized_async', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('set_cells_serialized_async', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_flush {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_async_mutator_flush_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_async_mutator_flush_result->new();
    eval {
      $self->{handler}->async_mutator_flush($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('async_mutator_flush', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('async_mutator_flush', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_flush_mutator_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_flush_mutator_async_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_flush_mutator_async_result->new();
    eval {
      $self->{handler}->flush_mutator_async($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('flush_mutator_async', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('flush_mutator_async', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_namespace_exists {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_namespace_exists_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_namespace_exists_result->new();
    eval {
      $result->{success} = $self->{handler}->namespace_exists($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('namespace_exists', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('namespace_exists', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_exists_namespace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_exists_namespace_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_exists_namespace_result->new();
    eval {
      $result->{success} = $self->{handler}->exists_namespace($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('exists_namespace', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('exists_namespace', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_exists_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_exists_table_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_exists_table_result->new();
    eval {
      $result->{success} = $self->{handler}->exists_table($args->ns, $args->name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('exists_table', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('exists_table', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_exists {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_table_exists_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_table_exists_result->new();
    eval {
      $result->{success} = $self->{handler}->table_exists($args->ns, $args->name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('table_exists', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('table_exists', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_get_id {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_table_get_id_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_table_get_id_result->new();
    eval {
      $result->{success} = $self->{handler}->table_get_id($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('table_get_id', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('table_get_id', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_table_id {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_get_table_id_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_get_table_id_result->new();
    eval {
      $result->{success} = $self->{handler}->get_table_id($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_table_id', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_table_id', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_get_schema_str {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_table_get_schema_str_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_table_get_schema_str_result->new();
    eval {
      $result->{success} = $self->{handler}->table_get_schema_str($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('table_get_schema_str', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('table_get_schema_str', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_schema_str {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_get_schema_str_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_get_schema_str_result->new();
    eval {
      $result->{success} = $self->{handler}->get_schema_str($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_schema_str', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_schema_str', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_get_schema_str_with_ids {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_table_get_schema_str_with_ids_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_table_get_schema_str_with_ids_result->new();
    eval {
      $result->{success} = $self->{handler}->table_get_schema_str_with_ids($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('table_get_schema_str_with_ids', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('table_get_schema_str_with_ids', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_schema_str_with_ids {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_result->new();
    eval {
      $result->{success} = $self->{handler}->get_schema_str_with_ids($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_schema_str_with_ids', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_schema_str_with_ids', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_get_schema {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_table_get_schema_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_table_get_schema_result->new();
    eval {
      $result->{success} = $self->{handler}->table_get_schema($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('table_get_schema', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('table_get_schema', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_schema {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_get_schema_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_get_schema_result->new();
    eval {
      $result->{success} = $self->{handler}->get_schema($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_schema', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_schema', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_tables {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_get_tables_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_get_tables_result->new();
    eval {
      $result->{success} = $self->{handler}->get_tables($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_tables', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_tables', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_namespace_get_listing {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_namespace_get_listing_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_namespace_get_listing_result->new();
    eval {
      $result->{success} = $self->{handler}->namespace_get_listing($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('namespace_get_listing', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('namespace_get_listing', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_listing {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_get_listing_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_get_listing_result->new();
    eval {
      $result->{success} = $self->{handler}->get_listing($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_listing', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_listing', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_get_splits {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_table_get_splits_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_table_get_splits_result->new();
    eval {
      $result->{success} = $self->{handler}->table_get_splits($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('table_get_splits', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('table_get_splits', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_table_splits {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_get_table_splits_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_get_table_splits_result->new();
    eval {
      $result->{success} = $self->{handler}->get_table_splits($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get_table_splits', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get_table_splits', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_namespace_drop {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_namespace_drop_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_namespace_drop_result->new();
    eval {
      $self->{handler}->namespace_drop($args->ns, $args->if_exists);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('namespace_drop', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('namespace_drop', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_namespace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_drop_namespace_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_drop_namespace_result->new();
    eval {
      $self->{handler}->drop_namespace($args->ns, $args->if_exists);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('drop_namespace', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('drop_namespace', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_rename_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_rename_table_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_rename_table_result->new();
    eval {
      $self->{handler}->rename_table($args->ns, $args->name, $args->new_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('rename_table', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('rename_table', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_rename {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_table_rename_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_table_rename_result->new();
    eval {
      $self->{handler}->table_rename($args->ns, $args->name, $args->new_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('table_rename', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('table_rename', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_drop_table_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_drop_table_result->new();
    eval {
      $self->{handler}->drop_table($args->ns, $args->name, $args->if_exists);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('drop_table', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('drop_table', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_table_drop {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_table_drop_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_table_drop_result->new();
    eval {
      $self->{handler}->table_drop($args->ns, $args->name, $args->if_exists);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('table_drop', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('table_drop', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_generate_guid {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_generate_guid_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_generate_guid_result->new();
    $result->{success} = $self->{handler}->generate_guid();
    $output->writeMessageBegin('generate_guid', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_create_cell_unique {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_create_cell_unique_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_create_cell_unique_result->new();
    eval {
      $result->{success} = $self->{handler}->create_cell_unique($args->ns, $args->table_name, $args->key, $args->value);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('create_cell_unique', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('create_cell_unique', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_error_get_text {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_error_get_text_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_error_get_text_result->new();
    $result->{success} = $self->{handler}->error_get_text($args->error_code);
    $output->writeMessageBegin('error_get_text', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_status {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_status_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_status_result->new();
    eval {
      $result->{success} = $self->{handler}->status();
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('status', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('status', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shutdown {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hypertable::ThriftGen::ClientService_shutdown_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hypertable::ThriftGen::ClientService_shutdown_result->new();
    eval {
      $self->{handler}->shutdown();
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('shutdown', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('shutdown', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
