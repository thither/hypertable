#
# Autogenerated by Thrift Compiler (0.12.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'

module Hypertable
  module ThriftGen
    module ColumnPredicateOperation
      EXACT_MATCH = 1
      PREFIX_MATCH = 2
      REGEX_MATCH = 4
      VALUE_MATCH = 7
      QUALIFIER_EXACT_MATCH = 256
      QUALIFIER_PREFIX_MATCH = 512
      QUALIFIER_REGEX_MATCH = 1024
      QUALIFIER_MATCH = 1792
      VALUE_MAP = {1 => "EXACT_MATCH", 2 => "PREFIX_MATCH", 4 => "REGEX_MATCH", 7 => "VALUE_MATCH", 256 => "QUALIFIER_EXACT_MATCH", 512 => "QUALIFIER_PREFIX_MATCH", 1024 => "QUALIFIER_REGEX_MATCH", 1792 => "QUALIFIER_MATCH"}
      VALID_VALUES = Set.new([EXACT_MATCH, PREFIX_MATCH, REGEX_MATCH, VALUE_MATCH, QUALIFIER_EXACT_MATCH, QUALIFIER_PREFIX_MATCH, QUALIFIER_REGEX_MATCH, QUALIFIER_MATCH]).freeze
    end

    module KeyFlag
      DELETE_ROW = 0
      DELETE_CF = 1
      DELETE_CELL = 2
      DELETE_CELL_VERSION = 3
      INSERT = 255
      VALUE_MAP = {0 => "DELETE_ROW", 1 => "DELETE_CF", 2 => "DELETE_CELL", 3 => "DELETE_CELL_VERSION", 255 => "INSERT"}
      VALID_VALUES = Set.new([DELETE_ROW, DELETE_CF, DELETE_CELL, DELETE_CELL_VERSION, INSERT]).freeze
    end

    module MutatorFlag
      NO_LOG_SYNC = 1
      IGNORE_UNKNOWN_CFS = 2
      NO_LOG = 4
      VALUE_MAP = {1 => "NO_LOG_SYNC", 2 => "IGNORE_UNKNOWN_CFS", 4 => "NO_LOG"}
      VALID_VALUES = Set.new([NO_LOG_SYNC, IGNORE_UNKNOWN_CFS, NO_LOG]).freeze
    end

    module StatusCode
      OK = 0
      WARNING = 1
      CRITICAL = 2
      UNKNOWN = 3
      VALUE_MAP = {0 => "OK", 1 => "WARNING", 2 => "CRITICAL", 3 => "UNKNOWN"}
      VALID_VALUES = Set.new([OK, WARNING, CRITICAL, UNKNOWN]).freeze
    end

    class RowInterval; end

    class CellInterval; end

    class ColumnPredicate; end

    class ScanSpec; end

    class Key; end

    class MutateSpec; end

    class Cell; end

    class Result; end

    class ResultAsArrays; end

    class ResultSerialized; end

    class NamespaceListing; end

    class TableSplit; end

    class ColumnFamilyOptions; end

    class ColumnFamilySpec; end

    class AccessGroupOptions; end

    class AccessGroupSpec; end

    class Schema; end

    class Status; end

    class ClientException < ::Thrift::Exception; end

    # Specifies a range of rows
# 
# <dl>
#   <dt>start_row</dt>
#   <dd>The row to start scan with. Must not contain nulls (0x00)</dd>
# 
#   <dt>start_inclusive</dt>
#   <dd>Whether the start row is included in the result (default: true)</dd>
# 
#   <dt>end_row</dt>
#   <dd>The row to end scan with. Must not contain nulls</dd>
# 
#   <dt>end_inclusive</dt>
#   <dd>Whether the end row is included in the result (default: true)</dd>
# </dl>
    class RowInterval
      include ::Thrift::Struct, ::Thrift::Struct_Union
      START_ROW = 1
      START_INCLUSIVE = 2
      END_ROW = 3
      END_INCLUSIVE = 4
      START_ROW_BINARY = 5
      END_ROW_BINARY = 6

      FIELDS = {
        START_ROW => {:type => ::Thrift::Types::STRING, :name => 'start_row', :optional => true},
        START_INCLUSIVE => {:type => ::Thrift::Types::BOOL, :name => 'start_inclusive', :default => true, :optional => true},
        END_ROW => {:type => ::Thrift::Types::STRING, :name => 'end_row', :optional => true},
        END_INCLUSIVE => {:type => ::Thrift::Types::BOOL, :name => 'end_inclusive', :default => true, :optional => true},
        START_ROW_BINARY => {:type => ::Thrift::Types::STRING, :name => 'start_row_binary', :binary => true, :optional => true},
        END_ROW_BINARY => {:type => ::Thrift::Types::STRING, :name => 'end_row_binary', :binary => true, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    # Specifies a range of cells
# 
# <dl>
#   <dt>start_row</dt>
#   <dd>The row to start scan with. Must not contain nulls (0x00)</dd>
# 
#   <dt>start_column</dt>
#   <dd>The column (prefix of column_family:column_qualifier) of the
#   start row for the scan</dd>
# 
#   <dt>start_inclusive</dt>
#   <dd>Whether the start row is included in the result (default: true)</dd>
# 
#   <dt>end_row</dt>
#   <dd>The row to end scan with. Must not contain nulls</dd>
# 
#   <dt>end_column</dt>
#   <dd>The column (prefix of column_family:column_qualifier) of the
#   end row for the scan</dd>
# 
#   <dt>end_inclusive</dt>
#   <dd>Whether the end row is included in the result (default: true)</dd>
# </dl>
    class CellInterval
      include ::Thrift::Struct, ::Thrift::Struct_Union
      START_ROW = 1
      START_COLUMN = 2
      START_INCLUSIVE = 3
      END_ROW = 4
      END_COLUMN = 5
      END_INCLUSIVE = 6

      FIELDS = {
        START_ROW => {:type => ::Thrift::Types::STRING, :name => 'start_row', :optional => true},
        START_COLUMN => {:type => ::Thrift::Types::STRING, :name => 'start_column', :optional => true},
        START_INCLUSIVE => {:type => ::Thrift::Types::BOOL, :name => 'start_inclusive', :default => true, :optional => true},
        END_ROW => {:type => ::Thrift::Types::STRING, :name => 'end_row', :optional => true},
        END_COLUMN => {:type => ::Thrift::Types::STRING, :name => 'end_column', :optional => true},
        END_INCLUSIVE => {:type => ::Thrift::Types::BOOL, :name => 'end_inclusive', :default => true, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    # Specifies a column predicate
#     ... WHERE column = "value"
#   or
#     ... WHERE column =^ "prefix"
# 
# <dl>
#   <dt>column_family</dt>
#   <dd>The name of the column family</dd>
# 
#   <dt>operation</dt>
#   <dd>The predicate operation; either EXACT_MATCH or PREFIX_MATCH</dd>
# 
#   <dt>value</dt>
#   <dd>The cell value or cell prefix, depending on the operation</dd>
# 
#   <dt>value_len</dt>
#   <dd>The size of the value</dd>
# 
#   <dt>column_qualifier</dt>
#   <dd>The column qualifier</dd>
# </dl>
    class ColumnPredicate
      include ::Thrift::Struct, ::Thrift::Struct_Union
      COLUMN_FAMILY = 1
      COLUMN_QUALIFIER = 2
      OPERATION = 3
      VALUE = 4

      FIELDS = {
        COLUMN_FAMILY => {:type => ::Thrift::Types::STRING, :name => 'column_family', :optional => true},
        COLUMN_QUALIFIER => {:type => ::Thrift::Types::STRING, :name => 'column_qualifier', :optional => true},
        OPERATION => {:type => ::Thrift::Types::I32, :name => 'operation'},
        VALUE => {:type => ::Thrift::Types::STRING, :name => 'value', :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    # Specifies options for a scan
# 
# <dl>
#   <dt>row_intervals</dt>
#   <dd>A list of ranges of rows to scan. Mutually exclusive with
#   cell_interval</dd>
# 
#   <dt>cell_intervals</dt>
#   <dd>A list of ranges of cells to scan. Mutually exclusive with
#   row_intervals</dd>
# 
#   <dt>return_deletes</dt>
#   <dd>Indicates whether cells pending delete are returned</dd>
# 
#   <dt>revs</dt>
#   <dd>Specifies max number of revisions of cells to return</dd>
# 
#   <dt>row_limit</dt>
#   <dd>Specifies max number of rows to return</dd>
# 
#   <dt>start_time</dt>
#   <dd>Specifies start time in nanoseconds since epoch for cells to
#   return</dd>
# 
#   <dt>end_time</dt>
#   <dd>Specifies end time in nanoseconds since epoch for cells to return</dd>
# 
#   <dt>columns</dt>
#   <dd>Specifies the names of the columns to return</dd>
# 
#   <dt>cell_limit</dt>
#   <dd>Specifies max number of cells to return</dd>
# 
#   <dt>cell_limit_per_family</dt>
#   <dd>Specifies max number of cells to return per column family</dd>
# 
#   <dt>row_regexp</dt>
#   <dd>Specifies a regexp used to filter by rowkey</dd>
# 
#   <dt>value_regexp</dt>
#   <dd>Specifies a regexp used to filter by cell value</dd>
# 
#   <dt>scan_and_filter_rows</dt>
#   <dd>Indicates whether table scan filters the rows specified instead of individual look up</dd>
# 
#   <dt>row_offset</dt>
#   <dd>Specifies number of rows to be skipped</dd>
# 
#   <dt>cell_offset</dt>
#   <dd>Specifies number of cells to be skipped</dd>
# </dl>
    class ScanSpec
      include ::Thrift::Struct, ::Thrift::Struct_Union
      ROW_INTERVALS = 1
      CELL_INTERVALS = 2
      RETURN_DELETES = 3
      VERSIONS = 4
      ROW_LIMIT = 5
      START_TIME = 6
      END_TIME = 7
      COLUMNS = 8
      KEYS_ONLY = 9
      CELL_LIMIT = 14
      CELL_LIMIT_PER_FAMILY = 10
      ROW_REGEXP = 11
      VALUE_REGEXP = 12
      SCAN_AND_FILTER_ROWS = 13
      ROW_OFFSET = 15
      CELL_OFFSET = 16
      COLUMN_PREDICATES = 17
      DO_NOT_CACHE = 18
      AND_COLUMN_PREDICATES = 19

      FIELDS = {
        ROW_INTERVALS => {:type => ::Thrift::Types::LIST, :name => 'row_intervals', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Hypertable::ThriftGen::RowInterval}, :optional => true},
        CELL_INTERVALS => {:type => ::Thrift::Types::LIST, :name => 'cell_intervals', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Hypertable::ThriftGen::CellInterval}, :optional => true},
        RETURN_DELETES => {:type => ::Thrift::Types::BOOL, :name => 'return_deletes', :default => false, :optional => true},
        VERSIONS => {:type => ::Thrift::Types::I32, :name => 'versions', :default => 0, :optional => true},
        ROW_LIMIT => {:type => ::Thrift::Types::I32, :name => 'row_limit', :default => 0, :optional => true},
        START_TIME => {:type => ::Thrift::Types::I64, :name => 'start_time', :optional => true},
        END_TIME => {:type => ::Thrift::Types::I64, :name => 'end_time', :optional => true},
        COLUMNS => {:type => ::Thrift::Types::LIST, :name => 'columns', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
        KEYS_ONLY => {:type => ::Thrift::Types::BOOL, :name => 'keys_only', :default => false, :optional => true},
        CELL_LIMIT => {:type => ::Thrift::Types::I32, :name => 'cell_limit', :default => 0, :optional => true},
        CELL_LIMIT_PER_FAMILY => {:type => ::Thrift::Types::I32, :name => 'cell_limit_per_family', :default => 0, :optional => true},
        ROW_REGEXP => {:type => ::Thrift::Types::STRING, :name => 'row_regexp', :optional => true},
        VALUE_REGEXP => {:type => ::Thrift::Types::STRING, :name => 'value_regexp', :optional => true},
        SCAN_AND_FILTER_ROWS => {:type => ::Thrift::Types::BOOL, :name => 'scan_and_filter_rows', :default => false, :optional => true},
        ROW_OFFSET => {:type => ::Thrift::Types::I32, :name => 'row_offset', :default => 0, :optional => true},
        CELL_OFFSET => {:type => ::Thrift::Types::I32, :name => 'cell_offset', :default => 0, :optional => true},
        COLUMN_PREDICATES => {:type => ::Thrift::Types::LIST, :name => 'column_predicates', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Hypertable::ThriftGen::ColumnPredicate}, :optional => true},
        DO_NOT_CACHE => {:type => ::Thrift::Types::BOOL, :name => 'do_not_cache', :default => false, :optional => true},
        AND_COLUMN_PREDICATES => {:type => ::Thrift::Types::BOOL, :name => 'and_column_predicates', :default => false, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    # Defines a cell key
# 
# <dl>
#   <dt>row</dt>
#   <dd>Specifies the row key. Note, it cannot contain null characters.
#   If a row key is not specified in a return cell, it's assumed to
#   be the same as the previous cell</dd>
# 
#   <dt>column_family</dt>
#   <dd>Specifies the column family</dd>
# 
#   <dt>column_qualifier</dt>
#   <dd>Specifies the column qualifier. A column family must be specified.</dd>
# 
#   <dt>timestamp</dt>
#   <dd>Nanoseconds since epoch for the cell<dd>
# 
#   <dt>revision</dt>
#   <dd>A 64-bit revision number for the cell</dd>
# 
#   <dt>flag</dt>
#   <dd>A 16-bit integer indicating the state of the cell</dd>
# </dl>
    class Key
      include ::Thrift::Struct, ::Thrift::Struct_Union
      ROW = 1
      COLUMN_FAMILY = 2
      COLUMN_QUALIFIER = 3
      TIMESTAMP = 4
      REVISION = 5
      FLAG = 6

      FIELDS = {
        ROW => {:type => ::Thrift::Types::STRING, :name => 'row'},
        COLUMN_FAMILY => {:type => ::Thrift::Types::STRING, :name => 'column_family'},
        COLUMN_QUALIFIER => {:type => ::Thrift::Types::STRING, :name => 'column_qualifier'},
        TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp', :optional => true},
        REVISION => {:type => ::Thrift::Types::I64, :name => 'revision', :optional => true},
        FLAG => {:type => ::Thrift::Types::I32, :name => 'flag', :default =>         255, :enum_class => ::Hypertable::ThriftGen::KeyFlag}
      }

      def struct_fields; FIELDS; end

      def validate
        unless @flag.nil? || ::Hypertable::ThriftGen::KeyFlag::VALID_VALUES.include?(@flag)
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field flag!')
        end
      end

      ::Thrift::Struct.generate_accessors self
    end

    # Specifies options for a shared periodic mutator
# 
# <dl>
#   <dt>appname</dt>
#   <dd>String key used to share/retrieve mutator, eg: "my_ht_app"</dd>
# 
#   <dt>flush_interval</dt>
#   <dd>Time interval between flushes</dd>
# 
#   <dt>flags</dt>
#   <dd>Mutator flags</dt>
# </dl>
    class MutateSpec
      include ::Thrift::Struct, ::Thrift::Struct_Union
      APPNAME = 1
      FLUSH_INTERVAL = 2
      FLAGS = 3

      FIELDS = {
        APPNAME => {:type => ::Thrift::Types::STRING, :name => 'appname', :default => %q""},
        FLUSH_INTERVAL => {:type => ::Thrift::Types::I32, :name => 'flush_interval', :default => 1000},
        FLAGS => {:type => ::Thrift::Types::I32, :name => 'flags', :default => 2}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field appname is unset!') unless @appname
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field flush_interval is unset!') unless @flush_interval
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field flags is unset!') unless @flags
      end

      ::Thrift::Struct.generate_accessors self
    end

    # Defines a table cell
# 
# <dl>
#   <dt>key</dt>
#   <dd>Specifies the cell key</dd>
# 
#   <dt>value</dt>
#   <dd>Value of a cell. Currently a sequence of uninterpreted bytes.</dd>
# </dl>
    class Cell
      include ::Thrift::Struct, ::Thrift::Struct_Union
      KEY = 1
      VALUE = 2

      FIELDS = {
        KEY => {:type => ::Thrift::Types::STRUCT, :name => 'key', :class => ::Hypertable::ThriftGen::Key},
        VALUE => {:type => ::Thrift::Types::STRING, :name => 'value', :binary => true, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    # Specifies a result object for asynchronous requests.
# TODO: add support for update results
# 
# <dl>
#   <dt>is_empty</dt>
#   <dd>Indicates whether this object contains a result or not</dd>
# 
#   <dt>id</dt>
#   <dd>Scanner/mutator id for which these results pertain to</dd>
#   
#   <dt>is_scan</dt>
#   <dd>Indicates whether these are scan results or update results</dd>
#   
#   <dt>is_error</dt>
#   <dd>Indicates whether the async request was successful or not</dd>
#   
#   <dt>error</dt>
#   <dd>Error code</dd>
# 
#   <dt>error_msg</dt>
#   <dd>Error message</dd>
# 
#   <dt>cells</dt>
#   <dd>Cells returned by asynchronous scanner</dd>
# </dl>
    class Result
      include ::Thrift::Struct, ::Thrift::Struct_Union
      IS_EMPTY = 1
      ID = 2
      IS_SCAN = 3
      IS_ERROR = 4
      ERROR = 5
      ERROR_MSG = 6
      CELLS = 7

      FIELDS = {
        IS_EMPTY => {:type => ::Thrift::Types::BOOL, :name => 'is_empty'},
        ID => {:type => ::Thrift::Types::I64, :name => 'id'},
        IS_SCAN => {:type => ::Thrift::Types::BOOL, :name => 'is_scan'},
        IS_ERROR => {:type => ::Thrift::Types::BOOL, :name => 'is_error'},
        ERROR => {:type => ::Thrift::Types::I32, :name => 'error', :optional => true},
        ERROR_MSG => {:type => ::Thrift::Types::STRING, :name => 'error_msg', :optional => true},
        CELLS => {:type => ::Thrift::Types::LIST, :name => 'cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Hypertable::ThriftGen::Cell}, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field is_empty is unset!') if @is_empty.nil?
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field is_scan is unset!') if @is_scan.nil?
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field is_error is unset!') if @is_error.nil?
      end

      ::Thrift::Struct.generate_accessors self
    end

    # Specifies a result object for asynchronous requests.
# TODO: add support for update results
# 
# <dl>
#   <dt>is_empty</dt>
#   <dd>Indicates whether this object contains a result or not</dd>
# 
#   <dt>id</dt>
#   <dd>Scanner/mutator id for which these results pertain to</dd>
#   
#   <dt>is_scan</dt>
#   <dd>Indicates whether these are scan results or update results</dd>
#   
#   <dt>is_error</dt>
#   <dd>Indicates whether the async request was successful or not</dd>
#   
#   <dt>error</dt>
#   <dd>Error code</dd>
# 
#   <dt>error_msg</dt>
#   <dd>Error message</dd>
# 
#   <dt>cells</dt>
#   <dd>Cells returned by asynchronous scanner</dd>
# </dl>
    class ResultAsArrays
      include ::Thrift::Struct, ::Thrift::Struct_Union
      IS_EMPTY = 1
      ID = 2
      IS_SCAN = 3
      IS_ERROR = 4
      ERROR = 5
      ERROR_MSG = 6
      CELLS = 7

      FIELDS = {
        IS_EMPTY => {:type => ::Thrift::Types::BOOL, :name => 'is_empty'},
        ID => {:type => ::Thrift::Types::I64, :name => 'id'},
        IS_SCAN => {:type => ::Thrift::Types::BOOL, :name => 'is_scan'},
        IS_ERROR => {:type => ::Thrift::Types::BOOL, :name => 'is_error'},
        ERROR => {:type => ::Thrift::Types::I32, :name => 'error', :optional => true},
        ERROR_MSG => {:type => ::Thrift::Types::STRING, :name => 'error_msg', :optional => true},
        CELLS => {:type => ::Thrift::Types::LIST, :name => 'cells', :element => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::STRING}}, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field is_empty is unset!') if @is_empty.nil?
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field is_scan is unset!') if @is_scan.nil?
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field is_error is unset!') if @is_error.nil?
      end

      ::Thrift::Struct.generate_accessors self
    end

    # Specifies a serialized result object for asynchronous requests.
# TODO: add support for update results
# 
# <dl>
#   <dt>is_empty</dt>
#   <dd>Indicates whether this object contains a result or not</dd>
# 
#   <dt>id</dt>
#   <dd>Scanner/mutator id for which these results pertain to</dd>
#   
#   <dt>is_scan</dt>
#   <dd>Indicates whether these are scan results or update results</dd>
#   
#   <dt>is_error</dt>
#   <dd>Indicates whether the async request was successful or not</dd>
#   
#   <dt>error</dt>
#   <dd>Error code</dd>
# 
#   <dt>error_msg</dt>
#   <dd>Error message</dd>
# 
#   <dt>cells</dt>
#   <dd>Cells returned by asynchronous scanner</dd>
# </dl>
    class ResultSerialized
      include ::Thrift::Struct, ::Thrift::Struct_Union
      IS_EMPTY = 1
      ID = 2
      IS_SCAN = 3
      IS_ERROR = 4
      ERROR = 5
      ERROR_MSG = 6
      CELLS = 7

      FIELDS = {
        IS_EMPTY => {:type => ::Thrift::Types::BOOL, :name => 'is_empty'},
        ID => {:type => ::Thrift::Types::I64, :name => 'id'},
        IS_SCAN => {:type => ::Thrift::Types::BOOL, :name => 'is_scan'},
        IS_ERROR => {:type => ::Thrift::Types::BOOL, :name => 'is_error'},
        ERROR => {:type => ::Thrift::Types::I32, :name => 'error', :optional => true},
        ERROR_MSG => {:type => ::Thrift::Types::STRING, :name => 'error_msg', :optional => true},
        CELLS => {:type => ::Thrift::Types::STRING, :name => 'cells', :binary => true, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field is_empty is unset!') if @is_empty.nil?
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field is_scan is unset!') if @is_scan.nil?
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field is_error is unset!') if @is_error.nil?
      end

      ::Thrift::Struct.generate_accessors self
    end

    # Defines an individual namespace listing
# 
# <dl>
#   <dt>name</dt>
#   <dd>Name of the listing.</dd>
# 
#   <dt>is_namespace</dt>
#   <dd>true if this entry is a namespace.</dd>
# </dl>
    class NamespaceListing
      include ::Thrift::Struct, ::Thrift::Struct_Union
      NAME = 1
      IS_NAMESPACE = 2

      FIELDS = {
        NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
        IS_NAMESPACE => {:type => ::Thrift::Types::BOOL, :name => 'is_namespace'}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field name is unset!') unless @name
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field is_namespace is unset!') if @is_namespace.nil?
      end

      ::Thrift::Struct.generate_accessors self
    end

    # Defines a table split
# 
# <dl>
#   <dt>start_row</dt>
#   <dd>Starting row of the split.</dd>
# 
#   <dt>end_row</dt>
#   <dd>Ending row of the split.</dd>
# 
#   <dt>location</dt>
#   <dd>Location (proxy name) of the split.</dd>
# 
#   <dt>ip_address</dt>
#   <dd>The IP address of the split.</dd>
# 
#   <dt>hostname</dt>
#   <dd>The hostname of the split.</dd>
# </dl>
    class TableSplit
      include ::Thrift::Struct, ::Thrift::Struct_Union
      START_ROW = 1
      END_ROW = 2
      LOCATION = 3
      IP_ADDRESS = 4
      HOSTNAME = 5

      FIELDS = {
        START_ROW => {:type => ::Thrift::Types::STRING, :name => 'start_row', :binary => true, :optional => true},
        END_ROW => {:type => ::Thrift::Types::STRING, :name => 'end_row', :binary => true, :optional => true},
        LOCATION => {:type => ::Thrift::Types::STRING, :name => 'location', :optional => true},
        IP_ADDRESS => {:type => ::Thrift::Types::STRING, :name => 'ip_address', :optional => true},
        HOSTNAME => {:type => ::Thrift::Types::STRING, :name => 'hostname', :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ColumnFamilyOptions
      include ::Thrift::Struct, ::Thrift::Struct_Union
      MAX_VERSIONS = 1
      TTL = 2
      TIME_ORDER_DESC = 3
      COUNTER = 4

      FIELDS = {
        MAX_VERSIONS => {:type => ::Thrift::Types::I32, :name => 'max_versions', :optional => true},
        TTL => {:type => ::Thrift::Types::I32, :name => 'ttl', :optional => true},
        TIME_ORDER_DESC => {:type => ::Thrift::Types::BOOL, :name => 'time_order_desc', :optional => true},
        COUNTER => {:type => ::Thrift::Types::BOOL, :name => 'counter', :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    # Describes a ColumnFamily
# <dl>
#   <dt>name</dt>
#   <dd>Name of the column family</dd>
# 
#   <dt>ag</dt>
#   <dd>Name of the access group for this CF</dd>
# 
#   <dt>max_versions</dt>
#   <dd>Max versions of the same cell to be stored</dd>
# 
#   <dt>ttl</dt>
#   <dd>Time to live for cells in the CF (ie delete cells older than this time)</dd>
# </dl>
    class ColumnFamilySpec
      include ::Thrift::Struct, ::Thrift::Struct_Union
      NAME = 1
      ACCESS_GROUP = 2
      DELETED = 3
      GENERATION = 4
      ID = 5
      VALUE_INDEX = 6
      QUALIFIER_INDEX = 7
      OPTIONS = 8

      FIELDS = {
        NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
        ACCESS_GROUP => {:type => ::Thrift::Types::STRING, :name => 'access_group'},
        DELETED => {:type => ::Thrift::Types::BOOL, :name => 'deleted'},
        GENERATION => {:type => ::Thrift::Types::I64, :name => 'generation', :optional => true},
        ID => {:type => ::Thrift::Types::I32, :name => 'id', :optional => true},
        VALUE_INDEX => {:type => ::Thrift::Types::BOOL, :name => 'value_index'},
        QUALIFIER_INDEX => {:type => ::Thrift::Types::BOOL, :name => 'qualifier_index'},
        OPTIONS => {:type => ::Thrift::Types::STRUCT, :name => 'options', :class => ::Hypertable::ThriftGen::ColumnFamilyOptions, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class AccessGroupOptions
      include ::Thrift::Struct, ::Thrift::Struct_Union
      REPLICATION = 1
      BLOCKSIZE = 2
      COMPRESSOR = 3
      BLOOM_FILTER = 4
      IN_MEMORY = 5

      FIELDS = {
        REPLICATION => {:type => ::Thrift::Types::I16, :name => 'replication', :optional => true},
        BLOCKSIZE => {:type => ::Thrift::Types::I32, :name => 'blocksize', :optional => true},
        COMPRESSOR => {:type => ::Thrift::Types::STRING, :name => 'compressor', :optional => true},
        BLOOM_FILTER => {:type => ::Thrift::Types::STRING, :name => 'bloom_filter', :optional => true},
        IN_MEMORY => {:type => ::Thrift::Types::BOOL, :name => 'in_memory', :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    # Describes an AccessGroup
# <dl>
#   <dt>name</dt>
#   <dd>Name of the access group</dd>
# 
#   <dt>in_memory</dt>
#   <dd>Is this access group in memory</dd>
# 
#   <dt>replication</dt>
#   <dd>Replication factor for this AG</dd>
# 
#   <dt>blocksize</dt>
#   <dd>Specifies blocksize for this AG</dd>
# 
#   <dt>compressor</dt>
#   <dd>Specifies compressor for this AG</dd>
# 
#   <dt>bloom_filter</dt>
#   <dd>Specifies bloom filter type</dd>
# 
#   <dt>columns</dt>
#   <dd>Specifies list of column families in this AG</dd>
# </dl>
    class AccessGroupSpec
      include ::Thrift::Struct, ::Thrift::Struct_Union
      NAME = 1
      GENERATION = 2
      OPTIONS = 3
      DEFAULTS = 4

      FIELDS = {
        NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
        GENERATION => {:type => ::Thrift::Types::I64, :name => 'generation', :optional => true},
        OPTIONS => {:type => ::Thrift::Types::STRUCT, :name => 'options', :class => ::Hypertable::ThriftGen::AccessGroupOptions, :optional => true},
        DEFAULTS => {:type => ::Thrift::Types::STRUCT, :name => 'defaults', :class => ::Hypertable::ThriftGen::ColumnFamilyOptions, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    # Describes a schema.
# <dl>
#   <dt>access_groups</dt>
#   <dd>Map of access groups</dd>
# 
#   <dt>column_families</dt>
#   <dd>Map of column families</dd>
# </dl>
    class Schema
      include ::Thrift::Struct, ::Thrift::Struct_Union
      ACCESS_GROUPS = 1
      COLUMN_FAMILIES = 2
      GENERATION = 3
      VERSION = 4
      GROUP_COMMIT_INTERVAL = 5
      ACCESS_GROUP_DEFAULTS = 6
      COLUMN_FAMILY_DEFAULTS = 7

      FIELDS = {
        ACCESS_GROUPS => {:type => ::Thrift::Types::MAP, :name => 'access_groups', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Hypertable::ThriftGen::AccessGroupSpec}, :optional => true},
        COLUMN_FAMILIES => {:type => ::Thrift::Types::MAP, :name => 'column_families', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Hypertable::ThriftGen::ColumnFamilySpec}, :optional => true},
        GENERATION => {:type => ::Thrift::Types::I64, :name => 'generation', :optional => true},
        VERSION => {:type => ::Thrift::Types::I32, :name => 'version', :optional => true},
        GROUP_COMMIT_INTERVAL => {:type => ::Thrift::Types::I32, :name => 'group_commit_interval', :optional => true},
        ACCESS_GROUP_DEFAULTS => {:type => ::Thrift::Types::STRUCT, :name => 'access_group_defaults', :class => ::Hypertable::ThriftGen::AccessGroupOptions, :optional => true},
        COLUMN_FAMILY_DEFAULTS => {:type => ::Thrift::Types::STRUCT, :name => 'column_family_defaults', :class => ::Hypertable::ThriftGen::ColumnFamilyOptions, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    # Status information.
# 
# <dl>
#   <dt>code</dt>
#   <dd>Status code</dd>
# 
#   <dt>text</dt>
#   <dd>Status text</dd>
# </dl>
    class Status
      include ::Thrift::Struct, ::Thrift::Struct_Union
      CODE = 1
      TEXT = 2

      FIELDS = {
        CODE => {:type => ::Thrift::Types::I32, :name => 'code', :default => 0},
        TEXT => {:type => ::Thrift::Types::STRING, :name => 'text'}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field code is unset!') unless @code
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field text is unset!') unless @text
      end

      ::Thrift::Struct.generate_accessors self
    end

    # Exception for thrift clients.
# 
# <dl>
#   <dt>code</dt><dd>Internal use (defined in src/cc/Common/Error.h)</dd>
#   <dt>message</dt><dd>A message about the exception</dd>
# </dl>
# 
# Note: some languages (like php) don't have adequate namespace, so Exception
# would conflict with language builtins.
    class ClientException < ::Thrift::Exception
      include ::Thrift::Struct, ::Thrift::Struct_Union
      CODE = 1
      MESSAGE = 2

      FIELDS = {
        CODE => {:type => ::Thrift::Types::I32, :name => 'code'},
        MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

  end
end
