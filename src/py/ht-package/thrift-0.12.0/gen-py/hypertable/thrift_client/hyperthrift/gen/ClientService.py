#
# Autogenerated by Thrift Compiler (0.12.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:slots,no_utf8strings
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    """
    The client service mimics the C++ client API, with table, scanner and
    mutator interface flattened.

    """
    def namespace_create(self, ns):
        """
        Create a namespace

        @param ns - namespace name

        Parameters:
         - ns

        """
        pass

    def create_namespace(self, ns):
        """
        Parameters:
         - ns

        """
        pass

    def table_create(self, ns, table_name, schema):
        """
        Create a table

        @param ns - namespace id
        @param table_name - table name
        @param schema - schema of the table

        Parameters:
         - ns
         - table_name
         - schema

        """
        pass

    def table_alter(self, ns, table_name, schema):
        """
        Alter a table

        @param ns - namespace id
        @param table_name - table name
        @param schema - schema of the table

        Parameters:
         - ns
         - table_name
         - schema

        """
        pass

    def refresh_table(self, ns, table_name):
        """
        Refreshes the cached table information

        @param ns - namespace
        @param table_name - name of the table

        Parameters:
         - ns
         - table_name

        """
        pass

    def namespace_open(self, ns):
        """
        Open a namespace

        @param ns - namespace
        @return value is guaranteed to be non-zero and unique

        Parameters:
         - ns

        """
        pass

    def open_namespace(self, ns):
        """
        Parameters:
         - ns

        """
        pass

    def namespace_close(self, ns):
        """
        Close a namespace

        @param ns - namespace

        Parameters:
         - ns

        """
        pass

    def close_namespace(self, ns):
        """
        Parameters:
         - ns

        """
        pass

    def future_open(self, capacity):
        """
        Open a future object
        @param capacity - Amount of result data the future object can enqueue without blocking threads

        Parameters:
         - capacity

        """
        pass

    def open_future(self, capacity):
        """
        Parameters:
         - capacity

        """
        pass

    def future_cancel(self, ff):
        """
        Cancel tasks outstanding in a future object
        @param ff - Future object

        Parameters:
         - ff

        """
        pass

    def cancel_future(self, ff):
        """
        Parameters:
         - ff

        """
        pass

    def future_get_result(self, ff, timeout_millis):
        """
        Fetch asynchronous results
        @param ff - Future object which has the asynchronous results
        @return - result from async scanner/mutator

        Parameters:
         - ff
         - timeout_millis

        """
        pass

    def get_future_result(self, ff, timeout_millis):
        """
        Parameters:
         - ff
         - timeout_millis

        """
        pass

    def future_get_result_as_arrays(self, ff, timeout_millis):
        """
        Fetch asynchronous results
        @param ff - Future object which has the asynchronous results
        @return - result from async scanner/mutator

        Parameters:
         - ff
         - timeout_millis

        """
        pass

    def get_future_result_as_arrays(self, ff, timeout_millis):
        """
        Parameters:
         - ff
         - timeout_millis

        """
        pass

    def future_get_result_serialized(self, ff, timeout_millis):
        """
        Fetch asynchronous results
        @param ff - Future object which has the asynchronous results
        @return - result from async scanner/mutator

        Parameters:
         - ff
         - timeout_millis

        """
        pass

    def get_future_result_serialized(self, ff, timeout_millis):
        """
        Parameters:
         - ff
         - timeout_millis

        """
        pass

    def future_is_empty(self, ff):
        """
        Check if future object's queue is empty

        Parameters:
         - ff

        """
        pass

    def future_is_full(self, ff):
        """
        Check if future object's queue is full

        Parameters:
         - ff

        """
        pass

    def future_is_cancelled(self, ff):
        """
        Check if future object has been cancelled

        Parameters:
         - ff

        """
        pass

    def future_has_outstanding(self, ff):
        """
        Check if future object has outstanding operations

        Parameters:
         - ff

        """
        pass

    def future_close(self, ff):
        """
        Close a future object
        @param ff - the future object to be closed

        Parameters:
         - ff

        """
        pass

    def close_future(self, ff):
        """
        Parameters:
         - ff

        """
        pass

    def scanner_open(self, ns, table_name, scan_spec):
        """
        Open a table scanner
        @param ns - namespace id
        @param table_name - table name
        @param scan_spec - scan specification

        Parameters:
         - ns
         - table_name
         - scan_spec

        """
        pass

    def open_scanner(self, ns, table_name, scan_spec):
        """
        Parameters:
         - ns
         - table_name
         - scan_spec

        """
        pass

    def async_scanner_open(self, ns, table_name, future, scan_spec):
        """
        Open an asynchronous table scanner
        @param ns - namespace id
        @param table_name - table name
        @param future - callback object
        @param scan_spec - scan specification

        Parameters:
         - ns
         - table_name
         - future
         - scan_spec

        """
        pass

    def open_scanner_async(self, ns, table_name, future, scan_spec):
        """
        Parameters:
         - ns
         - table_name
         - future
         - scan_spec

        """
        pass

    def scanner_close(self, scanner):
        """
        Close a table scanner

        @param scanner - scanner id to close

        Parameters:
         - scanner

        """
        pass

    def close_scanner(self, scanner):
        """
        Parameters:
         - scanner

        """
        pass

    def async_scanner_cancel(self, scanner):
        """
        Cancel a table scanner

        @param scanner - scanner id to close

        Parameters:
         - scanner

        """
        pass

    def cancel_scanner_async(self, scanner):
        """
        Parameters:
         - scanner

        """
        pass

    def async_scanner_close(self, scanner):
        """
        Close a table scanner

        @param scanner - scanner id to close

        Parameters:
         - scanner

        """
        pass

    def close_scanner_async(self, scanner):
        """
        Parameters:
         - scanner

        """
        pass

    def scanner_get_cells(self, scanner):
        """
        Iterate over cells of a scanner

        @param scanner - scanner id

        Parameters:
         - scanner

        """
        pass

    def next_cells(self, scanner):
        """
        Parameters:
         - scanner

        """
        pass

    def scanner_get_cells_as_arrays(self, scanner):
        """
        Parameters:
         - scanner

        """
        pass

    def next_cells_as_arrays(self, scanner):
        """
        Parameters:
         - scanner

        """
        pass

    def scanner_get_cells_serialized(self, scanner):
        """
        Alternative interface returning buffer of serialized cells

        Parameters:
         - scanner

        """
        pass

    def next_cells_serialized(self, scanner):
        """
        Parameters:
         - scanner

        """
        pass

    def scanner_get_row(self, scanner):
        """
        Iterate over rows of a scanner

        @param scanner - scanner id

        Parameters:
         - scanner

        """
        pass

    def next_row(self, scanner):
        """
        Parameters:
         - scanner

        """
        pass

    def scanner_get_row_as_arrays(self, scanner):
        """
        Alternative interface using array as cell

        Parameters:
         - scanner

        """
        pass

    def next_row_as_arrays(self, scanner):
        """
        Parameters:
         - scanner

        """
        pass

    def scanner_get_row_serialized(self, scanner):
        """
        Alternate interface returning a buffer of serialized cells for iterating by row
        for a given scanner

        @param scanner - scanner id

        Parameters:
         - scanner

        """
        pass

    def next_row_serialized(self, scanner):
        """
        Parameters:
         - scanner

        """
        pass

    def get_row(self, ns, table_name, row):
        """
        Get a row (convenience method for random access a row)

        @param ns - namespace id

        @param table_name - table name

        @param row - row key

        @return a list of cells (with row_keys unset)

        Parameters:
         - ns
         - table_name
         - row

        """
        pass

    def get_row_as_arrays(self, ns, name, row):
        """
        Alternative interface using array as cell

        Parameters:
         - ns
         - name
         - row

        """
        pass

    def get_row_serialized(self, ns, table_name, row):
        """
        Alternative interface returning buffer of serialized cells

        Parameters:
         - ns
         - table_name
         - row

        """
        pass

    def get_cell(self, ns, table_name, row, column):
        """
        Get a cell (convenience method for random access a cell)

        @param ns - namespace id

        @param table_name - table name

        @param row - row key

        @param column - column name

        @return value (byte sequence)

        Parameters:
         - ns
         - table_name
         - row
         - column

        """
        pass

    def get_cells(self, ns, table_name, scan_spec):
        """
        Get cells (convenience method for access small amount of cells)

        @param ns - namespace id
         
        @param table_name - table name

        @param scan_spec - scan specification

        @return a list of cells (a cell with no row key set is assumed to have
                the same row key as the previous cell)

        Parameters:
         - ns
         - table_name
         - scan_spec

        """
        pass

    def get_cells_as_arrays(self, ns, name, scan_spec):
        """
        Alternative interface using array as cell

        Parameters:
         - ns
         - name
         - scan_spec

        """
        pass

    def get_cells_serialized(self, ns, name, scan_spec):
        """
        Alternative interface returning buffer of serialized cells

        Parameters:
         - ns
         - name
         - scan_spec

        """
        pass

    def shared_mutator_refresh(self, ns, table_name, mutate_spec):
        """
        Create a shared mutator with specified MutateSpec.
        Delete and recreate it if the mutator exists.

        @param ns - namespace id
         
        @param table_name - table name

        @param mutate_spec - mutator specification


        Parameters:
         - ns
         - table_name
         - mutate_spec

        """
        pass

    def refresh_shared_mutator(self, ns, table_name, mutate_spec):
        """
        Parameters:
         - ns
         - table_name
         - mutate_spec

        """
        pass

    def shared_mutator_set_cells(self, ns, table_name, mutate_spec, cells):
        """
        Open a shared periodic mutator which causes cells to be written asyncronously.
        Users beware: calling this method merely writes
        cells to a local buffer and does not guarantee that the cells have been persisted.
        If you want guaranteed durability, use the open_mutator+set_cells* interface instead.

        @param ns - namespace id

        @param table_name - table name

        @param mutate_spec - mutator specification

        @param cells - set of cells to be written

        Parameters:
         - ns
         - table_name
         - mutate_spec
         - cells

        """
        pass

    def offer_cells(self, ns, table_name, mutate_spec, cells):
        """
        Parameters:
         - ns
         - table_name
         - mutate_spec
         - cells

        """
        pass

    def shared_mutator_set_cells_as_arrays(self, ns, table_name, mutate_spec, cells):
        """
        Alternative to offer_cell interface using array as cell

        Parameters:
         - ns
         - table_name
         - mutate_spec
         - cells

        """
        pass

    def offer_cells_as_arrays(self, ns, table_name, mutate_spec, cells):
        """
        Parameters:
         - ns
         - table_name
         - mutate_spec
         - cells

        """
        pass

    def shared_mutator_set_cell(self, ns, table_name, mutate_spec, cell):
        """
        Open a shared periodic mutator which causes cells to be written asyncronously.
        Users beware: calling this method merely writes
        cells to a local buffer and does not guarantee that the cells have been persisted.
        If you want guaranteed durability, use the open_mutator+set_cells* interface instead.

        @param ns - namespace id

        @param table_name - table name

        @param mutate_spec - mutator specification

        @param cell - cell to be written

        Parameters:
         - ns
         - table_name
         - mutate_spec
         - cell

        """
        pass

    def offer_cell(self, ns, table_name, mutate_spec, cell):
        """
        Parameters:
         - ns
         - table_name
         - mutate_spec
         - cell

        """
        pass

    def shared_mutator_set_cell_as_array(self, ns, table_name, mutate_spec, cell):
        """
        Alternative to offer_cell interface using array as cell

        Parameters:
         - ns
         - table_name
         - mutate_spec
         - cell

        """
        pass

    def offer_cell_as_array(self, ns, table_name, mutate_spec, cell):
        """
        Parameters:
         - ns
         - table_name
         - mutate_spec
         - cell

        """
        pass

    def mutator_open(self, ns, table_name, flags, flush_interval):
        """
        Open a table mutator

        @param ns - namespace id

        @param table_name - table name

        @param flags - mutator flags

        @param flush_interval - auto-flush interval in milliseconds; 0 disables it.

        @return mutator id

        Parameters:
         - ns
         - table_name
         - flags
         - flush_interval

        """
        pass

    def open_mutator(self, ns, table_name, flags, flush_interval):
        """
        Parameters:
         - ns
         - table_name
         - flags
         - flush_interval

        """
        pass

    def async_mutator_open(self, ns, table_name, future, flags):
        """
        Open an asynchronous table mutator

        @param ns - namespace id
        @param table_name - table name
        @param future - callback object
        @param flags - mutator flags

        @return mutator id

        Parameters:
         - ns
         - table_name
         - future
         - flags

        """
        pass

    def open_mutator_async(self, ns, table_name, future, flags):
        """
        Parameters:
         - ns
         - table_name
         - future
         - flags

        """
        pass

    def mutator_close(self, mutator):
        """
        Close a table mutator

        @param mutator - mutator id to close

        Parameters:
         - mutator

        """
        pass

    def close_mutator(self, mutator):
        """
        Parameters:
         - mutator

        """
        pass

    def async_mutator_cancel(self, mutator):
        """
        Cancel an asynchronous table mutator

        @param mutator -  mutator id to cancel

        Parameters:
         - mutator

        """
        pass

    def cancel_mutator_async(self, mutator):
        """
        Parameters:
         - mutator

        """
        pass

    def async_mutator_close(self, mutator):
        """
        Close an asynchronous table mutator

        @param mutator - mutator id to close

        Parameters:
         - mutator

        """
        pass

    def close_mutator_async(self, mutator):
        """
        Parameters:
         - mutator

        """
        pass

    def mutator_set_cell(self, mutator, cell):
        """
        Set a cell via mutator

        @param mutator - mutator id

        @param cell - the cell to set

        Parameters:
         - mutator
         - cell

        """
        pass

    def set_cell(self, ns, table_name, cell):
        """
        Set a cell in the table

        @param ns - namespace id

        @param table_name - table name

        @param cell - the cell to set

        Parameters:
         - ns
         - table_name
         - cell

        """
        pass

    def mutator_set_cell_as_array(self, mutator, cell):
        """
        Alternative interface using array as cell

        Parameters:
         - mutator
         - cell

        """
        pass

    def set_cell_as_array(self, ns, table_name, cell):
        """
        Alternative interface using array as cell

        Parameters:
         - ns
         - table_name
         - cell

        """
        pass

    def mutator_set_cells(self, mutator, cells):
        """
        Put a list of cells into a table via mutator

        @param mutator - mutator id

        @param cells - a list of cells (a cell with no row key set is assumed
               to have the same row key as the previous cell)

        Parameters:
         - mutator
         - cells

        """
        pass

    def set_cells(self, ns, table_name, cells):
        """
        Put a list of cells into a table

        @param ns - namespace id

        @param table_name - table name

        @param cells - a list of cells (a cell with no row key set is assumed
               to have the same row key as the previous cell)

        Parameters:
         - ns
         - table_name
         - cells

        """
        pass

    def mutator_set_cells_as_arrays(self, mutator, cells):
        """
        Alternative interface using array as cell

        Parameters:
         - mutator
         - cells

        """
        pass

    def set_cells_as_arrays(self, ns, table_name, cells):
        """
        Alternative interface using array as cell

        Parameters:
         - ns
         - table_name
         - cells

        """
        pass

    def mutator_set_cells_serialized(self, mutator, cells, flush):
        """
        Alternative interface using buffer of serialized cells

        Parameters:
         - mutator
         - cells
         - flush

        """
        pass

    def set_cells_serialized(self, ns, table_name, cells):
        """
        Alternative interface using buffer of serialized cells

        Parameters:
         - ns
         - table_name
         - cells

        """
        pass

    def mutator_flush(self, mutator):
        """
        Flush mutator buffers

        Parameters:
         - mutator

        """
        pass

    def flush_mutator(self, mutator):
        """
        Parameters:
         - mutator

        """
        pass

    def async_mutator_set_cell(self, mutator, cell):
        """
        Set a cell in the table using an asynchonous mutator

        @param mutator - mutator id

        @param cell - the cell to set

        Parameters:
         - mutator
         - cell

        """
        pass

    def set_cell_async(self, mutator, cell):
        """
        Parameters:
         - mutator
         - cell

        """
        pass

    def async_mutator_set_cell_as_array(self, mutator, cell):
        """
        Alternative interface using array as cell using an asynchonous mutator

        Parameters:
         - mutator
         - cell

        """
        pass

    def set_cell_as_array_async(self, mutator, cell):
        """
        Parameters:
         - mutator
         - cell

        """
        pass

    def async_mutator_set_cells(self, mutator, cells):
        """
        Put a list of cells into a table using asynchonous mutator

        @param mutator - mutator id

        @param cells - a list of cells (a cell with no row key set is assumed
               to have the same row key as the previous cell)

        Parameters:
         - mutator
         - cells

        """
        pass

    def set_cells_async(self, mutator, cells):
        """
        Parameters:
         - mutator
         - cells

        """
        pass

    def async_mutator_set_cells_as_arrays(self, mutator, cells):
        """
        Alternative interface using array as cell

        Parameters:
         - mutator
         - cells

        """
        pass

    def set_cells_as_arrays_async(self, mutator, cells):
        """
        Parameters:
         - mutator
         - cells

        """
        pass

    def async_mutator_set_cells_serialized(self, mutator, cells, flush):
        """
        Alternative interface using buffer of serialized cells

        Parameters:
         - mutator
         - cells
         - flush

        """
        pass

    def set_cells_serialized_async(self, mutator, cells, flush):
        """
        Parameters:
         - mutator
         - cells
         - flush

        """
        pass

    def async_mutator_flush(self, mutator):
        """
        Flush mutator buffers

        Parameters:
         - mutator

        """
        pass

    def flush_mutator_async(self, mutator):
        """
        Parameters:
         - mutator

        """
        pass

    def namespace_exists(self, ns):
        """
        Check if the namespace exists

        @param ns - namespace name

        @return true if ns exists, false ow

        Parameters:
         - ns

        """
        pass

    def exists_namespace(self, ns):
        """
        Parameters:
         - ns

        """
        pass

    def exists_table(self, ns, name):
        """
        Check if the table exists

        @param ns - namespace id

        @param name - table name

        @return true if table exists, false ow

        Parameters:
         - ns
         - name

        """
        pass

    def table_exists(self, ns, name):
        """
        Parameters:
         - ns
         - name

        """
        pass

    def table_get_id(self, ns, table_name):
        """
        Get the id of a table

        @param ns - namespace id

        @param table_name - table name

        @return table id string

        Parameters:
         - ns
         - table_name

        """
        pass

    def get_table_id(self, ns, table_name):
        """
        Parameters:
         - ns
         - table_name

        """
        pass

    def table_get_schema_str(self, ns, table_name):
        """
        Get the schema of a table as a string (that can be used with create_table)

        @param ns - namespace id

        @param table_name - table name

        @return schema string (in xml)

        Parameters:
         - ns
         - table_name

        """
        pass

    def get_schema_str(self, ns, table_name):
        """
        Parameters:
         - ns
         - table_name

        """
        pass

    def table_get_schema_str_with_ids(self, ns, table_name):
        """
        Get the schema of a table as a string along with column family ids

        @param ns - namespace id

        @param table_name - table name

        @return schema string (in xml)

        Parameters:
         - ns
         - table_name

        """
        pass

    def get_schema_str_with_ids(self, ns, table_name):
        """
        Parameters:
         - ns
         - table_name

        """
        pass

    def table_get_schema(self, ns, table_name):
        """
        Get the schema of a table as a string (that can be used with create_table)
          
        @param ns - namespace id

        @param table_name - table name

        @return schema object describing a table

        Parameters:
         - ns
         - table_name

        """
        pass

    def get_schema(self, ns, table_name):
        """
        Parameters:
         - ns
         - table_name

        """
        pass

    def get_tables(self, ns):
        """
        Get a list of table names in the namespace

        @param ns - namespace id

        @return a list of table names

        Parameters:
         - ns

        """
        pass

    def namespace_get_listing(self, ns):
        """
        Get a list of namespaces and table names table names in the namespace

        @param ns - namespace

        @return a list of table names

        Parameters:
         - ns

        """
        pass

    def get_listing(self, ns):
        """
        Parameters:
         - ns

        """
        pass

    def table_get_splits(self, ns, table_name):
        """
        Get a list of table splits

        @param ns - namespace id

        @param table_name - table name

        @return a list of table names

        Parameters:
         - ns
         - table_name

        """
        pass

    def get_table_splits(self, ns, table_name):
        """
        Parameters:
         - ns
         - table_name

        """
        pass

    def namespace_drop(self, ns, if_exists):
        """
        Drop a namespace

        @param ns - namespace name

        @param if_exists - if true, don't barf if the table doesn't exist

        Parameters:
         - ns
         - if_exists

        """
        pass

    def drop_namespace(self, ns, if_exists):
        """
        Parameters:
         - ns
         - if_exists

        """
        pass

    def rename_table(self, ns, name, new_name):
        """
        Rename a table

        @param ns - namespace id

        @param name - current table name

        @param new_name - new table name

        Parameters:
         - ns
         - name
         - new_name

        """
        pass

    def table_rename(self, ns, name, new_name):
        """
        Parameters:
         - ns
         - name
         - new_name

        """
        pass

    def drop_table(self, ns, name, if_exists):
        """
        Drop a table

        @param ns - namespace id

        @param name - table name

        @param if_exists - if true, don't barf if the table doesn't exist

        Parameters:
         - ns
         - name
         - if_exists

        """
        pass

    def table_drop(self, ns, name, if_exists):
        """
        Parameters:
         - ns
         - name
         - if_exists

        """
        pass

    def generate_guid(self):
        """
        Generate a GUID

        GUIDs are globally unique. The generated string is 36 bytes long and
        has a format similar to "9cf7da31-307a-4bef-b65e-19fb05aa57d8".

        """
        pass

    def create_cell_unique(self, ns, table_name, key, value):
        """
        Inserts a unique value into a table

        This function inserts a unique value into a table. The table must be
        created with TIME_ORDER DESC, MAX_VERSIONS 1 (although the latter is
        optional).

        If the value is empty then a new GUID will be assigned
        (using @a generate_guid).

        @param ns - namespace id
        @param table_name - table name
        @param key - the Key of the value
        @param value - the unique value. Can be empty; in this case a new
           guid will be generated internally

        @return the inserted unique value (which is identical to the @a value
           parameter or a new guid, if value is empty)

        Parameters:
         - ns
         - table_name
         - key
         - value

        """
        pass

    def error_get_text(self, error_code):
        """
        Retrieves a descriptive error string from an error code

        @param error_code - the numeric error code

        @return the descriptive string, or "ERROR NOT REGISTERED" if the error
           code is unknown

        Parameters:
         - error_code

        """
        pass

    def status(self):
        """
        Status check.
        @return Status information

        """
        pass

    def shutdown(self):
        """
        Shutdown broker.

        """
        pass


class Client(Iface):
    """
    The client service mimics the C++ client API, with table, scanner and
    mutator interface flattened.

    """
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def namespace_create(self, ns):
        """
        Create a namespace

        @param ns - namespace name

        Parameters:
         - ns

        """
        self.send_namespace_create(ns)
        self.recv_namespace_create()

    def send_namespace_create(self, ns):
        self._oprot.writeMessageBegin('namespace_create', TMessageType.CALL, self._seqid)
        args = namespace_create_args()
        args.ns = ns
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_namespace_create(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = namespace_create_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def create_namespace(self, ns):
        """
        Parameters:
         - ns

        """
        self.send_create_namespace(ns)
        self.recv_create_namespace()

    def send_create_namespace(self, ns):
        self._oprot.writeMessageBegin('create_namespace', TMessageType.CALL, self._seqid)
        args = create_namespace_args()
        args.ns = ns
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_namespace(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_namespace_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def table_create(self, ns, table_name, schema):
        """
        Create a table

        @param ns - namespace id
        @param table_name - table name
        @param schema - schema of the table

        Parameters:
         - ns
         - table_name
         - schema

        """
        self.send_table_create(ns, table_name, schema)
        self.recv_table_create()

    def send_table_create(self, ns, table_name, schema):
        self._oprot.writeMessageBegin('table_create', TMessageType.CALL, self._seqid)
        args = table_create_args()
        args.ns = ns
        args.table_name = table_name
        args.schema = schema
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_table_create(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = table_create_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def table_alter(self, ns, table_name, schema):
        """
        Alter a table

        @param ns - namespace id
        @param table_name - table name
        @param schema - schema of the table

        Parameters:
         - ns
         - table_name
         - schema

        """
        self.send_table_alter(ns, table_name, schema)
        self.recv_table_alter()

    def send_table_alter(self, ns, table_name, schema):
        self._oprot.writeMessageBegin('table_alter', TMessageType.CALL, self._seqid)
        args = table_alter_args()
        args.ns = ns
        args.table_name = table_name
        args.schema = schema
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_table_alter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = table_alter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def refresh_table(self, ns, table_name):
        """
        Refreshes the cached table information

        @param ns - namespace
        @param table_name - name of the table

        Parameters:
         - ns
         - table_name

        """
        self.send_refresh_table(ns, table_name)
        self.recv_refresh_table()

    def send_refresh_table(self, ns, table_name):
        self._oprot.writeMessageBegin('refresh_table', TMessageType.CALL, self._seqid)
        args = refresh_table_args()
        args.ns = ns
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_refresh_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = refresh_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def namespace_open(self, ns):
        """
        Open a namespace

        @param ns - namespace
        @return value is guaranteed to be non-zero and unique

        Parameters:
         - ns

        """
        self.send_namespace_open(ns)
        return self.recv_namespace_open()

    def send_namespace_open(self, ns):
        self._oprot.writeMessageBegin('namespace_open', TMessageType.CALL, self._seqid)
        args = namespace_open_args()
        args.ns = ns
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_namespace_open(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = namespace_open_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "namespace_open failed: unknown result")

    def open_namespace(self, ns):
        """
        Parameters:
         - ns

        """
        self.send_open_namespace(ns)
        return self.recv_open_namespace()

    def send_open_namespace(self, ns):
        self._oprot.writeMessageBegin('open_namespace', TMessageType.CALL, self._seqid)
        args = open_namespace_args()
        args.ns = ns
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_open_namespace(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = open_namespace_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "open_namespace failed: unknown result")

    def namespace_close(self, ns):
        """
        Close a namespace

        @param ns - namespace

        Parameters:
         - ns

        """
        self.send_namespace_close(ns)
        self.recv_namespace_close()

    def send_namespace_close(self, ns):
        self._oprot.writeMessageBegin('namespace_close', TMessageType.CALL, self._seqid)
        args = namespace_close_args()
        args.ns = ns
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_namespace_close(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = namespace_close_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def close_namespace(self, ns):
        """
        Parameters:
         - ns

        """
        self.send_close_namespace(ns)
        self.recv_close_namespace()

    def send_close_namespace(self, ns):
        self._oprot.writeMessageBegin('close_namespace', TMessageType.CALL, self._seqid)
        args = close_namespace_args()
        args.ns = ns
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_close_namespace(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = close_namespace_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def future_open(self, capacity):
        """
        Open a future object
        @param capacity - Amount of result data the future object can enqueue without blocking threads

        Parameters:
         - capacity

        """
        self.send_future_open(capacity)
        return self.recv_future_open()

    def send_future_open(self, capacity):
        self._oprot.writeMessageBegin('future_open', TMessageType.CALL, self._seqid)
        args = future_open_args()
        args.capacity = capacity
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_future_open(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = future_open_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "future_open failed: unknown result")

    def open_future(self, capacity):
        """
        Parameters:
         - capacity

        """
        self.send_open_future(capacity)
        return self.recv_open_future()

    def send_open_future(self, capacity):
        self._oprot.writeMessageBegin('open_future', TMessageType.CALL, self._seqid)
        args = open_future_args()
        args.capacity = capacity
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_open_future(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = open_future_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "open_future failed: unknown result")

    def future_cancel(self, ff):
        """
        Cancel tasks outstanding in a future object
        @param ff - Future object

        Parameters:
         - ff

        """
        self.send_future_cancel(ff)
        self.recv_future_cancel()

    def send_future_cancel(self, ff):
        self._oprot.writeMessageBegin('future_cancel', TMessageType.CALL, self._seqid)
        args = future_cancel_args()
        args.ff = ff
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_future_cancel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = future_cancel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def cancel_future(self, ff):
        """
        Parameters:
         - ff

        """
        self.send_cancel_future(ff)
        self.recv_cancel_future()

    def send_cancel_future(self, ff):
        self._oprot.writeMessageBegin('cancel_future', TMessageType.CALL, self._seqid)
        args = cancel_future_args()
        args.ff = ff
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cancel_future(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cancel_future_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def future_get_result(self, ff, timeout_millis):
        """
        Fetch asynchronous results
        @param ff - Future object which has the asynchronous results
        @return - result from async scanner/mutator

        Parameters:
         - ff
         - timeout_millis

        """
        self.send_future_get_result(ff, timeout_millis)
        return self.recv_future_get_result()

    def send_future_get_result(self, ff, timeout_millis):
        self._oprot.writeMessageBegin('future_get_result', TMessageType.CALL, self._seqid)
        args = future_get_result_args()
        args.ff = ff
        args.timeout_millis = timeout_millis
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_future_get_result(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = future_get_result_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "future_get_result failed: unknown result")

    def get_future_result(self, ff, timeout_millis):
        """
        Parameters:
         - ff
         - timeout_millis

        """
        self.send_get_future_result(ff, timeout_millis)
        return self.recv_get_future_result()

    def send_get_future_result(self, ff, timeout_millis):
        self._oprot.writeMessageBegin('get_future_result', TMessageType.CALL, self._seqid)
        args = get_future_result_args()
        args.ff = ff
        args.timeout_millis = timeout_millis
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_future_result(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_future_result_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_future_result failed: unknown result")

    def future_get_result_as_arrays(self, ff, timeout_millis):
        """
        Fetch asynchronous results
        @param ff - Future object which has the asynchronous results
        @return - result from async scanner/mutator

        Parameters:
         - ff
         - timeout_millis

        """
        self.send_future_get_result_as_arrays(ff, timeout_millis)
        return self.recv_future_get_result_as_arrays()

    def send_future_get_result_as_arrays(self, ff, timeout_millis):
        self._oprot.writeMessageBegin('future_get_result_as_arrays', TMessageType.CALL, self._seqid)
        args = future_get_result_as_arrays_args()
        args.ff = ff
        args.timeout_millis = timeout_millis
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_future_get_result_as_arrays(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = future_get_result_as_arrays_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "future_get_result_as_arrays failed: unknown result")

    def get_future_result_as_arrays(self, ff, timeout_millis):
        """
        Parameters:
         - ff
         - timeout_millis

        """
        self.send_get_future_result_as_arrays(ff, timeout_millis)
        return self.recv_get_future_result_as_arrays()

    def send_get_future_result_as_arrays(self, ff, timeout_millis):
        self._oprot.writeMessageBegin('get_future_result_as_arrays', TMessageType.CALL, self._seqid)
        args = get_future_result_as_arrays_args()
        args.ff = ff
        args.timeout_millis = timeout_millis
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_future_result_as_arrays(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_future_result_as_arrays_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_future_result_as_arrays failed: unknown result")

    def future_get_result_serialized(self, ff, timeout_millis):
        """
        Fetch asynchronous results
        @param ff - Future object which has the asynchronous results
        @return - result from async scanner/mutator

        Parameters:
         - ff
         - timeout_millis

        """
        self.send_future_get_result_serialized(ff, timeout_millis)
        return self.recv_future_get_result_serialized()

    def send_future_get_result_serialized(self, ff, timeout_millis):
        self._oprot.writeMessageBegin('future_get_result_serialized', TMessageType.CALL, self._seqid)
        args = future_get_result_serialized_args()
        args.ff = ff
        args.timeout_millis = timeout_millis
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_future_get_result_serialized(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = future_get_result_serialized_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "future_get_result_serialized failed: unknown result")

    def get_future_result_serialized(self, ff, timeout_millis):
        """
        Parameters:
         - ff
         - timeout_millis

        """
        self.send_get_future_result_serialized(ff, timeout_millis)
        return self.recv_get_future_result_serialized()

    def send_get_future_result_serialized(self, ff, timeout_millis):
        self._oprot.writeMessageBegin('get_future_result_serialized', TMessageType.CALL, self._seqid)
        args = get_future_result_serialized_args()
        args.ff = ff
        args.timeout_millis = timeout_millis
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_future_result_serialized(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_future_result_serialized_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_future_result_serialized failed: unknown result")

    def future_is_empty(self, ff):
        """
        Check if future object's queue is empty

        Parameters:
         - ff

        """
        self.send_future_is_empty(ff)
        return self.recv_future_is_empty()

    def send_future_is_empty(self, ff):
        self._oprot.writeMessageBegin('future_is_empty', TMessageType.CALL, self._seqid)
        args = future_is_empty_args()
        args.ff = ff
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_future_is_empty(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = future_is_empty_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "future_is_empty failed: unknown result")

    def future_is_full(self, ff):
        """
        Check if future object's queue is full

        Parameters:
         - ff

        """
        self.send_future_is_full(ff)
        return self.recv_future_is_full()

    def send_future_is_full(self, ff):
        self._oprot.writeMessageBegin('future_is_full', TMessageType.CALL, self._seqid)
        args = future_is_full_args()
        args.ff = ff
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_future_is_full(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = future_is_full_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "future_is_full failed: unknown result")

    def future_is_cancelled(self, ff):
        """
        Check if future object has been cancelled

        Parameters:
         - ff

        """
        self.send_future_is_cancelled(ff)
        return self.recv_future_is_cancelled()

    def send_future_is_cancelled(self, ff):
        self._oprot.writeMessageBegin('future_is_cancelled', TMessageType.CALL, self._seqid)
        args = future_is_cancelled_args()
        args.ff = ff
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_future_is_cancelled(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = future_is_cancelled_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "future_is_cancelled failed: unknown result")

    def future_has_outstanding(self, ff):
        """
        Check if future object has outstanding operations

        Parameters:
         - ff

        """
        self.send_future_has_outstanding(ff)
        return self.recv_future_has_outstanding()

    def send_future_has_outstanding(self, ff):
        self._oprot.writeMessageBegin('future_has_outstanding', TMessageType.CALL, self._seqid)
        args = future_has_outstanding_args()
        args.ff = ff
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_future_has_outstanding(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = future_has_outstanding_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "future_has_outstanding failed: unknown result")

    def future_close(self, ff):
        """
        Close a future object
        @param ff - the future object to be closed

        Parameters:
         - ff

        """
        self.send_future_close(ff)
        self.recv_future_close()

    def send_future_close(self, ff):
        self._oprot.writeMessageBegin('future_close', TMessageType.CALL, self._seqid)
        args = future_close_args()
        args.ff = ff
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_future_close(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = future_close_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def close_future(self, ff):
        """
        Parameters:
         - ff

        """
        self.send_close_future(ff)
        self.recv_close_future()

    def send_close_future(self, ff):
        self._oprot.writeMessageBegin('close_future', TMessageType.CALL, self._seqid)
        args = close_future_args()
        args.ff = ff
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_close_future(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = close_future_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def scanner_open(self, ns, table_name, scan_spec):
        """
        Open a table scanner
        @param ns - namespace id
        @param table_name - table name
        @param scan_spec - scan specification

        Parameters:
         - ns
         - table_name
         - scan_spec

        """
        self.send_scanner_open(ns, table_name, scan_spec)
        return self.recv_scanner_open()

    def send_scanner_open(self, ns, table_name, scan_spec):
        self._oprot.writeMessageBegin('scanner_open', TMessageType.CALL, self._seqid)
        args = scanner_open_args()
        args.ns = ns
        args.table_name = table_name
        args.scan_spec = scan_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_scanner_open(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = scanner_open_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "scanner_open failed: unknown result")

    def open_scanner(self, ns, table_name, scan_spec):
        """
        Parameters:
         - ns
         - table_name
         - scan_spec

        """
        self.send_open_scanner(ns, table_name, scan_spec)
        return self.recv_open_scanner()

    def send_open_scanner(self, ns, table_name, scan_spec):
        self._oprot.writeMessageBegin('open_scanner', TMessageType.CALL, self._seqid)
        args = open_scanner_args()
        args.ns = ns
        args.table_name = table_name
        args.scan_spec = scan_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_open_scanner(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = open_scanner_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "open_scanner failed: unknown result")

    def async_scanner_open(self, ns, table_name, future, scan_spec):
        """
        Open an asynchronous table scanner
        @param ns - namespace id
        @param table_name - table name
        @param future - callback object
        @param scan_spec - scan specification

        Parameters:
         - ns
         - table_name
         - future
         - scan_spec

        """
        self.send_async_scanner_open(ns, table_name, future, scan_spec)
        return self.recv_async_scanner_open()

    def send_async_scanner_open(self, ns, table_name, future, scan_spec):
        self._oprot.writeMessageBegin('async_scanner_open', TMessageType.CALL, self._seqid)
        args = async_scanner_open_args()
        args.ns = ns
        args.table_name = table_name
        args.future = future
        args.scan_spec = scan_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_async_scanner_open(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = async_scanner_open_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "async_scanner_open failed: unknown result")

    def open_scanner_async(self, ns, table_name, future, scan_spec):
        """
        Parameters:
         - ns
         - table_name
         - future
         - scan_spec

        """
        self.send_open_scanner_async(ns, table_name, future, scan_spec)
        return self.recv_open_scanner_async()

    def send_open_scanner_async(self, ns, table_name, future, scan_spec):
        self._oprot.writeMessageBegin('open_scanner_async', TMessageType.CALL, self._seqid)
        args = open_scanner_async_args()
        args.ns = ns
        args.table_name = table_name
        args.future = future
        args.scan_spec = scan_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_open_scanner_async(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = open_scanner_async_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "open_scanner_async failed: unknown result")

    def scanner_close(self, scanner):
        """
        Close a table scanner

        @param scanner - scanner id to close

        Parameters:
         - scanner

        """
        self.send_scanner_close(scanner)
        self.recv_scanner_close()

    def send_scanner_close(self, scanner):
        self._oprot.writeMessageBegin('scanner_close', TMessageType.CALL, self._seqid)
        args = scanner_close_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_scanner_close(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = scanner_close_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def close_scanner(self, scanner):
        """
        Parameters:
         - scanner

        """
        self.send_close_scanner(scanner)
        self.recv_close_scanner()

    def send_close_scanner(self, scanner):
        self._oprot.writeMessageBegin('close_scanner', TMessageType.CALL, self._seqid)
        args = close_scanner_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_close_scanner(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = close_scanner_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def async_scanner_cancel(self, scanner):
        """
        Cancel a table scanner

        @param scanner - scanner id to close

        Parameters:
         - scanner

        """
        self.send_async_scanner_cancel(scanner)
        self.recv_async_scanner_cancel()

    def send_async_scanner_cancel(self, scanner):
        self._oprot.writeMessageBegin('async_scanner_cancel', TMessageType.CALL, self._seqid)
        args = async_scanner_cancel_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_async_scanner_cancel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = async_scanner_cancel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def cancel_scanner_async(self, scanner):
        """
        Parameters:
         - scanner

        """
        self.send_cancel_scanner_async(scanner)
        self.recv_cancel_scanner_async()

    def send_cancel_scanner_async(self, scanner):
        self._oprot.writeMessageBegin('cancel_scanner_async', TMessageType.CALL, self._seqid)
        args = cancel_scanner_async_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cancel_scanner_async(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cancel_scanner_async_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def async_scanner_close(self, scanner):
        """
        Close a table scanner

        @param scanner - scanner id to close

        Parameters:
         - scanner

        """
        self.send_async_scanner_close(scanner)
        self.recv_async_scanner_close()

    def send_async_scanner_close(self, scanner):
        self._oprot.writeMessageBegin('async_scanner_close', TMessageType.CALL, self._seqid)
        args = async_scanner_close_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_async_scanner_close(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = async_scanner_close_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def close_scanner_async(self, scanner):
        """
        Parameters:
         - scanner

        """
        self.send_close_scanner_async(scanner)
        self.recv_close_scanner_async()

    def send_close_scanner_async(self, scanner):
        self._oprot.writeMessageBegin('close_scanner_async', TMessageType.CALL, self._seqid)
        args = close_scanner_async_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_close_scanner_async(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = close_scanner_async_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def scanner_get_cells(self, scanner):
        """
        Iterate over cells of a scanner

        @param scanner - scanner id

        Parameters:
         - scanner

        """
        self.send_scanner_get_cells(scanner)
        return self.recv_scanner_get_cells()

    def send_scanner_get_cells(self, scanner):
        self._oprot.writeMessageBegin('scanner_get_cells', TMessageType.CALL, self._seqid)
        args = scanner_get_cells_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_scanner_get_cells(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = scanner_get_cells_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "scanner_get_cells failed: unknown result")

    def next_cells(self, scanner):
        """
        Parameters:
         - scanner

        """
        self.send_next_cells(scanner)
        return self.recv_next_cells()

    def send_next_cells(self, scanner):
        self._oprot.writeMessageBegin('next_cells', TMessageType.CALL, self._seqid)
        args = next_cells_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_next_cells(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = next_cells_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "next_cells failed: unknown result")

    def scanner_get_cells_as_arrays(self, scanner):
        """
        Parameters:
         - scanner

        """
        self.send_scanner_get_cells_as_arrays(scanner)
        return self.recv_scanner_get_cells_as_arrays()

    def send_scanner_get_cells_as_arrays(self, scanner):
        self._oprot.writeMessageBegin('scanner_get_cells_as_arrays', TMessageType.CALL, self._seqid)
        args = scanner_get_cells_as_arrays_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_scanner_get_cells_as_arrays(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = scanner_get_cells_as_arrays_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "scanner_get_cells_as_arrays failed: unknown result")

    def next_cells_as_arrays(self, scanner):
        """
        Parameters:
         - scanner

        """
        self.send_next_cells_as_arrays(scanner)
        return self.recv_next_cells_as_arrays()

    def send_next_cells_as_arrays(self, scanner):
        self._oprot.writeMessageBegin('next_cells_as_arrays', TMessageType.CALL, self._seqid)
        args = next_cells_as_arrays_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_next_cells_as_arrays(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = next_cells_as_arrays_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "next_cells_as_arrays failed: unknown result")

    def scanner_get_cells_serialized(self, scanner):
        """
        Alternative interface returning buffer of serialized cells

        Parameters:
         - scanner

        """
        self.send_scanner_get_cells_serialized(scanner)
        return self.recv_scanner_get_cells_serialized()

    def send_scanner_get_cells_serialized(self, scanner):
        self._oprot.writeMessageBegin('scanner_get_cells_serialized', TMessageType.CALL, self._seqid)
        args = scanner_get_cells_serialized_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_scanner_get_cells_serialized(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = scanner_get_cells_serialized_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "scanner_get_cells_serialized failed: unknown result")

    def next_cells_serialized(self, scanner):
        """
        Parameters:
         - scanner

        """
        self.send_next_cells_serialized(scanner)
        return self.recv_next_cells_serialized()

    def send_next_cells_serialized(self, scanner):
        self._oprot.writeMessageBegin('next_cells_serialized', TMessageType.CALL, self._seqid)
        args = next_cells_serialized_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_next_cells_serialized(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = next_cells_serialized_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "next_cells_serialized failed: unknown result")

    def scanner_get_row(self, scanner):
        """
        Iterate over rows of a scanner

        @param scanner - scanner id

        Parameters:
         - scanner

        """
        self.send_scanner_get_row(scanner)
        return self.recv_scanner_get_row()

    def send_scanner_get_row(self, scanner):
        self._oprot.writeMessageBegin('scanner_get_row', TMessageType.CALL, self._seqid)
        args = scanner_get_row_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_scanner_get_row(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = scanner_get_row_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "scanner_get_row failed: unknown result")

    def next_row(self, scanner):
        """
        Parameters:
         - scanner

        """
        self.send_next_row(scanner)
        return self.recv_next_row()

    def send_next_row(self, scanner):
        self._oprot.writeMessageBegin('next_row', TMessageType.CALL, self._seqid)
        args = next_row_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_next_row(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = next_row_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "next_row failed: unknown result")

    def scanner_get_row_as_arrays(self, scanner):
        """
        Alternative interface using array as cell

        Parameters:
         - scanner

        """
        self.send_scanner_get_row_as_arrays(scanner)
        return self.recv_scanner_get_row_as_arrays()

    def send_scanner_get_row_as_arrays(self, scanner):
        self._oprot.writeMessageBegin('scanner_get_row_as_arrays', TMessageType.CALL, self._seqid)
        args = scanner_get_row_as_arrays_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_scanner_get_row_as_arrays(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = scanner_get_row_as_arrays_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "scanner_get_row_as_arrays failed: unknown result")

    def next_row_as_arrays(self, scanner):
        """
        Parameters:
         - scanner

        """
        self.send_next_row_as_arrays(scanner)
        return self.recv_next_row_as_arrays()

    def send_next_row_as_arrays(self, scanner):
        self._oprot.writeMessageBegin('next_row_as_arrays', TMessageType.CALL, self._seqid)
        args = next_row_as_arrays_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_next_row_as_arrays(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = next_row_as_arrays_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "next_row_as_arrays failed: unknown result")

    def scanner_get_row_serialized(self, scanner):
        """
        Alternate interface returning a buffer of serialized cells for iterating by row
        for a given scanner

        @param scanner - scanner id

        Parameters:
         - scanner

        """
        self.send_scanner_get_row_serialized(scanner)
        return self.recv_scanner_get_row_serialized()

    def send_scanner_get_row_serialized(self, scanner):
        self._oprot.writeMessageBegin('scanner_get_row_serialized', TMessageType.CALL, self._seqid)
        args = scanner_get_row_serialized_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_scanner_get_row_serialized(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = scanner_get_row_serialized_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "scanner_get_row_serialized failed: unknown result")

    def next_row_serialized(self, scanner):
        """
        Parameters:
         - scanner

        """
        self.send_next_row_serialized(scanner)
        return self.recv_next_row_serialized()

    def send_next_row_serialized(self, scanner):
        self._oprot.writeMessageBegin('next_row_serialized', TMessageType.CALL, self._seqid)
        args = next_row_serialized_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_next_row_serialized(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = next_row_serialized_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "next_row_serialized failed: unknown result")

    def get_row(self, ns, table_name, row):
        """
        Get a row (convenience method for random access a row)

        @param ns - namespace id

        @param table_name - table name

        @param row - row key

        @return a list of cells (with row_keys unset)

        Parameters:
         - ns
         - table_name
         - row

        """
        self.send_get_row(ns, table_name, row)
        return self.recv_get_row()

    def send_get_row(self, ns, table_name, row):
        self._oprot.writeMessageBegin('get_row', TMessageType.CALL, self._seqid)
        args = get_row_args()
        args.ns = ns
        args.table_name = table_name
        args.row = row
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_row(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_row_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_row failed: unknown result")

    def get_row_as_arrays(self, ns, name, row):
        """
        Alternative interface using array as cell

        Parameters:
         - ns
         - name
         - row

        """
        self.send_get_row_as_arrays(ns, name, row)
        return self.recv_get_row_as_arrays()

    def send_get_row_as_arrays(self, ns, name, row):
        self._oprot.writeMessageBegin('get_row_as_arrays', TMessageType.CALL, self._seqid)
        args = get_row_as_arrays_args()
        args.ns = ns
        args.name = name
        args.row = row
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_row_as_arrays(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_row_as_arrays_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_row_as_arrays failed: unknown result")

    def get_row_serialized(self, ns, table_name, row):
        """
        Alternative interface returning buffer of serialized cells

        Parameters:
         - ns
         - table_name
         - row

        """
        self.send_get_row_serialized(ns, table_name, row)
        return self.recv_get_row_serialized()

    def send_get_row_serialized(self, ns, table_name, row):
        self._oprot.writeMessageBegin('get_row_serialized', TMessageType.CALL, self._seqid)
        args = get_row_serialized_args()
        args.ns = ns
        args.table_name = table_name
        args.row = row
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_row_serialized(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_row_serialized_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_row_serialized failed: unknown result")

    def get_cell(self, ns, table_name, row, column):
        """
        Get a cell (convenience method for random access a cell)

        @param ns - namespace id

        @param table_name - table name

        @param row - row key

        @param column - column name

        @return value (byte sequence)

        Parameters:
         - ns
         - table_name
         - row
         - column

        """
        self.send_get_cell(ns, table_name, row, column)
        return self.recv_get_cell()

    def send_get_cell(self, ns, table_name, row, column):
        self._oprot.writeMessageBegin('get_cell', TMessageType.CALL, self._seqid)
        args = get_cell_args()
        args.ns = ns
        args.table_name = table_name
        args.row = row
        args.column = column
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_cell(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_cell_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_cell failed: unknown result")

    def get_cells(self, ns, table_name, scan_spec):
        """
        Get cells (convenience method for access small amount of cells)

        @param ns - namespace id
         
        @param table_name - table name

        @param scan_spec - scan specification

        @return a list of cells (a cell with no row key set is assumed to have
                the same row key as the previous cell)

        Parameters:
         - ns
         - table_name
         - scan_spec

        """
        self.send_get_cells(ns, table_name, scan_spec)
        return self.recv_get_cells()

    def send_get_cells(self, ns, table_name, scan_spec):
        self._oprot.writeMessageBegin('get_cells', TMessageType.CALL, self._seqid)
        args = get_cells_args()
        args.ns = ns
        args.table_name = table_name
        args.scan_spec = scan_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_cells(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_cells_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_cells failed: unknown result")

    def get_cells_as_arrays(self, ns, name, scan_spec):
        """
        Alternative interface using array as cell

        Parameters:
         - ns
         - name
         - scan_spec

        """
        self.send_get_cells_as_arrays(ns, name, scan_spec)
        return self.recv_get_cells_as_arrays()

    def send_get_cells_as_arrays(self, ns, name, scan_spec):
        self._oprot.writeMessageBegin('get_cells_as_arrays', TMessageType.CALL, self._seqid)
        args = get_cells_as_arrays_args()
        args.ns = ns
        args.name = name
        args.scan_spec = scan_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_cells_as_arrays(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_cells_as_arrays_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_cells_as_arrays failed: unknown result")

    def get_cells_serialized(self, ns, name, scan_spec):
        """
        Alternative interface returning buffer of serialized cells

        Parameters:
         - ns
         - name
         - scan_spec

        """
        self.send_get_cells_serialized(ns, name, scan_spec)
        return self.recv_get_cells_serialized()

    def send_get_cells_serialized(self, ns, name, scan_spec):
        self._oprot.writeMessageBegin('get_cells_serialized', TMessageType.CALL, self._seqid)
        args = get_cells_serialized_args()
        args.ns = ns
        args.name = name
        args.scan_spec = scan_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_cells_serialized(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_cells_serialized_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_cells_serialized failed: unknown result")

    def shared_mutator_refresh(self, ns, table_name, mutate_spec):
        """
        Create a shared mutator with specified MutateSpec.
        Delete and recreate it if the mutator exists.

        @param ns - namespace id
         
        @param table_name - table name

        @param mutate_spec - mutator specification


        Parameters:
         - ns
         - table_name
         - mutate_spec

        """
        self.send_shared_mutator_refresh(ns, table_name, mutate_spec)
        self.recv_shared_mutator_refresh()

    def send_shared_mutator_refresh(self, ns, table_name, mutate_spec):
        self._oprot.writeMessageBegin('shared_mutator_refresh', TMessageType.CALL, self._seqid)
        args = shared_mutator_refresh_args()
        args.ns = ns
        args.table_name = table_name
        args.mutate_spec = mutate_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_shared_mutator_refresh(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = shared_mutator_refresh_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def refresh_shared_mutator(self, ns, table_name, mutate_spec):
        """
        Parameters:
         - ns
         - table_name
         - mutate_spec

        """
        self.send_refresh_shared_mutator(ns, table_name, mutate_spec)
        self.recv_refresh_shared_mutator()

    def send_refresh_shared_mutator(self, ns, table_name, mutate_spec):
        self._oprot.writeMessageBegin('refresh_shared_mutator', TMessageType.CALL, self._seqid)
        args = refresh_shared_mutator_args()
        args.ns = ns
        args.table_name = table_name
        args.mutate_spec = mutate_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_refresh_shared_mutator(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = refresh_shared_mutator_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def shared_mutator_set_cells(self, ns, table_name, mutate_spec, cells):
        """
        Open a shared periodic mutator which causes cells to be written asyncronously.
        Users beware: calling this method merely writes
        cells to a local buffer and does not guarantee that the cells have been persisted.
        If you want guaranteed durability, use the open_mutator+set_cells* interface instead.

        @param ns - namespace id

        @param table_name - table name

        @param mutate_spec - mutator specification

        @param cells - set of cells to be written

        Parameters:
         - ns
         - table_name
         - mutate_spec
         - cells

        """
        self.send_shared_mutator_set_cells(ns, table_name, mutate_spec, cells)
        self.recv_shared_mutator_set_cells()

    def send_shared_mutator_set_cells(self, ns, table_name, mutate_spec, cells):
        self._oprot.writeMessageBegin('shared_mutator_set_cells', TMessageType.CALL, self._seqid)
        args = shared_mutator_set_cells_args()
        args.ns = ns
        args.table_name = table_name
        args.mutate_spec = mutate_spec
        args.cells = cells
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_shared_mutator_set_cells(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = shared_mutator_set_cells_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def offer_cells(self, ns, table_name, mutate_spec, cells):
        """
        Parameters:
         - ns
         - table_name
         - mutate_spec
         - cells

        """
        self.send_offer_cells(ns, table_name, mutate_spec, cells)
        self.recv_offer_cells()

    def send_offer_cells(self, ns, table_name, mutate_spec, cells):
        self._oprot.writeMessageBegin('offer_cells', TMessageType.CALL, self._seqid)
        args = offer_cells_args()
        args.ns = ns
        args.table_name = table_name
        args.mutate_spec = mutate_spec
        args.cells = cells
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_offer_cells(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = offer_cells_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def shared_mutator_set_cells_as_arrays(self, ns, table_name, mutate_spec, cells):
        """
        Alternative to offer_cell interface using array as cell

        Parameters:
         - ns
         - table_name
         - mutate_spec
         - cells

        """
        self.send_shared_mutator_set_cells_as_arrays(ns, table_name, mutate_spec, cells)
        self.recv_shared_mutator_set_cells_as_arrays()

    def send_shared_mutator_set_cells_as_arrays(self, ns, table_name, mutate_spec, cells):
        self._oprot.writeMessageBegin('shared_mutator_set_cells_as_arrays', TMessageType.CALL, self._seqid)
        args = shared_mutator_set_cells_as_arrays_args()
        args.ns = ns
        args.table_name = table_name
        args.mutate_spec = mutate_spec
        args.cells = cells
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_shared_mutator_set_cells_as_arrays(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = shared_mutator_set_cells_as_arrays_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def offer_cells_as_arrays(self, ns, table_name, mutate_spec, cells):
        """
        Parameters:
         - ns
         - table_name
         - mutate_spec
         - cells

        """
        self.send_offer_cells_as_arrays(ns, table_name, mutate_spec, cells)
        self.recv_offer_cells_as_arrays()

    def send_offer_cells_as_arrays(self, ns, table_name, mutate_spec, cells):
        self._oprot.writeMessageBegin('offer_cells_as_arrays', TMessageType.CALL, self._seqid)
        args = offer_cells_as_arrays_args()
        args.ns = ns
        args.table_name = table_name
        args.mutate_spec = mutate_spec
        args.cells = cells
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_offer_cells_as_arrays(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = offer_cells_as_arrays_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def shared_mutator_set_cell(self, ns, table_name, mutate_spec, cell):
        """
        Open a shared periodic mutator which causes cells to be written asyncronously.
        Users beware: calling this method merely writes
        cells to a local buffer and does not guarantee that the cells have been persisted.
        If you want guaranteed durability, use the open_mutator+set_cells* interface instead.

        @param ns - namespace id

        @param table_name - table name

        @param mutate_spec - mutator specification

        @param cell - cell to be written

        Parameters:
         - ns
         - table_name
         - mutate_spec
         - cell

        """
        self.send_shared_mutator_set_cell(ns, table_name, mutate_spec, cell)
        self.recv_shared_mutator_set_cell()

    def send_shared_mutator_set_cell(self, ns, table_name, mutate_spec, cell):
        self._oprot.writeMessageBegin('shared_mutator_set_cell', TMessageType.CALL, self._seqid)
        args = shared_mutator_set_cell_args()
        args.ns = ns
        args.table_name = table_name
        args.mutate_spec = mutate_spec
        args.cell = cell
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_shared_mutator_set_cell(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = shared_mutator_set_cell_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def offer_cell(self, ns, table_name, mutate_spec, cell):
        """
        Parameters:
         - ns
         - table_name
         - mutate_spec
         - cell

        """
        self.send_offer_cell(ns, table_name, mutate_spec, cell)
        self.recv_offer_cell()

    def send_offer_cell(self, ns, table_name, mutate_spec, cell):
        self._oprot.writeMessageBegin('offer_cell', TMessageType.CALL, self._seqid)
        args = offer_cell_args()
        args.ns = ns
        args.table_name = table_name
        args.mutate_spec = mutate_spec
        args.cell = cell
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_offer_cell(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = offer_cell_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def shared_mutator_set_cell_as_array(self, ns, table_name, mutate_spec, cell):
        """
        Alternative to offer_cell interface using array as cell

        Parameters:
         - ns
         - table_name
         - mutate_spec
         - cell

        """
        self.send_shared_mutator_set_cell_as_array(ns, table_name, mutate_spec, cell)
        self.recv_shared_mutator_set_cell_as_array()

    def send_shared_mutator_set_cell_as_array(self, ns, table_name, mutate_spec, cell):
        self._oprot.writeMessageBegin('shared_mutator_set_cell_as_array', TMessageType.CALL, self._seqid)
        args = shared_mutator_set_cell_as_array_args()
        args.ns = ns
        args.table_name = table_name
        args.mutate_spec = mutate_spec
        args.cell = cell
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_shared_mutator_set_cell_as_array(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = shared_mutator_set_cell_as_array_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def offer_cell_as_array(self, ns, table_name, mutate_spec, cell):
        """
        Parameters:
         - ns
         - table_name
         - mutate_spec
         - cell

        """
        self.send_offer_cell_as_array(ns, table_name, mutate_spec, cell)
        self.recv_offer_cell_as_array()

    def send_offer_cell_as_array(self, ns, table_name, mutate_spec, cell):
        self._oprot.writeMessageBegin('offer_cell_as_array', TMessageType.CALL, self._seqid)
        args = offer_cell_as_array_args()
        args.ns = ns
        args.table_name = table_name
        args.mutate_spec = mutate_spec
        args.cell = cell
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_offer_cell_as_array(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = offer_cell_as_array_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def mutator_open(self, ns, table_name, flags, flush_interval):
        """
        Open a table mutator

        @param ns - namespace id

        @param table_name - table name

        @param flags - mutator flags

        @param flush_interval - auto-flush interval in milliseconds; 0 disables it.

        @return mutator id

        Parameters:
         - ns
         - table_name
         - flags
         - flush_interval

        """
        self.send_mutator_open(ns, table_name, flags, flush_interval)
        return self.recv_mutator_open()

    def send_mutator_open(self, ns, table_name, flags, flush_interval):
        self._oprot.writeMessageBegin('mutator_open', TMessageType.CALL, self._seqid)
        args = mutator_open_args()
        args.ns = ns
        args.table_name = table_name
        args.flags = flags
        args.flush_interval = flush_interval
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mutator_open(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mutator_open_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mutator_open failed: unknown result")

    def open_mutator(self, ns, table_name, flags, flush_interval):
        """
        Parameters:
         - ns
         - table_name
         - flags
         - flush_interval

        """
        self.send_open_mutator(ns, table_name, flags, flush_interval)
        return self.recv_open_mutator()

    def send_open_mutator(self, ns, table_name, flags, flush_interval):
        self._oprot.writeMessageBegin('open_mutator', TMessageType.CALL, self._seqid)
        args = open_mutator_args()
        args.ns = ns
        args.table_name = table_name
        args.flags = flags
        args.flush_interval = flush_interval
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_open_mutator(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = open_mutator_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "open_mutator failed: unknown result")

    def async_mutator_open(self, ns, table_name, future, flags):
        """
        Open an asynchronous table mutator

        @param ns - namespace id
        @param table_name - table name
        @param future - callback object
        @param flags - mutator flags

        @return mutator id

        Parameters:
         - ns
         - table_name
         - future
         - flags

        """
        self.send_async_mutator_open(ns, table_name, future, flags)
        return self.recv_async_mutator_open()

    def send_async_mutator_open(self, ns, table_name, future, flags):
        self._oprot.writeMessageBegin('async_mutator_open', TMessageType.CALL, self._seqid)
        args = async_mutator_open_args()
        args.ns = ns
        args.table_name = table_name
        args.future = future
        args.flags = flags
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_async_mutator_open(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = async_mutator_open_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "async_mutator_open failed: unknown result")

    def open_mutator_async(self, ns, table_name, future, flags):
        """
        Parameters:
         - ns
         - table_name
         - future
         - flags

        """
        self.send_open_mutator_async(ns, table_name, future, flags)
        return self.recv_open_mutator_async()

    def send_open_mutator_async(self, ns, table_name, future, flags):
        self._oprot.writeMessageBegin('open_mutator_async', TMessageType.CALL, self._seqid)
        args = open_mutator_async_args()
        args.ns = ns
        args.table_name = table_name
        args.future = future
        args.flags = flags
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_open_mutator_async(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = open_mutator_async_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "open_mutator_async failed: unknown result")

    def mutator_close(self, mutator):
        """
        Close a table mutator

        @param mutator - mutator id to close

        Parameters:
         - mutator

        """
        self.send_mutator_close(mutator)
        self.recv_mutator_close()

    def send_mutator_close(self, mutator):
        self._oprot.writeMessageBegin('mutator_close', TMessageType.CALL, self._seqid)
        args = mutator_close_args()
        args.mutator = mutator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mutator_close(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mutator_close_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def close_mutator(self, mutator):
        """
        Parameters:
         - mutator

        """
        self.send_close_mutator(mutator)
        self.recv_close_mutator()

    def send_close_mutator(self, mutator):
        self._oprot.writeMessageBegin('close_mutator', TMessageType.CALL, self._seqid)
        args = close_mutator_args()
        args.mutator = mutator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_close_mutator(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = close_mutator_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def async_mutator_cancel(self, mutator):
        """
        Cancel an asynchronous table mutator

        @param mutator -  mutator id to cancel

        Parameters:
         - mutator

        """
        self.send_async_mutator_cancel(mutator)
        self.recv_async_mutator_cancel()

    def send_async_mutator_cancel(self, mutator):
        self._oprot.writeMessageBegin('async_mutator_cancel', TMessageType.CALL, self._seqid)
        args = async_mutator_cancel_args()
        args.mutator = mutator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_async_mutator_cancel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = async_mutator_cancel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def cancel_mutator_async(self, mutator):
        """
        Parameters:
         - mutator

        """
        self.send_cancel_mutator_async(mutator)
        self.recv_cancel_mutator_async()

    def send_cancel_mutator_async(self, mutator):
        self._oprot.writeMessageBegin('cancel_mutator_async', TMessageType.CALL, self._seqid)
        args = cancel_mutator_async_args()
        args.mutator = mutator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cancel_mutator_async(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cancel_mutator_async_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def async_mutator_close(self, mutator):
        """
        Close an asynchronous table mutator

        @param mutator - mutator id to close

        Parameters:
         - mutator

        """
        self.send_async_mutator_close(mutator)
        self.recv_async_mutator_close()

    def send_async_mutator_close(self, mutator):
        self._oprot.writeMessageBegin('async_mutator_close', TMessageType.CALL, self._seqid)
        args = async_mutator_close_args()
        args.mutator = mutator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_async_mutator_close(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = async_mutator_close_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def close_mutator_async(self, mutator):
        """
        Parameters:
         - mutator

        """
        self.send_close_mutator_async(mutator)
        self.recv_close_mutator_async()

    def send_close_mutator_async(self, mutator):
        self._oprot.writeMessageBegin('close_mutator_async', TMessageType.CALL, self._seqid)
        args = close_mutator_async_args()
        args.mutator = mutator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_close_mutator_async(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = close_mutator_async_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def mutator_set_cell(self, mutator, cell):
        """
        Set a cell via mutator

        @param mutator - mutator id

        @param cell - the cell to set

        Parameters:
         - mutator
         - cell

        """
        self.send_mutator_set_cell(mutator, cell)
        self.recv_mutator_set_cell()

    def send_mutator_set_cell(self, mutator, cell):
        self._oprot.writeMessageBegin('mutator_set_cell', TMessageType.CALL, self._seqid)
        args = mutator_set_cell_args()
        args.mutator = mutator
        args.cell = cell
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mutator_set_cell(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mutator_set_cell_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def set_cell(self, ns, table_name, cell):
        """
        Set a cell in the table

        @param ns - namespace id

        @param table_name - table name

        @param cell - the cell to set

        Parameters:
         - ns
         - table_name
         - cell

        """
        self.send_set_cell(ns, table_name, cell)
        self.recv_set_cell()

    def send_set_cell(self, ns, table_name, cell):
        self._oprot.writeMessageBegin('set_cell', TMessageType.CALL, self._seqid)
        args = set_cell_args()
        args.ns = ns
        args.table_name = table_name
        args.cell = cell
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_cell(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_cell_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def mutator_set_cell_as_array(self, mutator, cell):
        """
        Alternative interface using array as cell

        Parameters:
         - mutator
         - cell

        """
        self.send_mutator_set_cell_as_array(mutator, cell)
        self.recv_mutator_set_cell_as_array()

    def send_mutator_set_cell_as_array(self, mutator, cell):
        self._oprot.writeMessageBegin('mutator_set_cell_as_array', TMessageType.CALL, self._seqid)
        args = mutator_set_cell_as_array_args()
        args.mutator = mutator
        args.cell = cell
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mutator_set_cell_as_array(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mutator_set_cell_as_array_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def set_cell_as_array(self, ns, table_name, cell):
        """
        Alternative interface using array as cell

        Parameters:
         - ns
         - table_name
         - cell

        """
        self.send_set_cell_as_array(ns, table_name, cell)
        self.recv_set_cell_as_array()

    def send_set_cell_as_array(self, ns, table_name, cell):
        self._oprot.writeMessageBegin('set_cell_as_array', TMessageType.CALL, self._seqid)
        args = set_cell_as_array_args()
        args.ns = ns
        args.table_name = table_name
        args.cell = cell
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_cell_as_array(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_cell_as_array_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def mutator_set_cells(self, mutator, cells):
        """
        Put a list of cells into a table via mutator

        @param mutator - mutator id

        @param cells - a list of cells (a cell with no row key set is assumed
               to have the same row key as the previous cell)

        Parameters:
         - mutator
         - cells

        """
        self.send_mutator_set_cells(mutator, cells)
        self.recv_mutator_set_cells()

    def send_mutator_set_cells(self, mutator, cells):
        self._oprot.writeMessageBegin('mutator_set_cells', TMessageType.CALL, self._seqid)
        args = mutator_set_cells_args()
        args.mutator = mutator
        args.cells = cells
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mutator_set_cells(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mutator_set_cells_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def set_cells(self, ns, table_name, cells):
        """
        Put a list of cells into a table

        @param ns - namespace id

        @param table_name - table name

        @param cells - a list of cells (a cell with no row key set is assumed
               to have the same row key as the previous cell)

        Parameters:
         - ns
         - table_name
         - cells

        """
        self.send_set_cells(ns, table_name, cells)
        self.recv_set_cells()

    def send_set_cells(self, ns, table_name, cells):
        self._oprot.writeMessageBegin('set_cells', TMessageType.CALL, self._seqid)
        args = set_cells_args()
        args.ns = ns
        args.table_name = table_name
        args.cells = cells
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_cells(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_cells_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def mutator_set_cells_as_arrays(self, mutator, cells):
        """
        Alternative interface using array as cell

        Parameters:
         - mutator
         - cells

        """
        self.send_mutator_set_cells_as_arrays(mutator, cells)
        self.recv_mutator_set_cells_as_arrays()

    def send_mutator_set_cells_as_arrays(self, mutator, cells):
        self._oprot.writeMessageBegin('mutator_set_cells_as_arrays', TMessageType.CALL, self._seqid)
        args = mutator_set_cells_as_arrays_args()
        args.mutator = mutator
        args.cells = cells
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mutator_set_cells_as_arrays(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mutator_set_cells_as_arrays_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def set_cells_as_arrays(self, ns, table_name, cells):
        """
        Alternative interface using array as cell

        Parameters:
         - ns
         - table_name
         - cells

        """
        self.send_set_cells_as_arrays(ns, table_name, cells)
        self.recv_set_cells_as_arrays()

    def send_set_cells_as_arrays(self, ns, table_name, cells):
        self._oprot.writeMessageBegin('set_cells_as_arrays', TMessageType.CALL, self._seqid)
        args = set_cells_as_arrays_args()
        args.ns = ns
        args.table_name = table_name
        args.cells = cells
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_cells_as_arrays(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_cells_as_arrays_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def mutator_set_cells_serialized(self, mutator, cells, flush):
        """
        Alternative interface using buffer of serialized cells

        Parameters:
         - mutator
         - cells
         - flush

        """
        self.send_mutator_set_cells_serialized(mutator, cells, flush)
        self.recv_mutator_set_cells_serialized()

    def send_mutator_set_cells_serialized(self, mutator, cells, flush):
        self._oprot.writeMessageBegin('mutator_set_cells_serialized', TMessageType.CALL, self._seqid)
        args = mutator_set_cells_serialized_args()
        args.mutator = mutator
        args.cells = cells
        args.flush = flush
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mutator_set_cells_serialized(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mutator_set_cells_serialized_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def set_cells_serialized(self, ns, table_name, cells):
        """
        Alternative interface using buffer of serialized cells

        Parameters:
         - ns
         - table_name
         - cells

        """
        self.send_set_cells_serialized(ns, table_name, cells)
        self.recv_set_cells_serialized()

    def send_set_cells_serialized(self, ns, table_name, cells):
        self._oprot.writeMessageBegin('set_cells_serialized', TMessageType.CALL, self._seqid)
        args = set_cells_serialized_args()
        args.ns = ns
        args.table_name = table_name
        args.cells = cells
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_cells_serialized(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_cells_serialized_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def mutator_flush(self, mutator):
        """
        Flush mutator buffers

        Parameters:
         - mutator

        """
        self.send_mutator_flush(mutator)
        self.recv_mutator_flush()

    def send_mutator_flush(self, mutator):
        self._oprot.writeMessageBegin('mutator_flush', TMessageType.CALL, self._seqid)
        args = mutator_flush_args()
        args.mutator = mutator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mutator_flush(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mutator_flush_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def flush_mutator(self, mutator):
        """
        Parameters:
         - mutator

        """
        self.send_flush_mutator(mutator)
        self.recv_flush_mutator()

    def send_flush_mutator(self, mutator):
        self._oprot.writeMessageBegin('flush_mutator', TMessageType.CALL, self._seqid)
        args = flush_mutator_args()
        args.mutator = mutator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_flush_mutator(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = flush_mutator_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def async_mutator_set_cell(self, mutator, cell):
        """
        Set a cell in the table using an asynchonous mutator

        @param mutator - mutator id

        @param cell - the cell to set

        Parameters:
         - mutator
         - cell

        """
        self.send_async_mutator_set_cell(mutator, cell)
        self.recv_async_mutator_set_cell()

    def send_async_mutator_set_cell(self, mutator, cell):
        self._oprot.writeMessageBegin('async_mutator_set_cell', TMessageType.CALL, self._seqid)
        args = async_mutator_set_cell_args()
        args.mutator = mutator
        args.cell = cell
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_async_mutator_set_cell(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = async_mutator_set_cell_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def set_cell_async(self, mutator, cell):
        """
        Parameters:
         - mutator
         - cell

        """
        self.send_set_cell_async(mutator, cell)
        self.recv_set_cell_async()

    def send_set_cell_async(self, mutator, cell):
        self._oprot.writeMessageBegin('set_cell_async', TMessageType.CALL, self._seqid)
        args = set_cell_async_args()
        args.mutator = mutator
        args.cell = cell
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_cell_async(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_cell_async_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def async_mutator_set_cell_as_array(self, mutator, cell):
        """
        Alternative interface using array as cell using an asynchonous mutator

        Parameters:
         - mutator
         - cell

        """
        self.send_async_mutator_set_cell_as_array(mutator, cell)
        self.recv_async_mutator_set_cell_as_array()

    def send_async_mutator_set_cell_as_array(self, mutator, cell):
        self._oprot.writeMessageBegin('async_mutator_set_cell_as_array', TMessageType.CALL, self._seqid)
        args = async_mutator_set_cell_as_array_args()
        args.mutator = mutator
        args.cell = cell
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_async_mutator_set_cell_as_array(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = async_mutator_set_cell_as_array_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def set_cell_as_array_async(self, mutator, cell):
        """
        Parameters:
         - mutator
         - cell

        """
        self.send_set_cell_as_array_async(mutator, cell)
        self.recv_set_cell_as_array_async()

    def send_set_cell_as_array_async(self, mutator, cell):
        self._oprot.writeMessageBegin('set_cell_as_array_async', TMessageType.CALL, self._seqid)
        args = set_cell_as_array_async_args()
        args.mutator = mutator
        args.cell = cell
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_cell_as_array_async(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_cell_as_array_async_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def async_mutator_set_cells(self, mutator, cells):
        """
        Put a list of cells into a table using asynchonous mutator

        @param mutator - mutator id

        @param cells - a list of cells (a cell with no row key set is assumed
               to have the same row key as the previous cell)

        Parameters:
         - mutator
         - cells

        """
        self.send_async_mutator_set_cells(mutator, cells)
        self.recv_async_mutator_set_cells()

    def send_async_mutator_set_cells(self, mutator, cells):
        self._oprot.writeMessageBegin('async_mutator_set_cells', TMessageType.CALL, self._seqid)
        args = async_mutator_set_cells_args()
        args.mutator = mutator
        args.cells = cells
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_async_mutator_set_cells(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = async_mutator_set_cells_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def set_cells_async(self, mutator, cells):
        """
        Parameters:
         - mutator
         - cells

        """
        self.send_set_cells_async(mutator, cells)
        self.recv_set_cells_async()

    def send_set_cells_async(self, mutator, cells):
        self._oprot.writeMessageBegin('set_cells_async', TMessageType.CALL, self._seqid)
        args = set_cells_async_args()
        args.mutator = mutator
        args.cells = cells
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_cells_async(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_cells_async_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def async_mutator_set_cells_as_arrays(self, mutator, cells):
        """
        Alternative interface using array as cell

        Parameters:
         - mutator
         - cells

        """
        self.send_async_mutator_set_cells_as_arrays(mutator, cells)
        self.recv_async_mutator_set_cells_as_arrays()

    def send_async_mutator_set_cells_as_arrays(self, mutator, cells):
        self._oprot.writeMessageBegin('async_mutator_set_cells_as_arrays', TMessageType.CALL, self._seqid)
        args = async_mutator_set_cells_as_arrays_args()
        args.mutator = mutator
        args.cells = cells
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_async_mutator_set_cells_as_arrays(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = async_mutator_set_cells_as_arrays_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def set_cells_as_arrays_async(self, mutator, cells):
        """
        Parameters:
         - mutator
         - cells

        """
        self.send_set_cells_as_arrays_async(mutator, cells)
        self.recv_set_cells_as_arrays_async()

    def send_set_cells_as_arrays_async(self, mutator, cells):
        self._oprot.writeMessageBegin('set_cells_as_arrays_async', TMessageType.CALL, self._seqid)
        args = set_cells_as_arrays_async_args()
        args.mutator = mutator
        args.cells = cells
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_cells_as_arrays_async(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_cells_as_arrays_async_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def async_mutator_set_cells_serialized(self, mutator, cells, flush):
        """
        Alternative interface using buffer of serialized cells

        Parameters:
         - mutator
         - cells
         - flush

        """
        self.send_async_mutator_set_cells_serialized(mutator, cells, flush)
        self.recv_async_mutator_set_cells_serialized()

    def send_async_mutator_set_cells_serialized(self, mutator, cells, flush):
        self._oprot.writeMessageBegin('async_mutator_set_cells_serialized', TMessageType.CALL, self._seqid)
        args = async_mutator_set_cells_serialized_args()
        args.mutator = mutator
        args.cells = cells
        args.flush = flush
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_async_mutator_set_cells_serialized(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = async_mutator_set_cells_serialized_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def set_cells_serialized_async(self, mutator, cells, flush):
        """
        Parameters:
         - mutator
         - cells
         - flush

        """
        self.send_set_cells_serialized_async(mutator, cells, flush)
        self.recv_set_cells_serialized_async()

    def send_set_cells_serialized_async(self, mutator, cells, flush):
        self._oprot.writeMessageBegin('set_cells_serialized_async', TMessageType.CALL, self._seqid)
        args = set_cells_serialized_async_args()
        args.mutator = mutator
        args.cells = cells
        args.flush = flush
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_cells_serialized_async(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_cells_serialized_async_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def async_mutator_flush(self, mutator):
        """
        Flush mutator buffers

        Parameters:
         - mutator

        """
        self.send_async_mutator_flush(mutator)
        self.recv_async_mutator_flush()

    def send_async_mutator_flush(self, mutator):
        self._oprot.writeMessageBegin('async_mutator_flush', TMessageType.CALL, self._seqid)
        args = async_mutator_flush_args()
        args.mutator = mutator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_async_mutator_flush(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = async_mutator_flush_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def flush_mutator_async(self, mutator):
        """
        Parameters:
         - mutator

        """
        self.send_flush_mutator_async(mutator)
        self.recv_flush_mutator_async()

    def send_flush_mutator_async(self, mutator):
        self._oprot.writeMessageBegin('flush_mutator_async', TMessageType.CALL, self._seqid)
        args = flush_mutator_async_args()
        args.mutator = mutator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_flush_mutator_async(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = flush_mutator_async_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def namespace_exists(self, ns):
        """
        Check if the namespace exists

        @param ns - namespace name

        @return true if ns exists, false ow

        Parameters:
         - ns

        """
        self.send_namespace_exists(ns)
        return self.recv_namespace_exists()

    def send_namespace_exists(self, ns):
        self._oprot.writeMessageBegin('namespace_exists', TMessageType.CALL, self._seqid)
        args = namespace_exists_args()
        args.ns = ns
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_namespace_exists(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = namespace_exists_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "namespace_exists failed: unknown result")

    def exists_namespace(self, ns):
        """
        Parameters:
         - ns

        """
        self.send_exists_namespace(ns)
        return self.recv_exists_namespace()

    def send_exists_namespace(self, ns):
        self._oprot.writeMessageBegin('exists_namespace', TMessageType.CALL, self._seqid)
        args = exists_namespace_args()
        args.ns = ns
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_exists_namespace(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = exists_namespace_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "exists_namespace failed: unknown result")

    def exists_table(self, ns, name):
        """
        Check if the table exists

        @param ns - namespace id

        @param name - table name

        @return true if table exists, false ow

        Parameters:
         - ns
         - name

        """
        self.send_exists_table(ns, name)
        return self.recv_exists_table()

    def send_exists_table(self, ns, name):
        self._oprot.writeMessageBegin('exists_table', TMessageType.CALL, self._seqid)
        args = exists_table_args()
        args.ns = ns
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_exists_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = exists_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "exists_table failed: unknown result")

    def table_exists(self, ns, name):
        """
        Parameters:
         - ns
         - name

        """
        self.send_table_exists(ns, name)
        return self.recv_table_exists()

    def send_table_exists(self, ns, name):
        self._oprot.writeMessageBegin('table_exists', TMessageType.CALL, self._seqid)
        args = table_exists_args()
        args.ns = ns
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_table_exists(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = table_exists_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "table_exists failed: unknown result")

    def table_get_id(self, ns, table_name):
        """
        Get the id of a table

        @param ns - namespace id

        @param table_name - table name

        @return table id string

        Parameters:
         - ns
         - table_name

        """
        self.send_table_get_id(ns, table_name)
        return self.recv_table_get_id()

    def send_table_get_id(self, ns, table_name):
        self._oprot.writeMessageBegin('table_get_id', TMessageType.CALL, self._seqid)
        args = table_get_id_args()
        args.ns = ns
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_table_get_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = table_get_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "table_get_id failed: unknown result")

    def get_table_id(self, ns, table_name):
        """
        Parameters:
         - ns
         - table_name

        """
        self.send_get_table_id(ns, table_name)
        return self.recv_get_table_id()

    def send_get_table_id(self, ns, table_name):
        self._oprot.writeMessageBegin('get_table_id', TMessageType.CALL, self._seqid)
        args = get_table_id_args()
        args.ns = ns
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_id failed: unknown result")

    def table_get_schema_str(self, ns, table_name):
        """
        Get the schema of a table as a string (that can be used with create_table)

        @param ns - namespace id

        @param table_name - table name

        @return schema string (in xml)

        Parameters:
         - ns
         - table_name

        """
        self.send_table_get_schema_str(ns, table_name)
        return self.recv_table_get_schema_str()

    def send_table_get_schema_str(self, ns, table_name):
        self._oprot.writeMessageBegin('table_get_schema_str', TMessageType.CALL, self._seqid)
        args = table_get_schema_str_args()
        args.ns = ns
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_table_get_schema_str(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = table_get_schema_str_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "table_get_schema_str failed: unknown result")

    def get_schema_str(self, ns, table_name):
        """
        Parameters:
         - ns
         - table_name

        """
        self.send_get_schema_str(ns, table_name)
        return self.recv_get_schema_str()

    def send_get_schema_str(self, ns, table_name):
        self._oprot.writeMessageBegin('get_schema_str', TMessageType.CALL, self._seqid)
        args = get_schema_str_args()
        args.ns = ns
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schema_str(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schema_str_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema_str failed: unknown result")

    def table_get_schema_str_with_ids(self, ns, table_name):
        """
        Get the schema of a table as a string along with column family ids

        @param ns - namespace id

        @param table_name - table name

        @return schema string (in xml)

        Parameters:
         - ns
         - table_name

        """
        self.send_table_get_schema_str_with_ids(ns, table_name)
        return self.recv_table_get_schema_str_with_ids()

    def send_table_get_schema_str_with_ids(self, ns, table_name):
        self._oprot.writeMessageBegin('table_get_schema_str_with_ids', TMessageType.CALL, self._seqid)
        args = table_get_schema_str_with_ids_args()
        args.ns = ns
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_table_get_schema_str_with_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = table_get_schema_str_with_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "table_get_schema_str_with_ids failed: unknown result")

    def get_schema_str_with_ids(self, ns, table_name):
        """
        Parameters:
         - ns
         - table_name

        """
        self.send_get_schema_str_with_ids(ns, table_name)
        return self.recv_get_schema_str_with_ids()

    def send_get_schema_str_with_ids(self, ns, table_name):
        self._oprot.writeMessageBegin('get_schema_str_with_ids', TMessageType.CALL, self._seqid)
        args = get_schema_str_with_ids_args()
        args.ns = ns
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schema_str_with_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schema_str_with_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema_str_with_ids failed: unknown result")

    def table_get_schema(self, ns, table_name):
        """
        Get the schema of a table as a string (that can be used with create_table)
          
        @param ns - namespace id

        @param table_name - table name

        @return schema object describing a table

        Parameters:
         - ns
         - table_name

        """
        self.send_table_get_schema(ns, table_name)
        return self.recv_table_get_schema()

    def send_table_get_schema(self, ns, table_name):
        self._oprot.writeMessageBegin('table_get_schema', TMessageType.CALL, self._seqid)
        args = table_get_schema_args()
        args.ns = ns
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_table_get_schema(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = table_get_schema_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "table_get_schema failed: unknown result")

    def get_schema(self, ns, table_name):
        """
        Parameters:
         - ns
         - table_name

        """
        self.send_get_schema(ns, table_name)
        return self.recv_get_schema()

    def send_get_schema(self, ns, table_name):
        self._oprot.writeMessageBegin('get_schema', TMessageType.CALL, self._seqid)
        args = get_schema_args()
        args.ns = ns
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schema(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schema_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema failed: unknown result")

    def get_tables(self, ns):
        """
        Get a list of table names in the namespace

        @param ns - namespace id

        @return a list of table names

        Parameters:
         - ns

        """
        self.send_get_tables(ns)
        return self.recv_get_tables()

    def send_get_tables(self, ns):
        self._oprot.writeMessageBegin('get_tables', TMessageType.CALL, self._seqid)
        args = get_tables_args()
        args.ns = ns
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tables(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tables_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tables failed: unknown result")

    def namespace_get_listing(self, ns):
        """
        Get a list of namespaces and table names table names in the namespace

        @param ns - namespace

        @return a list of table names

        Parameters:
         - ns

        """
        self.send_namespace_get_listing(ns)
        return self.recv_namespace_get_listing()

    def send_namespace_get_listing(self, ns):
        self._oprot.writeMessageBegin('namespace_get_listing', TMessageType.CALL, self._seqid)
        args = namespace_get_listing_args()
        args.ns = ns
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_namespace_get_listing(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = namespace_get_listing_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "namespace_get_listing failed: unknown result")

    def get_listing(self, ns):
        """
        Parameters:
         - ns

        """
        self.send_get_listing(ns)
        return self.recv_get_listing()

    def send_get_listing(self, ns):
        self._oprot.writeMessageBegin('get_listing', TMessageType.CALL, self._seqid)
        args = get_listing_args()
        args.ns = ns
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_listing(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_listing_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_listing failed: unknown result")

    def table_get_splits(self, ns, table_name):
        """
        Get a list of table splits

        @param ns - namespace id

        @param table_name - table name

        @return a list of table names

        Parameters:
         - ns
         - table_name

        """
        self.send_table_get_splits(ns, table_name)
        return self.recv_table_get_splits()

    def send_table_get_splits(self, ns, table_name):
        self._oprot.writeMessageBegin('table_get_splits', TMessageType.CALL, self._seqid)
        args = table_get_splits_args()
        args.ns = ns
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_table_get_splits(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = table_get_splits_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "table_get_splits failed: unknown result")

    def get_table_splits(self, ns, table_name):
        """
        Parameters:
         - ns
         - table_name

        """
        self.send_get_table_splits(ns, table_name)
        return self.recv_get_table_splits()

    def send_get_table_splits(self, ns, table_name):
        self._oprot.writeMessageBegin('get_table_splits', TMessageType.CALL, self._seqid)
        args = get_table_splits_args()
        args.ns = ns
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_splits(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_splits_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_splits failed: unknown result")

    def namespace_drop(self, ns, if_exists):
        """
        Drop a namespace

        @param ns - namespace name

        @param if_exists - if true, don't barf if the table doesn't exist

        Parameters:
         - ns
         - if_exists

        """
        self.send_namespace_drop(ns, if_exists)
        self.recv_namespace_drop()

    def send_namespace_drop(self, ns, if_exists):
        self._oprot.writeMessageBegin('namespace_drop', TMessageType.CALL, self._seqid)
        args = namespace_drop_args()
        args.ns = ns
        args.if_exists = if_exists
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_namespace_drop(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = namespace_drop_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def drop_namespace(self, ns, if_exists):
        """
        Parameters:
         - ns
         - if_exists

        """
        self.send_drop_namespace(ns, if_exists)
        self.recv_drop_namespace()

    def send_drop_namespace(self, ns, if_exists):
        self._oprot.writeMessageBegin('drop_namespace', TMessageType.CALL, self._seqid)
        args = drop_namespace_args()
        args.ns = ns
        args.if_exists = if_exists
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_namespace(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_namespace_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def rename_table(self, ns, name, new_name):
        """
        Rename a table

        @param ns - namespace id

        @param name - current table name

        @param new_name - new table name

        Parameters:
         - ns
         - name
         - new_name

        """
        self.send_rename_table(ns, name, new_name)
        self.recv_rename_table()

    def send_rename_table(self, ns, name, new_name):
        self._oprot.writeMessageBegin('rename_table', TMessageType.CALL, self._seqid)
        args = rename_table_args()
        args.ns = ns
        args.name = name
        args.new_name = new_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rename_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rename_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def table_rename(self, ns, name, new_name):
        """
        Parameters:
         - ns
         - name
         - new_name

        """
        self.send_table_rename(ns, name, new_name)
        self.recv_table_rename()

    def send_table_rename(self, ns, name, new_name):
        self._oprot.writeMessageBegin('table_rename', TMessageType.CALL, self._seqid)
        args = table_rename_args()
        args.ns = ns
        args.name = name
        args.new_name = new_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_table_rename(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = table_rename_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def drop_table(self, ns, name, if_exists):
        """
        Drop a table

        @param ns - namespace id

        @param name - table name

        @param if_exists - if true, don't barf if the table doesn't exist

        Parameters:
         - ns
         - name
         - if_exists

        """
        self.send_drop_table(ns, name, if_exists)
        self.recv_drop_table()

    def send_drop_table(self, ns, name, if_exists):
        self._oprot.writeMessageBegin('drop_table', TMessageType.CALL, self._seqid)
        args = drop_table_args()
        args.ns = ns
        args.name = name
        args.if_exists = if_exists
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def table_drop(self, ns, name, if_exists):
        """
        Parameters:
         - ns
         - name
         - if_exists

        """
        self.send_table_drop(ns, name, if_exists)
        self.recv_table_drop()

    def send_table_drop(self, ns, name, if_exists):
        self._oprot.writeMessageBegin('table_drop', TMessageType.CALL, self._seqid)
        args = table_drop_args()
        args.ns = ns
        args.name = name
        args.if_exists = if_exists
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_table_drop(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = table_drop_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def generate_guid(self):
        """
        Generate a GUID

        GUIDs are globally unique. The generated string is 36 bytes long and
        has a format similar to "9cf7da31-307a-4bef-b65e-19fb05aa57d8".

        """
        self.send_generate_guid()
        return self.recv_generate_guid()

    def send_generate_guid(self):
        self._oprot.writeMessageBegin('generate_guid', TMessageType.CALL, self._seqid)
        args = generate_guid_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_generate_guid(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = generate_guid_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "generate_guid failed: unknown result")

    def create_cell_unique(self, ns, table_name, key, value):
        """
        Inserts a unique value into a table

        This function inserts a unique value into a table. The table must be
        created with TIME_ORDER DESC, MAX_VERSIONS 1 (although the latter is
        optional).

        If the value is empty then a new GUID will be assigned
        (using @a generate_guid).

        @param ns - namespace id
        @param table_name - table name
        @param key - the Key of the value
        @param value - the unique value. Can be empty; in this case a new
           guid will be generated internally

        @return the inserted unique value (which is identical to the @a value
           parameter or a new guid, if value is empty)

        Parameters:
         - ns
         - table_name
         - key
         - value

        """
        self.send_create_cell_unique(ns, table_name, key, value)
        return self.recv_create_cell_unique()

    def send_create_cell_unique(self, ns, table_name, key, value):
        self._oprot.writeMessageBegin('create_cell_unique', TMessageType.CALL, self._seqid)
        args = create_cell_unique_args()
        args.ns = ns
        args.table_name = table_name
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_cell_unique(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_cell_unique_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_cell_unique failed: unknown result")

    def error_get_text(self, error_code):
        """
        Retrieves a descriptive error string from an error code

        @param error_code - the numeric error code

        @return the descriptive string, or "ERROR NOT REGISTERED" if the error
           code is unknown

        Parameters:
         - error_code

        """
        self.send_error_get_text(error_code)
        return self.recv_error_get_text()

    def send_error_get_text(self, error_code):
        self._oprot.writeMessageBegin('error_get_text', TMessageType.CALL, self._seqid)
        args = error_get_text_args()
        args.error_code = error_code
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_error_get_text(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = error_get_text_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "error_get_text failed: unknown result")

    def status(self):
        """
        Status check.
        @return Status information

        """
        self.send_status()
        return self.recv_status()

    def send_status(self):
        self._oprot.writeMessageBegin('status', TMessageType.CALL, self._seqid)
        args = status_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "status failed: unknown result")

    def shutdown(self):
        """
        Shutdown broker.

        """
        self.send_shutdown()
        self.recv_shutdown()

    def send_shutdown(self):
        self._oprot.writeMessageBegin('shutdown', TMessageType.CALL, self._seqid)
        args = shutdown_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_shutdown(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = shutdown_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["namespace_create"] = Processor.process_namespace_create
        self._processMap["create_namespace"] = Processor.process_create_namespace
        self._processMap["table_create"] = Processor.process_table_create
        self._processMap["table_alter"] = Processor.process_table_alter
        self._processMap["refresh_table"] = Processor.process_refresh_table
        self._processMap["namespace_open"] = Processor.process_namespace_open
        self._processMap["open_namespace"] = Processor.process_open_namespace
        self._processMap["namespace_close"] = Processor.process_namespace_close
        self._processMap["close_namespace"] = Processor.process_close_namespace
        self._processMap["future_open"] = Processor.process_future_open
        self._processMap["open_future"] = Processor.process_open_future
        self._processMap["future_cancel"] = Processor.process_future_cancel
        self._processMap["cancel_future"] = Processor.process_cancel_future
        self._processMap["future_get_result"] = Processor.process_future_get_result
        self._processMap["get_future_result"] = Processor.process_get_future_result
        self._processMap["future_get_result_as_arrays"] = Processor.process_future_get_result_as_arrays
        self._processMap["get_future_result_as_arrays"] = Processor.process_get_future_result_as_arrays
        self._processMap["future_get_result_serialized"] = Processor.process_future_get_result_serialized
        self._processMap["get_future_result_serialized"] = Processor.process_get_future_result_serialized
        self._processMap["future_is_empty"] = Processor.process_future_is_empty
        self._processMap["future_is_full"] = Processor.process_future_is_full
        self._processMap["future_is_cancelled"] = Processor.process_future_is_cancelled
        self._processMap["future_has_outstanding"] = Processor.process_future_has_outstanding
        self._processMap["future_close"] = Processor.process_future_close
        self._processMap["close_future"] = Processor.process_close_future
        self._processMap["scanner_open"] = Processor.process_scanner_open
        self._processMap["open_scanner"] = Processor.process_open_scanner
        self._processMap["async_scanner_open"] = Processor.process_async_scanner_open
        self._processMap["open_scanner_async"] = Processor.process_open_scanner_async
        self._processMap["scanner_close"] = Processor.process_scanner_close
        self._processMap["close_scanner"] = Processor.process_close_scanner
        self._processMap["async_scanner_cancel"] = Processor.process_async_scanner_cancel
        self._processMap["cancel_scanner_async"] = Processor.process_cancel_scanner_async
        self._processMap["async_scanner_close"] = Processor.process_async_scanner_close
        self._processMap["close_scanner_async"] = Processor.process_close_scanner_async
        self._processMap["scanner_get_cells"] = Processor.process_scanner_get_cells
        self._processMap["next_cells"] = Processor.process_next_cells
        self._processMap["scanner_get_cells_as_arrays"] = Processor.process_scanner_get_cells_as_arrays
        self._processMap["next_cells_as_arrays"] = Processor.process_next_cells_as_arrays
        self._processMap["scanner_get_cells_serialized"] = Processor.process_scanner_get_cells_serialized
        self._processMap["next_cells_serialized"] = Processor.process_next_cells_serialized
        self._processMap["scanner_get_row"] = Processor.process_scanner_get_row
        self._processMap["next_row"] = Processor.process_next_row
        self._processMap["scanner_get_row_as_arrays"] = Processor.process_scanner_get_row_as_arrays
        self._processMap["next_row_as_arrays"] = Processor.process_next_row_as_arrays
        self._processMap["scanner_get_row_serialized"] = Processor.process_scanner_get_row_serialized
        self._processMap["next_row_serialized"] = Processor.process_next_row_serialized
        self._processMap["get_row"] = Processor.process_get_row
        self._processMap["get_row_as_arrays"] = Processor.process_get_row_as_arrays
        self._processMap["get_row_serialized"] = Processor.process_get_row_serialized
        self._processMap["get_cell"] = Processor.process_get_cell
        self._processMap["get_cells"] = Processor.process_get_cells
        self._processMap["get_cells_as_arrays"] = Processor.process_get_cells_as_arrays
        self._processMap["get_cells_serialized"] = Processor.process_get_cells_serialized
        self._processMap["shared_mutator_refresh"] = Processor.process_shared_mutator_refresh
        self._processMap["refresh_shared_mutator"] = Processor.process_refresh_shared_mutator
        self._processMap["shared_mutator_set_cells"] = Processor.process_shared_mutator_set_cells
        self._processMap["offer_cells"] = Processor.process_offer_cells
        self._processMap["shared_mutator_set_cells_as_arrays"] = Processor.process_shared_mutator_set_cells_as_arrays
        self._processMap["offer_cells_as_arrays"] = Processor.process_offer_cells_as_arrays
        self._processMap["shared_mutator_set_cell"] = Processor.process_shared_mutator_set_cell
        self._processMap["offer_cell"] = Processor.process_offer_cell
        self._processMap["shared_mutator_set_cell_as_array"] = Processor.process_shared_mutator_set_cell_as_array
        self._processMap["offer_cell_as_array"] = Processor.process_offer_cell_as_array
        self._processMap["mutator_open"] = Processor.process_mutator_open
        self._processMap["open_mutator"] = Processor.process_open_mutator
        self._processMap["async_mutator_open"] = Processor.process_async_mutator_open
        self._processMap["open_mutator_async"] = Processor.process_open_mutator_async
        self._processMap["mutator_close"] = Processor.process_mutator_close
        self._processMap["close_mutator"] = Processor.process_close_mutator
        self._processMap["async_mutator_cancel"] = Processor.process_async_mutator_cancel
        self._processMap["cancel_mutator_async"] = Processor.process_cancel_mutator_async
        self._processMap["async_mutator_close"] = Processor.process_async_mutator_close
        self._processMap["close_mutator_async"] = Processor.process_close_mutator_async
        self._processMap["mutator_set_cell"] = Processor.process_mutator_set_cell
        self._processMap["set_cell"] = Processor.process_set_cell
        self._processMap["mutator_set_cell_as_array"] = Processor.process_mutator_set_cell_as_array
        self._processMap["set_cell_as_array"] = Processor.process_set_cell_as_array
        self._processMap["mutator_set_cells"] = Processor.process_mutator_set_cells
        self._processMap["set_cells"] = Processor.process_set_cells
        self._processMap["mutator_set_cells_as_arrays"] = Processor.process_mutator_set_cells_as_arrays
        self._processMap["set_cells_as_arrays"] = Processor.process_set_cells_as_arrays
        self._processMap["mutator_set_cells_serialized"] = Processor.process_mutator_set_cells_serialized
        self._processMap["set_cells_serialized"] = Processor.process_set_cells_serialized
        self._processMap["mutator_flush"] = Processor.process_mutator_flush
        self._processMap["flush_mutator"] = Processor.process_flush_mutator
        self._processMap["async_mutator_set_cell"] = Processor.process_async_mutator_set_cell
        self._processMap["set_cell_async"] = Processor.process_set_cell_async
        self._processMap["async_mutator_set_cell_as_array"] = Processor.process_async_mutator_set_cell_as_array
        self._processMap["set_cell_as_array_async"] = Processor.process_set_cell_as_array_async
        self._processMap["async_mutator_set_cells"] = Processor.process_async_mutator_set_cells
        self._processMap["set_cells_async"] = Processor.process_set_cells_async
        self._processMap["async_mutator_set_cells_as_arrays"] = Processor.process_async_mutator_set_cells_as_arrays
        self._processMap["set_cells_as_arrays_async"] = Processor.process_set_cells_as_arrays_async
        self._processMap["async_mutator_set_cells_serialized"] = Processor.process_async_mutator_set_cells_serialized
        self._processMap["set_cells_serialized_async"] = Processor.process_set_cells_serialized_async
        self._processMap["async_mutator_flush"] = Processor.process_async_mutator_flush
        self._processMap["flush_mutator_async"] = Processor.process_flush_mutator_async
        self._processMap["namespace_exists"] = Processor.process_namespace_exists
        self._processMap["exists_namespace"] = Processor.process_exists_namespace
        self._processMap["exists_table"] = Processor.process_exists_table
        self._processMap["table_exists"] = Processor.process_table_exists
        self._processMap["table_get_id"] = Processor.process_table_get_id
        self._processMap["get_table_id"] = Processor.process_get_table_id
        self._processMap["table_get_schema_str"] = Processor.process_table_get_schema_str
        self._processMap["get_schema_str"] = Processor.process_get_schema_str
        self._processMap["table_get_schema_str_with_ids"] = Processor.process_table_get_schema_str_with_ids
        self._processMap["get_schema_str_with_ids"] = Processor.process_get_schema_str_with_ids
        self._processMap["table_get_schema"] = Processor.process_table_get_schema
        self._processMap["get_schema"] = Processor.process_get_schema
        self._processMap["get_tables"] = Processor.process_get_tables
        self._processMap["namespace_get_listing"] = Processor.process_namespace_get_listing
        self._processMap["get_listing"] = Processor.process_get_listing
        self._processMap["table_get_splits"] = Processor.process_table_get_splits
        self._processMap["get_table_splits"] = Processor.process_get_table_splits
        self._processMap["namespace_drop"] = Processor.process_namespace_drop
        self._processMap["drop_namespace"] = Processor.process_drop_namespace
        self._processMap["rename_table"] = Processor.process_rename_table
        self._processMap["table_rename"] = Processor.process_table_rename
        self._processMap["drop_table"] = Processor.process_drop_table
        self._processMap["table_drop"] = Processor.process_table_drop
        self._processMap["generate_guid"] = Processor.process_generate_guid
        self._processMap["create_cell_unique"] = Processor.process_create_cell_unique
        self._processMap["error_get_text"] = Processor.process_error_get_text
        self._processMap["status"] = Processor.process_status
        self._processMap["shutdown"] = Processor.process_shutdown

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_namespace_create(self, seqid, iprot, oprot):
        args = namespace_create_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = namespace_create_result()
        try:
            self._handler.namespace_create(args.ns)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("namespace_create", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_namespace(self, seqid, iprot, oprot):
        args = create_namespace_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_namespace_result()
        try:
            self._handler.create_namespace(args.ns)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_namespace", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_table_create(self, seqid, iprot, oprot):
        args = table_create_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = table_create_result()
        try:
            self._handler.table_create(args.ns, args.table_name, args.schema)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("table_create", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_table_alter(self, seqid, iprot, oprot):
        args = table_alter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = table_alter_result()
        try:
            self._handler.table_alter(args.ns, args.table_name, args.schema)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("table_alter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_refresh_table(self, seqid, iprot, oprot):
        args = refresh_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = refresh_table_result()
        try:
            self._handler.refresh_table(args.ns, args.table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("refresh_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_namespace_open(self, seqid, iprot, oprot):
        args = namespace_open_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = namespace_open_result()
        try:
            result.success = self._handler.namespace_open(args.ns)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("namespace_open", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_open_namespace(self, seqid, iprot, oprot):
        args = open_namespace_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = open_namespace_result()
        try:
            result.success = self._handler.open_namespace(args.ns)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("open_namespace", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_namespace_close(self, seqid, iprot, oprot):
        args = namespace_close_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = namespace_close_result()
        try:
            self._handler.namespace_close(args.ns)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("namespace_close", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_close_namespace(self, seqid, iprot, oprot):
        args = close_namespace_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = close_namespace_result()
        try:
            self._handler.close_namespace(args.ns)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("close_namespace", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_future_open(self, seqid, iprot, oprot):
        args = future_open_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = future_open_result()
        try:
            result.success = self._handler.future_open(args.capacity)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("future_open", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_open_future(self, seqid, iprot, oprot):
        args = open_future_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = open_future_result()
        try:
            result.success = self._handler.open_future(args.capacity)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("open_future", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_future_cancel(self, seqid, iprot, oprot):
        args = future_cancel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = future_cancel_result()
        try:
            self._handler.future_cancel(args.ff)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("future_cancel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cancel_future(self, seqid, iprot, oprot):
        args = cancel_future_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cancel_future_result()
        try:
            self._handler.cancel_future(args.ff)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cancel_future", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_future_get_result(self, seqid, iprot, oprot):
        args = future_get_result_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = future_get_result_result()
        try:
            result.success = self._handler.future_get_result(args.ff, args.timeout_millis)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("future_get_result", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_future_result(self, seqid, iprot, oprot):
        args = get_future_result_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_future_result_result()
        try:
            result.success = self._handler.get_future_result(args.ff, args.timeout_millis)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_future_result", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_future_get_result_as_arrays(self, seqid, iprot, oprot):
        args = future_get_result_as_arrays_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = future_get_result_as_arrays_result()
        try:
            result.success = self._handler.future_get_result_as_arrays(args.ff, args.timeout_millis)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("future_get_result_as_arrays", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_future_result_as_arrays(self, seqid, iprot, oprot):
        args = get_future_result_as_arrays_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_future_result_as_arrays_result()
        try:
            result.success = self._handler.get_future_result_as_arrays(args.ff, args.timeout_millis)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_future_result_as_arrays", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_future_get_result_serialized(self, seqid, iprot, oprot):
        args = future_get_result_serialized_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = future_get_result_serialized_result()
        try:
            result.success = self._handler.future_get_result_serialized(args.ff, args.timeout_millis)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("future_get_result_serialized", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_future_result_serialized(self, seqid, iprot, oprot):
        args = get_future_result_serialized_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_future_result_serialized_result()
        try:
            result.success = self._handler.get_future_result_serialized(args.ff, args.timeout_millis)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_future_result_serialized", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_future_is_empty(self, seqid, iprot, oprot):
        args = future_is_empty_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = future_is_empty_result()
        try:
            result.success = self._handler.future_is_empty(args.ff)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("future_is_empty", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_future_is_full(self, seqid, iprot, oprot):
        args = future_is_full_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = future_is_full_result()
        try:
            result.success = self._handler.future_is_full(args.ff)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("future_is_full", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_future_is_cancelled(self, seqid, iprot, oprot):
        args = future_is_cancelled_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = future_is_cancelled_result()
        try:
            result.success = self._handler.future_is_cancelled(args.ff)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("future_is_cancelled", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_future_has_outstanding(self, seqid, iprot, oprot):
        args = future_has_outstanding_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = future_has_outstanding_result()
        try:
            result.success = self._handler.future_has_outstanding(args.ff)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("future_has_outstanding", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_future_close(self, seqid, iprot, oprot):
        args = future_close_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = future_close_result()
        try:
            self._handler.future_close(args.ff)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("future_close", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_close_future(self, seqid, iprot, oprot):
        args = close_future_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = close_future_result()
        try:
            self._handler.close_future(args.ff)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("close_future", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_scanner_open(self, seqid, iprot, oprot):
        args = scanner_open_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = scanner_open_result()
        try:
            result.success = self._handler.scanner_open(args.ns, args.table_name, args.scan_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("scanner_open", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_open_scanner(self, seqid, iprot, oprot):
        args = open_scanner_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = open_scanner_result()
        try:
            result.success = self._handler.open_scanner(args.ns, args.table_name, args.scan_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("open_scanner", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_async_scanner_open(self, seqid, iprot, oprot):
        args = async_scanner_open_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = async_scanner_open_result()
        try:
            result.success = self._handler.async_scanner_open(args.ns, args.table_name, args.future, args.scan_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("async_scanner_open", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_open_scanner_async(self, seqid, iprot, oprot):
        args = open_scanner_async_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = open_scanner_async_result()
        try:
            result.success = self._handler.open_scanner_async(args.ns, args.table_name, args.future, args.scan_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("open_scanner_async", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_scanner_close(self, seqid, iprot, oprot):
        args = scanner_close_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = scanner_close_result()
        try:
            self._handler.scanner_close(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("scanner_close", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_close_scanner(self, seqid, iprot, oprot):
        args = close_scanner_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = close_scanner_result()
        try:
            self._handler.close_scanner(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("close_scanner", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_async_scanner_cancel(self, seqid, iprot, oprot):
        args = async_scanner_cancel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = async_scanner_cancel_result()
        try:
            self._handler.async_scanner_cancel(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("async_scanner_cancel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cancel_scanner_async(self, seqid, iprot, oprot):
        args = cancel_scanner_async_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cancel_scanner_async_result()
        try:
            self._handler.cancel_scanner_async(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cancel_scanner_async", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_async_scanner_close(self, seqid, iprot, oprot):
        args = async_scanner_close_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = async_scanner_close_result()
        try:
            self._handler.async_scanner_close(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("async_scanner_close", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_close_scanner_async(self, seqid, iprot, oprot):
        args = close_scanner_async_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = close_scanner_async_result()
        try:
            self._handler.close_scanner_async(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("close_scanner_async", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_scanner_get_cells(self, seqid, iprot, oprot):
        args = scanner_get_cells_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = scanner_get_cells_result()
        try:
            result.success = self._handler.scanner_get_cells(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("scanner_get_cells", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_next_cells(self, seqid, iprot, oprot):
        args = next_cells_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = next_cells_result()
        try:
            result.success = self._handler.next_cells(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("next_cells", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_scanner_get_cells_as_arrays(self, seqid, iprot, oprot):
        args = scanner_get_cells_as_arrays_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = scanner_get_cells_as_arrays_result()
        try:
            result.success = self._handler.scanner_get_cells_as_arrays(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("scanner_get_cells_as_arrays", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_next_cells_as_arrays(self, seqid, iprot, oprot):
        args = next_cells_as_arrays_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = next_cells_as_arrays_result()
        try:
            result.success = self._handler.next_cells_as_arrays(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("next_cells_as_arrays", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_scanner_get_cells_serialized(self, seqid, iprot, oprot):
        args = scanner_get_cells_serialized_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = scanner_get_cells_serialized_result()
        try:
            result.success = self._handler.scanner_get_cells_serialized(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("scanner_get_cells_serialized", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_next_cells_serialized(self, seqid, iprot, oprot):
        args = next_cells_serialized_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = next_cells_serialized_result()
        try:
            result.success = self._handler.next_cells_serialized(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("next_cells_serialized", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_scanner_get_row(self, seqid, iprot, oprot):
        args = scanner_get_row_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = scanner_get_row_result()
        try:
            result.success = self._handler.scanner_get_row(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("scanner_get_row", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_next_row(self, seqid, iprot, oprot):
        args = next_row_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = next_row_result()
        try:
            result.success = self._handler.next_row(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("next_row", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_scanner_get_row_as_arrays(self, seqid, iprot, oprot):
        args = scanner_get_row_as_arrays_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = scanner_get_row_as_arrays_result()
        try:
            result.success = self._handler.scanner_get_row_as_arrays(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("scanner_get_row_as_arrays", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_next_row_as_arrays(self, seqid, iprot, oprot):
        args = next_row_as_arrays_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = next_row_as_arrays_result()
        try:
            result.success = self._handler.next_row_as_arrays(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("next_row_as_arrays", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_scanner_get_row_serialized(self, seqid, iprot, oprot):
        args = scanner_get_row_serialized_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = scanner_get_row_serialized_result()
        try:
            result.success = self._handler.scanner_get_row_serialized(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("scanner_get_row_serialized", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_next_row_serialized(self, seqid, iprot, oprot):
        args = next_row_serialized_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = next_row_serialized_result()
        try:
            result.success = self._handler.next_row_serialized(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("next_row_serialized", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_row(self, seqid, iprot, oprot):
        args = get_row_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_row_result()
        try:
            result.success = self._handler.get_row(args.ns, args.table_name, args.row)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_row", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_row_as_arrays(self, seqid, iprot, oprot):
        args = get_row_as_arrays_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_row_as_arrays_result()
        try:
            result.success = self._handler.get_row_as_arrays(args.ns, args.name, args.row)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_row_as_arrays", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_row_serialized(self, seqid, iprot, oprot):
        args = get_row_serialized_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_row_serialized_result()
        try:
            result.success = self._handler.get_row_serialized(args.ns, args.table_name, args.row)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_row_serialized", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_cell(self, seqid, iprot, oprot):
        args = get_cell_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_cell_result()
        try:
            result.success = self._handler.get_cell(args.ns, args.table_name, args.row, args.column)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_cell", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_cells(self, seqid, iprot, oprot):
        args = get_cells_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_cells_result()
        try:
            result.success = self._handler.get_cells(args.ns, args.table_name, args.scan_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_cells", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_cells_as_arrays(self, seqid, iprot, oprot):
        args = get_cells_as_arrays_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_cells_as_arrays_result()
        try:
            result.success = self._handler.get_cells_as_arrays(args.ns, args.name, args.scan_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_cells_as_arrays", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_cells_serialized(self, seqid, iprot, oprot):
        args = get_cells_serialized_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_cells_serialized_result()
        try:
            result.success = self._handler.get_cells_serialized(args.ns, args.name, args.scan_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_cells_serialized", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_shared_mutator_refresh(self, seqid, iprot, oprot):
        args = shared_mutator_refresh_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = shared_mutator_refresh_result()
        try:
            self._handler.shared_mutator_refresh(args.ns, args.table_name, args.mutate_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("shared_mutator_refresh", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_refresh_shared_mutator(self, seqid, iprot, oprot):
        args = refresh_shared_mutator_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = refresh_shared_mutator_result()
        try:
            self._handler.refresh_shared_mutator(args.ns, args.table_name, args.mutate_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("refresh_shared_mutator", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_shared_mutator_set_cells(self, seqid, iprot, oprot):
        args = shared_mutator_set_cells_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = shared_mutator_set_cells_result()
        try:
            self._handler.shared_mutator_set_cells(args.ns, args.table_name, args.mutate_spec, args.cells)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("shared_mutator_set_cells", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_offer_cells(self, seqid, iprot, oprot):
        args = offer_cells_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = offer_cells_result()
        try:
            self._handler.offer_cells(args.ns, args.table_name, args.mutate_spec, args.cells)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("offer_cells", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_shared_mutator_set_cells_as_arrays(self, seqid, iprot, oprot):
        args = shared_mutator_set_cells_as_arrays_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = shared_mutator_set_cells_as_arrays_result()
        try:
            self._handler.shared_mutator_set_cells_as_arrays(args.ns, args.table_name, args.mutate_spec, args.cells)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("shared_mutator_set_cells_as_arrays", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_offer_cells_as_arrays(self, seqid, iprot, oprot):
        args = offer_cells_as_arrays_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = offer_cells_as_arrays_result()
        try:
            self._handler.offer_cells_as_arrays(args.ns, args.table_name, args.mutate_spec, args.cells)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("offer_cells_as_arrays", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_shared_mutator_set_cell(self, seqid, iprot, oprot):
        args = shared_mutator_set_cell_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = shared_mutator_set_cell_result()
        try:
            self._handler.shared_mutator_set_cell(args.ns, args.table_name, args.mutate_spec, args.cell)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("shared_mutator_set_cell", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_offer_cell(self, seqid, iprot, oprot):
        args = offer_cell_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = offer_cell_result()
        try:
            self._handler.offer_cell(args.ns, args.table_name, args.mutate_spec, args.cell)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("offer_cell", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_shared_mutator_set_cell_as_array(self, seqid, iprot, oprot):
        args = shared_mutator_set_cell_as_array_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = shared_mutator_set_cell_as_array_result()
        try:
            self._handler.shared_mutator_set_cell_as_array(args.ns, args.table_name, args.mutate_spec, args.cell)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("shared_mutator_set_cell_as_array", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_offer_cell_as_array(self, seqid, iprot, oprot):
        args = offer_cell_as_array_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = offer_cell_as_array_result()
        try:
            self._handler.offer_cell_as_array(args.ns, args.table_name, args.mutate_spec, args.cell)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("offer_cell_as_array", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mutator_open(self, seqid, iprot, oprot):
        args = mutator_open_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mutator_open_result()
        try:
            result.success = self._handler.mutator_open(args.ns, args.table_name, args.flags, args.flush_interval)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mutator_open", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_open_mutator(self, seqid, iprot, oprot):
        args = open_mutator_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = open_mutator_result()
        try:
            result.success = self._handler.open_mutator(args.ns, args.table_name, args.flags, args.flush_interval)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("open_mutator", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_async_mutator_open(self, seqid, iprot, oprot):
        args = async_mutator_open_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = async_mutator_open_result()
        try:
            result.success = self._handler.async_mutator_open(args.ns, args.table_name, args.future, args.flags)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("async_mutator_open", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_open_mutator_async(self, seqid, iprot, oprot):
        args = open_mutator_async_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = open_mutator_async_result()
        try:
            result.success = self._handler.open_mutator_async(args.ns, args.table_name, args.future, args.flags)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("open_mutator_async", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mutator_close(self, seqid, iprot, oprot):
        args = mutator_close_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mutator_close_result()
        try:
            self._handler.mutator_close(args.mutator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mutator_close", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_close_mutator(self, seqid, iprot, oprot):
        args = close_mutator_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = close_mutator_result()
        try:
            self._handler.close_mutator(args.mutator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("close_mutator", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_async_mutator_cancel(self, seqid, iprot, oprot):
        args = async_mutator_cancel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = async_mutator_cancel_result()
        try:
            self._handler.async_mutator_cancel(args.mutator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("async_mutator_cancel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cancel_mutator_async(self, seqid, iprot, oprot):
        args = cancel_mutator_async_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cancel_mutator_async_result()
        try:
            self._handler.cancel_mutator_async(args.mutator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cancel_mutator_async", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_async_mutator_close(self, seqid, iprot, oprot):
        args = async_mutator_close_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = async_mutator_close_result()
        try:
            self._handler.async_mutator_close(args.mutator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("async_mutator_close", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_close_mutator_async(self, seqid, iprot, oprot):
        args = close_mutator_async_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = close_mutator_async_result()
        try:
            self._handler.close_mutator_async(args.mutator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("close_mutator_async", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mutator_set_cell(self, seqid, iprot, oprot):
        args = mutator_set_cell_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mutator_set_cell_result()
        try:
            self._handler.mutator_set_cell(args.mutator, args.cell)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mutator_set_cell", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_cell(self, seqid, iprot, oprot):
        args = set_cell_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_cell_result()
        try:
            self._handler.set_cell(args.ns, args.table_name, args.cell)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_cell", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mutator_set_cell_as_array(self, seqid, iprot, oprot):
        args = mutator_set_cell_as_array_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mutator_set_cell_as_array_result()
        try:
            self._handler.mutator_set_cell_as_array(args.mutator, args.cell)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mutator_set_cell_as_array", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_cell_as_array(self, seqid, iprot, oprot):
        args = set_cell_as_array_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_cell_as_array_result()
        try:
            self._handler.set_cell_as_array(args.ns, args.table_name, args.cell)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_cell_as_array", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mutator_set_cells(self, seqid, iprot, oprot):
        args = mutator_set_cells_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mutator_set_cells_result()
        try:
            self._handler.mutator_set_cells(args.mutator, args.cells)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mutator_set_cells", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_cells(self, seqid, iprot, oprot):
        args = set_cells_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_cells_result()
        try:
            self._handler.set_cells(args.ns, args.table_name, args.cells)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_cells", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mutator_set_cells_as_arrays(self, seqid, iprot, oprot):
        args = mutator_set_cells_as_arrays_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mutator_set_cells_as_arrays_result()
        try:
            self._handler.mutator_set_cells_as_arrays(args.mutator, args.cells)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mutator_set_cells_as_arrays", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_cells_as_arrays(self, seqid, iprot, oprot):
        args = set_cells_as_arrays_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_cells_as_arrays_result()
        try:
            self._handler.set_cells_as_arrays(args.ns, args.table_name, args.cells)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_cells_as_arrays", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mutator_set_cells_serialized(self, seqid, iprot, oprot):
        args = mutator_set_cells_serialized_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mutator_set_cells_serialized_result()
        try:
            self._handler.mutator_set_cells_serialized(args.mutator, args.cells, args.flush)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mutator_set_cells_serialized", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_cells_serialized(self, seqid, iprot, oprot):
        args = set_cells_serialized_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_cells_serialized_result()
        try:
            self._handler.set_cells_serialized(args.ns, args.table_name, args.cells)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_cells_serialized", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mutator_flush(self, seqid, iprot, oprot):
        args = mutator_flush_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mutator_flush_result()
        try:
            self._handler.mutator_flush(args.mutator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mutator_flush", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_flush_mutator(self, seqid, iprot, oprot):
        args = flush_mutator_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = flush_mutator_result()
        try:
            self._handler.flush_mutator(args.mutator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("flush_mutator", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_async_mutator_set_cell(self, seqid, iprot, oprot):
        args = async_mutator_set_cell_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = async_mutator_set_cell_result()
        try:
            self._handler.async_mutator_set_cell(args.mutator, args.cell)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("async_mutator_set_cell", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_cell_async(self, seqid, iprot, oprot):
        args = set_cell_async_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_cell_async_result()
        try:
            self._handler.set_cell_async(args.mutator, args.cell)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_cell_async", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_async_mutator_set_cell_as_array(self, seqid, iprot, oprot):
        args = async_mutator_set_cell_as_array_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = async_mutator_set_cell_as_array_result()
        try:
            self._handler.async_mutator_set_cell_as_array(args.mutator, args.cell)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("async_mutator_set_cell_as_array", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_cell_as_array_async(self, seqid, iprot, oprot):
        args = set_cell_as_array_async_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_cell_as_array_async_result()
        try:
            self._handler.set_cell_as_array_async(args.mutator, args.cell)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_cell_as_array_async", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_async_mutator_set_cells(self, seqid, iprot, oprot):
        args = async_mutator_set_cells_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = async_mutator_set_cells_result()
        try:
            self._handler.async_mutator_set_cells(args.mutator, args.cells)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("async_mutator_set_cells", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_cells_async(self, seqid, iprot, oprot):
        args = set_cells_async_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_cells_async_result()
        try:
            self._handler.set_cells_async(args.mutator, args.cells)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_cells_async", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_async_mutator_set_cells_as_arrays(self, seqid, iprot, oprot):
        args = async_mutator_set_cells_as_arrays_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = async_mutator_set_cells_as_arrays_result()
        try:
            self._handler.async_mutator_set_cells_as_arrays(args.mutator, args.cells)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("async_mutator_set_cells_as_arrays", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_cells_as_arrays_async(self, seqid, iprot, oprot):
        args = set_cells_as_arrays_async_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_cells_as_arrays_async_result()
        try:
            self._handler.set_cells_as_arrays_async(args.mutator, args.cells)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_cells_as_arrays_async", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_async_mutator_set_cells_serialized(self, seqid, iprot, oprot):
        args = async_mutator_set_cells_serialized_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = async_mutator_set_cells_serialized_result()
        try:
            self._handler.async_mutator_set_cells_serialized(args.mutator, args.cells, args.flush)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("async_mutator_set_cells_serialized", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_cells_serialized_async(self, seqid, iprot, oprot):
        args = set_cells_serialized_async_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_cells_serialized_async_result()
        try:
            self._handler.set_cells_serialized_async(args.mutator, args.cells, args.flush)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_cells_serialized_async", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_async_mutator_flush(self, seqid, iprot, oprot):
        args = async_mutator_flush_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = async_mutator_flush_result()
        try:
            self._handler.async_mutator_flush(args.mutator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("async_mutator_flush", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_flush_mutator_async(self, seqid, iprot, oprot):
        args = flush_mutator_async_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = flush_mutator_async_result()
        try:
            self._handler.flush_mutator_async(args.mutator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("flush_mutator_async", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_namespace_exists(self, seqid, iprot, oprot):
        args = namespace_exists_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = namespace_exists_result()
        try:
            result.success = self._handler.namespace_exists(args.ns)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("namespace_exists", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_exists_namespace(self, seqid, iprot, oprot):
        args = exists_namespace_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = exists_namespace_result()
        try:
            result.success = self._handler.exists_namespace(args.ns)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("exists_namespace", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_exists_table(self, seqid, iprot, oprot):
        args = exists_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = exists_table_result()
        try:
            result.success = self._handler.exists_table(args.ns, args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("exists_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_table_exists(self, seqid, iprot, oprot):
        args = table_exists_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = table_exists_result()
        try:
            result.success = self._handler.table_exists(args.ns, args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("table_exists", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_table_get_id(self, seqid, iprot, oprot):
        args = table_get_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = table_get_id_result()
        try:
            result.success = self._handler.table_get_id(args.ns, args.table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("table_get_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_id(self, seqid, iprot, oprot):
        args = get_table_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_id_result()
        try:
            result.success = self._handler.get_table_id(args.ns, args.table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_table_get_schema_str(self, seqid, iprot, oprot):
        args = table_get_schema_str_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = table_get_schema_str_result()
        try:
            result.success = self._handler.table_get_schema_str(args.ns, args.table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("table_get_schema_str", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schema_str(self, seqid, iprot, oprot):
        args = get_schema_str_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schema_str_result()
        try:
            result.success = self._handler.get_schema_str(args.ns, args.table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_schema_str", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_table_get_schema_str_with_ids(self, seqid, iprot, oprot):
        args = table_get_schema_str_with_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = table_get_schema_str_with_ids_result()
        try:
            result.success = self._handler.table_get_schema_str_with_ids(args.ns, args.table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("table_get_schema_str_with_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schema_str_with_ids(self, seqid, iprot, oprot):
        args = get_schema_str_with_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schema_str_with_ids_result()
        try:
            result.success = self._handler.get_schema_str_with_ids(args.ns, args.table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_schema_str_with_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_table_get_schema(self, seqid, iprot, oprot):
        args = table_get_schema_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = table_get_schema_result()
        try:
            result.success = self._handler.table_get_schema(args.ns, args.table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("table_get_schema", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schema(self, seqid, iprot, oprot):
        args = get_schema_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schema_result()
        try:
            result.success = self._handler.get_schema(args.ns, args.table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_schema", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tables(self, seqid, iprot, oprot):
        args = get_tables_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tables_result()
        try:
            result.success = self._handler.get_tables(args.ns)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tables", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_namespace_get_listing(self, seqid, iprot, oprot):
        args = namespace_get_listing_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = namespace_get_listing_result()
        try:
            result.success = self._handler.namespace_get_listing(args.ns)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("namespace_get_listing", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_listing(self, seqid, iprot, oprot):
        args = get_listing_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_listing_result()
        try:
            result.success = self._handler.get_listing(args.ns)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_listing", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_table_get_splits(self, seqid, iprot, oprot):
        args = table_get_splits_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = table_get_splits_result()
        try:
            result.success = self._handler.table_get_splits(args.ns, args.table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("table_get_splits", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_splits(self, seqid, iprot, oprot):
        args = get_table_splits_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_splits_result()
        try:
            result.success = self._handler.get_table_splits(args.ns, args.table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_splits", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_namespace_drop(self, seqid, iprot, oprot):
        args = namespace_drop_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = namespace_drop_result()
        try:
            self._handler.namespace_drop(args.ns, args.if_exists)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("namespace_drop", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_namespace(self, seqid, iprot, oprot):
        args = drop_namespace_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_namespace_result()
        try:
            self._handler.drop_namespace(args.ns, args.if_exists)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_namespace", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rename_table(self, seqid, iprot, oprot):
        args = rename_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rename_table_result()
        try:
            self._handler.rename_table(args.ns, args.name, args.new_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rename_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_table_rename(self, seqid, iprot, oprot):
        args = table_rename_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = table_rename_result()
        try:
            self._handler.table_rename(args.ns, args.name, args.new_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("table_rename", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_table(self, seqid, iprot, oprot):
        args = drop_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_table_result()
        try:
            self._handler.drop_table(args.ns, args.name, args.if_exists)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_table_drop(self, seqid, iprot, oprot):
        args = table_drop_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = table_drop_result()
        try:
            self._handler.table_drop(args.ns, args.name, args.if_exists)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("table_drop", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_generate_guid(self, seqid, iprot, oprot):
        args = generate_guid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = generate_guid_result()
        try:
            result.success = self._handler.generate_guid()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("generate_guid", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_cell_unique(self, seqid, iprot, oprot):
        args = create_cell_unique_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_cell_unique_result()
        try:
            result.success = self._handler.create_cell_unique(args.ns, args.table_name, args.key, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_cell_unique", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_error_get_text(self, seqid, iprot, oprot):
        args = error_get_text_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = error_get_text_result()
        try:
            result.success = self._handler.error_get_text(args.error_code)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("error_get_text", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_status(self, seqid, iprot, oprot):
        args = status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = status_result()
        try:
            result.success = self._handler.status()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_shutdown(self, seqid, iprot, oprot):
        args = shutdown_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = shutdown_result()
        try:
            self._handler.shutdown()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClientException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("shutdown", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class namespace_create_args(object):
    """
    Attributes:
     - ns

    """

    __slots__ = (
        'ns',
    )


    def __init__(self, ns=None,):
        self.ns = ns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ns = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('namespace_create_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.STRING, 1)
            oprot.writeString(self.ns)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(namespace_create_args)
namespace_create_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ns', None, None, ),  # 1
)


class namespace_create_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('namespace_create_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(namespace_create_result)
namespace_create_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class create_namespace_args(object):
    """
    Attributes:
     - ns

    """

    __slots__ = (
        'ns',
    )


    def __init__(self, ns=None,):
        self.ns = ns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ns = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_namespace_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.STRING, 1)
            oprot.writeString(self.ns)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_namespace_args)
create_namespace_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ns', None, None, ),  # 1
)


class create_namespace_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_namespace_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_namespace_result)
create_namespace_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class table_create_args(object):
    """
    Attributes:
     - ns
     - table_name
     - schema

    """

    __slots__ = (
        'ns',
        'table_name',
        'schema',
    )


    def __init__(self, ns=None, table_name=None, schema=None,):
        self.ns = ns
        self.table_name = table_name
        self.schema = schema

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.schema = Schema()
                    self.schema.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_create_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.schema is not None:
            oprot.writeFieldBegin('schema', TType.STRUCT, 3)
            self.schema.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_create_args)
table_create_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRUCT, 'schema', [Schema, None], None, ),  # 3
)


class table_create_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_create_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_create_result)
table_create_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class table_alter_args(object):
    """
    Attributes:
     - ns
     - table_name
     - schema

    """

    __slots__ = (
        'ns',
        'table_name',
        'schema',
    )


    def __init__(self, ns=None, table_name=None, schema=None,):
        self.ns = ns
        self.table_name = table_name
        self.schema = schema

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.schema = Schema()
                    self.schema.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_alter_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.schema is not None:
            oprot.writeFieldBegin('schema', TType.STRUCT, 3)
            self.schema.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_alter_args)
table_alter_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRUCT, 'schema', [Schema, None], None, ),  # 3
)


class table_alter_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_alter_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_alter_result)
table_alter_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class refresh_table_args(object):
    """
    Attributes:
     - ns
     - table_name

    """

    __slots__ = (
        'ns',
        'table_name',
    )


    def __init__(self, ns=None, table_name=None,):
        self.ns = ns
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('refresh_table_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(refresh_table_args)
refresh_table_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
)


class refresh_table_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('refresh_table_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(refresh_table_result)
refresh_table_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class namespace_open_args(object):
    """
    Attributes:
     - ns

    """

    __slots__ = (
        'ns',
    )


    def __init__(self, ns=None,):
        self.ns = ns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ns = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('namespace_open_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.STRING, 1)
            oprot.writeString(self.ns)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(namespace_open_args)
namespace_open_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ns', None, None, ),  # 1
)


class namespace_open_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('namespace_open_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(namespace_open_result)
namespace_open_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class open_namespace_args(object):
    """
    Attributes:
     - ns

    """

    __slots__ = (
        'ns',
    )


    def __init__(self, ns=None,):
        self.ns = ns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ns = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('open_namespace_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.STRING, 1)
            oprot.writeString(self.ns)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(open_namespace_args)
open_namespace_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ns', None, None, ),  # 1
)


class open_namespace_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('open_namespace_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(open_namespace_result)
open_namespace_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class namespace_close_args(object):
    """
    Attributes:
     - ns

    """

    __slots__ = (
        'ns',
    )


    def __init__(self, ns=None,):
        self.ns = ns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('namespace_close_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(namespace_close_args)
namespace_close_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
)


class namespace_close_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('namespace_close_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(namespace_close_result)
namespace_close_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class close_namespace_args(object):
    """
    Attributes:
     - ns

    """

    __slots__ = (
        'ns',
    )


    def __init__(self, ns=None,):
        self.ns = ns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('close_namespace_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(close_namespace_args)
close_namespace_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
)


class close_namespace_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('close_namespace_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(close_namespace_result)
close_namespace_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class future_open_args(object):
    """
    Attributes:
     - capacity

    """

    __slots__ = (
        'capacity',
    )


    def __init__(self, capacity=0,):
        self.capacity = capacity

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.capacity = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_open_args')
        if self.capacity is not None:
            oprot.writeFieldBegin('capacity', TType.I32, 1)
            oprot.writeI32(self.capacity)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_open_args)
future_open_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'capacity', None, 0, ),  # 1
)


class future_open_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_open_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_open_result)
future_open_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class open_future_args(object):
    """
    Attributes:
     - capacity

    """

    __slots__ = (
        'capacity',
    )


    def __init__(self, capacity=0,):
        self.capacity = capacity

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.capacity = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('open_future_args')
        if self.capacity is not None:
            oprot.writeFieldBegin('capacity', TType.I32, 1)
            oprot.writeI32(self.capacity)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(open_future_args)
open_future_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'capacity', None, 0, ),  # 1
)


class open_future_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('open_future_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(open_future_result)
open_future_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class future_cancel_args(object):
    """
    Attributes:
     - ff

    """

    __slots__ = (
        'ff',
    )


    def __init__(self, ff=None,):
        self.ff = ff

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ff = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_cancel_args')
        if self.ff is not None:
            oprot.writeFieldBegin('ff', TType.I64, 1)
            oprot.writeI64(self.ff)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_cancel_args)
future_cancel_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ff', None, None, ),  # 1
)


class future_cancel_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_cancel_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_cancel_result)
future_cancel_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class cancel_future_args(object):
    """
    Attributes:
     - ff

    """

    __slots__ = (
        'ff',
    )


    def __init__(self, ff=None,):
        self.ff = ff

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ff = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancel_future_args')
        if self.ff is not None:
            oprot.writeFieldBegin('ff', TType.I64, 1)
            oprot.writeI64(self.ff)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancel_future_args)
cancel_future_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ff', None, None, ),  # 1
)


class cancel_future_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancel_future_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancel_future_result)
cancel_future_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class future_get_result_args(object):
    """
    Attributes:
     - ff
     - timeout_millis

    """

    __slots__ = (
        'ff',
        'timeout_millis',
    )


    def __init__(self, ff=None, timeout_millis=0,):
        self.ff = ff
        self.timeout_millis = timeout_millis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ff = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.timeout_millis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_get_result_args')
        if self.ff is not None:
            oprot.writeFieldBegin('ff', TType.I64, 1)
            oprot.writeI64(self.ff)
            oprot.writeFieldEnd()
        if self.timeout_millis is not None:
            oprot.writeFieldBegin('timeout_millis', TType.I32, 2)
            oprot.writeI32(self.timeout_millis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_get_result_args)
future_get_result_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ff', None, None, ),  # 1
    (2, TType.I32, 'timeout_millis', None, 0, ),  # 2
)


class future_get_result_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Result()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_get_result_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_get_result_result)
future_get_result_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Result, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class get_future_result_args(object):
    """
    Attributes:
     - ff
     - timeout_millis

    """

    __slots__ = (
        'ff',
        'timeout_millis',
    )


    def __init__(self, ff=None, timeout_millis=0,):
        self.ff = ff
        self.timeout_millis = timeout_millis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ff = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.timeout_millis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_future_result_args')
        if self.ff is not None:
            oprot.writeFieldBegin('ff', TType.I64, 1)
            oprot.writeI64(self.ff)
            oprot.writeFieldEnd()
        if self.timeout_millis is not None:
            oprot.writeFieldBegin('timeout_millis', TType.I32, 2)
            oprot.writeI32(self.timeout_millis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_future_result_args)
get_future_result_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ff', None, None, ),  # 1
    (2, TType.I32, 'timeout_millis', None, 0, ),  # 2
)


class get_future_result_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Result()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_future_result_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_future_result_result)
get_future_result_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Result, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class future_get_result_as_arrays_args(object):
    """
    Attributes:
     - ff
     - timeout_millis

    """

    __slots__ = (
        'ff',
        'timeout_millis',
    )


    def __init__(self, ff=None, timeout_millis=0,):
        self.ff = ff
        self.timeout_millis = timeout_millis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ff = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.timeout_millis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_get_result_as_arrays_args')
        if self.ff is not None:
            oprot.writeFieldBegin('ff', TType.I64, 1)
            oprot.writeI64(self.ff)
            oprot.writeFieldEnd()
        if self.timeout_millis is not None:
            oprot.writeFieldBegin('timeout_millis', TType.I32, 2)
            oprot.writeI32(self.timeout_millis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_get_result_as_arrays_args)
future_get_result_as_arrays_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ff', None, None, ),  # 1
    (2, TType.I32, 'timeout_millis', None, 0, ),  # 2
)


class future_get_result_as_arrays_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ResultAsArrays()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_get_result_as_arrays_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_get_result_as_arrays_result)
future_get_result_as_arrays_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ResultAsArrays, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class get_future_result_as_arrays_args(object):
    """
    Attributes:
     - ff
     - timeout_millis

    """

    __slots__ = (
        'ff',
        'timeout_millis',
    )


    def __init__(self, ff=None, timeout_millis=0,):
        self.ff = ff
        self.timeout_millis = timeout_millis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ff = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.timeout_millis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_future_result_as_arrays_args')
        if self.ff is not None:
            oprot.writeFieldBegin('ff', TType.I64, 1)
            oprot.writeI64(self.ff)
            oprot.writeFieldEnd()
        if self.timeout_millis is not None:
            oprot.writeFieldBegin('timeout_millis', TType.I32, 2)
            oprot.writeI32(self.timeout_millis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_future_result_as_arrays_args)
get_future_result_as_arrays_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ff', None, None, ),  # 1
    (2, TType.I32, 'timeout_millis', None, 0, ),  # 2
)


class get_future_result_as_arrays_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ResultAsArrays()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_future_result_as_arrays_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_future_result_as_arrays_result)
get_future_result_as_arrays_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ResultAsArrays, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class future_get_result_serialized_args(object):
    """
    Attributes:
     - ff
     - timeout_millis

    """

    __slots__ = (
        'ff',
        'timeout_millis',
    )


    def __init__(self, ff=None, timeout_millis=0,):
        self.ff = ff
        self.timeout_millis = timeout_millis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ff = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.timeout_millis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_get_result_serialized_args')
        if self.ff is not None:
            oprot.writeFieldBegin('ff', TType.I64, 1)
            oprot.writeI64(self.ff)
            oprot.writeFieldEnd()
        if self.timeout_millis is not None:
            oprot.writeFieldBegin('timeout_millis', TType.I32, 2)
            oprot.writeI32(self.timeout_millis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_get_result_serialized_args)
future_get_result_serialized_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ff', None, None, ),  # 1
    (2, TType.I32, 'timeout_millis', None, 0, ),  # 2
)


class future_get_result_serialized_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ResultSerialized()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_get_result_serialized_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_get_result_serialized_result)
future_get_result_serialized_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ResultSerialized, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class get_future_result_serialized_args(object):
    """
    Attributes:
     - ff
     - timeout_millis

    """

    __slots__ = (
        'ff',
        'timeout_millis',
    )


    def __init__(self, ff=None, timeout_millis=0,):
        self.ff = ff
        self.timeout_millis = timeout_millis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ff = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.timeout_millis = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_future_result_serialized_args')
        if self.ff is not None:
            oprot.writeFieldBegin('ff', TType.I64, 1)
            oprot.writeI64(self.ff)
            oprot.writeFieldEnd()
        if self.timeout_millis is not None:
            oprot.writeFieldBegin('timeout_millis', TType.I32, 2)
            oprot.writeI32(self.timeout_millis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_future_result_serialized_args)
get_future_result_serialized_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ff', None, None, ),  # 1
    (2, TType.I32, 'timeout_millis', None, 0, ),  # 2
)


class get_future_result_serialized_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ResultSerialized()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_future_result_serialized_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_future_result_serialized_result)
get_future_result_serialized_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ResultSerialized, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class future_is_empty_args(object):
    """
    Attributes:
     - ff

    """

    __slots__ = (
        'ff',
    )


    def __init__(self, ff=None,):
        self.ff = ff

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ff = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_is_empty_args')
        if self.ff is not None:
            oprot.writeFieldBegin('ff', TType.I64, 1)
            oprot.writeI64(self.ff)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_is_empty_args)
future_is_empty_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ff', None, None, ),  # 1
)


class future_is_empty_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_is_empty_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_is_empty_result)
future_is_empty_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class future_is_full_args(object):
    """
    Attributes:
     - ff

    """

    __slots__ = (
        'ff',
    )


    def __init__(self, ff=None,):
        self.ff = ff

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ff = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_is_full_args')
        if self.ff is not None:
            oprot.writeFieldBegin('ff', TType.I64, 1)
            oprot.writeI64(self.ff)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_is_full_args)
future_is_full_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ff', None, None, ),  # 1
)


class future_is_full_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_is_full_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_is_full_result)
future_is_full_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class future_is_cancelled_args(object):
    """
    Attributes:
     - ff

    """

    __slots__ = (
        'ff',
    )


    def __init__(self, ff=None,):
        self.ff = ff

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ff = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_is_cancelled_args')
        if self.ff is not None:
            oprot.writeFieldBegin('ff', TType.I64, 1)
            oprot.writeI64(self.ff)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_is_cancelled_args)
future_is_cancelled_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ff', None, None, ),  # 1
)


class future_is_cancelled_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_is_cancelled_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_is_cancelled_result)
future_is_cancelled_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class future_has_outstanding_args(object):
    """
    Attributes:
     - ff

    """

    __slots__ = (
        'ff',
    )


    def __init__(self, ff=None,):
        self.ff = ff

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ff = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_has_outstanding_args')
        if self.ff is not None:
            oprot.writeFieldBegin('ff', TType.I64, 1)
            oprot.writeI64(self.ff)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_has_outstanding_args)
future_has_outstanding_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ff', None, None, ),  # 1
)


class future_has_outstanding_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_has_outstanding_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_has_outstanding_result)
future_has_outstanding_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class future_close_args(object):
    """
    Attributes:
     - ff

    """

    __slots__ = (
        'ff',
    )


    def __init__(self, ff=None,):
        self.ff = ff

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ff = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_close_args')
        if self.ff is not None:
            oprot.writeFieldBegin('ff', TType.I64, 1)
            oprot.writeI64(self.ff)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_close_args)
future_close_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ff', None, None, ),  # 1
)


class future_close_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('future_close_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(future_close_result)
future_close_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class close_future_args(object):
    """
    Attributes:
     - ff

    """

    __slots__ = (
        'ff',
    )


    def __init__(self, ff=None,):
        self.ff = ff

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ff = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('close_future_args')
        if self.ff is not None:
            oprot.writeFieldBegin('ff', TType.I64, 1)
            oprot.writeI64(self.ff)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(close_future_args)
close_future_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ff', None, None, ),  # 1
)


class close_future_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('close_future_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(close_future_result)
close_future_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class scanner_open_args(object):
    """
    Attributes:
     - ns
     - table_name
     - scan_spec

    """

    __slots__ = (
        'ns',
        'table_name',
        'scan_spec',
    )


    def __init__(self, ns=None, table_name=None, scan_spec=None,):
        self.ns = ns
        self.table_name = table_name
        self.scan_spec = scan_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.scan_spec = ScanSpec()
                    self.scan_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scanner_open_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.scan_spec is not None:
            oprot.writeFieldBegin('scan_spec', TType.STRUCT, 3)
            self.scan_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scanner_open_args)
scanner_open_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRUCT, 'scan_spec', [ScanSpec, None], None, ),  # 3
)


class scanner_open_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scanner_open_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scanner_open_result)
scanner_open_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class open_scanner_args(object):
    """
    Attributes:
     - ns
     - table_name
     - scan_spec

    """

    __slots__ = (
        'ns',
        'table_name',
        'scan_spec',
    )


    def __init__(self, ns=None, table_name=None, scan_spec=None,):
        self.ns = ns
        self.table_name = table_name
        self.scan_spec = scan_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.scan_spec = ScanSpec()
                    self.scan_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('open_scanner_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.scan_spec is not None:
            oprot.writeFieldBegin('scan_spec', TType.STRUCT, 3)
            self.scan_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(open_scanner_args)
open_scanner_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRUCT, 'scan_spec', [ScanSpec, None], None, ),  # 3
)


class open_scanner_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('open_scanner_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(open_scanner_result)
open_scanner_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class async_scanner_open_args(object):
    """
    Attributes:
     - ns
     - table_name
     - future
     - scan_spec

    """

    __slots__ = (
        'ns',
        'table_name',
        'future',
        'scan_spec',
    )


    def __init__(self, ns=None, table_name=None, future=None, scan_spec=None,):
        self.ns = ns
        self.table_name = table_name
        self.future = future
        self.scan_spec = scan_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.future = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.scan_spec = ScanSpec()
                    self.scan_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_scanner_open_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.future is not None:
            oprot.writeFieldBegin('future', TType.I64, 3)
            oprot.writeI64(self.future)
            oprot.writeFieldEnd()
        if self.scan_spec is not None:
            oprot.writeFieldBegin('scan_spec', TType.STRUCT, 4)
            self.scan_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_scanner_open_args)
async_scanner_open_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.I64, 'future', None, None, ),  # 3
    (4, TType.STRUCT, 'scan_spec', [ScanSpec, None], None, ),  # 4
)


class async_scanner_open_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_scanner_open_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_scanner_open_result)
async_scanner_open_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class open_scanner_async_args(object):
    """
    Attributes:
     - ns
     - table_name
     - future
     - scan_spec

    """

    __slots__ = (
        'ns',
        'table_name',
        'future',
        'scan_spec',
    )


    def __init__(self, ns=None, table_name=None, future=None, scan_spec=None,):
        self.ns = ns
        self.table_name = table_name
        self.future = future
        self.scan_spec = scan_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.future = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.scan_spec = ScanSpec()
                    self.scan_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('open_scanner_async_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.future is not None:
            oprot.writeFieldBegin('future', TType.I64, 3)
            oprot.writeI64(self.future)
            oprot.writeFieldEnd()
        if self.scan_spec is not None:
            oprot.writeFieldBegin('scan_spec', TType.STRUCT, 4)
            self.scan_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(open_scanner_async_args)
open_scanner_async_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.I64, 'future', None, None, ),  # 3
    (4, TType.STRUCT, 'scan_spec', [ScanSpec, None], None, ),  # 4
)


class open_scanner_async_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('open_scanner_async_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(open_scanner_async_result)
open_scanner_async_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class scanner_close_args(object):
    """
    Attributes:
     - scanner

    """

    __slots__ = (
        'scanner',
    )


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.scanner = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scanner_close_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.I64, 1)
            oprot.writeI64(self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scanner_close_args)
scanner_close_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'scanner', None, None, ),  # 1
)


class scanner_close_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scanner_close_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scanner_close_result)
scanner_close_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class close_scanner_args(object):
    """
    Attributes:
     - scanner

    """

    __slots__ = (
        'scanner',
    )


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.scanner = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('close_scanner_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.I64, 1)
            oprot.writeI64(self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(close_scanner_args)
close_scanner_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'scanner', None, None, ),  # 1
)


class close_scanner_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('close_scanner_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(close_scanner_result)
close_scanner_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class async_scanner_cancel_args(object):
    """
    Attributes:
     - scanner

    """

    __slots__ = (
        'scanner',
    )


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.scanner = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_scanner_cancel_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.I64, 1)
            oprot.writeI64(self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_scanner_cancel_args)
async_scanner_cancel_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'scanner', None, None, ),  # 1
)


class async_scanner_cancel_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_scanner_cancel_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_scanner_cancel_result)
async_scanner_cancel_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class cancel_scanner_async_args(object):
    """
    Attributes:
     - scanner

    """

    __slots__ = (
        'scanner',
    )


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.scanner = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancel_scanner_async_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.I64, 1)
            oprot.writeI64(self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancel_scanner_async_args)
cancel_scanner_async_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'scanner', None, None, ),  # 1
)


class cancel_scanner_async_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancel_scanner_async_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancel_scanner_async_result)
cancel_scanner_async_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class async_scanner_close_args(object):
    """
    Attributes:
     - scanner

    """

    __slots__ = (
        'scanner',
    )


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.scanner = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_scanner_close_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.I64, 1)
            oprot.writeI64(self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_scanner_close_args)
async_scanner_close_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'scanner', None, None, ),  # 1
)


class async_scanner_close_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_scanner_close_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_scanner_close_result)
async_scanner_close_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class close_scanner_async_args(object):
    """
    Attributes:
     - scanner

    """

    __slots__ = (
        'scanner',
    )


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.scanner = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('close_scanner_async_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.I64, 1)
            oprot.writeI64(self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(close_scanner_async_args)
close_scanner_async_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'scanner', None, None, ),  # 1
)


class close_scanner_async_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('close_scanner_async_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(close_scanner_async_result)
close_scanner_async_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class scanner_get_cells_args(object):
    """
    Attributes:
     - scanner

    """

    __slots__ = (
        'scanner',
    )


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.scanner = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scanner_get_cells_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.I64, 1)
            oprot.writeI64(self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scanner_get_cells_args)
scanner_get_cells_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'scanner', None, None, ),  # 1
)


class scanner_get_cells_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype70, _size67) = iprot.readListBegin()
                    for _i71 in range(_size67):
                        _elem72 = Cell()
                        _elem72.read(iprot)
                        self.success.append(_elem72)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scanner_get_cells_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter73 in self.success:
                iter73.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scanner_get_cells_result)
scanner_get_cells_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Cell, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class next_cells_args(object):
    """
    Attributes:
     - scanner

    """

    __slots__ = (
        'scanner',
    )


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.scanner = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('next_cells_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.I64, 1)
            oprot.writeI64(self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(next_cells_args)
next_cells_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'scanner', None, None, ),  # 1
)


class next_cells_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype77, _size74) = iprot.readListBegin()
                    for _i78 in range(_size74):
                        _elem79 = Cell()
                        _elem79.read(iprot)
                        self.success.append(_elem79)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('next_cells_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter80 in self.success:
                iter80.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(next_cells_result)
next_cells_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Cell, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class scanner_get_cells_as_arrays_args(object):
    """
    Attributes:
     - scanner

    """

    __slots__ = (
        'scanner',
    )


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.scanner = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scanner_get_cells_as_arrays_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.I64, 1)
            oprot.writeI64(self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scanner_get_cells_as_arrays_args)
scanner_get_cells_as_arrays_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'scanner', None, None, ),  # 1
)


class scanner_get_cells_as_arrays_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype84, _size81) = iprot.readListBegin()
                    for _i85 in range(_size81):
                        _elem86 = []
                        (_etype90, _size87) = iprot.readListBegin()
                        for _i91 in range(_size87):
                            _elem92 = iprot.readString()
                            _elem86.append(_elem92)
                        iprot.readListEnd()
                        self.success.append(_elem86)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scanner_get_cells_as_arrays_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter93 in self.success:
                oprot.writeListBegin(TType.STRING, len(iter93))
                for iter94 in iter93:
                    oprot.writeString(iter94)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scanner_get_cells_as_arrays_result)
scanner_get_cells_as_arrays_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.STRING, None, False), False), None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class next_cells_as_arrays_args(object):
    """
    Attributes:
     - scanner

    """

    __slots__ = (
        'scanner',
    )


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.scanner = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('next_cells_as_arrays_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.I64, 1)
            oprot.writeI64(self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(next_cells_as_arrays_args)
next_cells_as_arrays_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'scanner', None, None, ),  # 1
)


class next_cells_as_arrays_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype98, _size95) = iprot.readListBegin()
                    for _i99 in range(_size95):
                        _elem100 = []
                        (_etype104, _size101) = iprot.readListBegin()
                        for _i105 in range(_size101):
                            _elem106 = iprot.readString()
                            _elem100.append(_elem106)
                        iprot.readListEnd()
                        self.success.append(_elem100)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('next_cells_as_arrays_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter107 in self.success:
                oprot.writeListBegin(TType.STRING, len(iter107))
                for iter108 in iter107:
                    oprot.writeString(iter108)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(next_cells_as_arrays_result)
next_cells_as_arrays_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.STRING, None, False), False), None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class scanner_get_cells_serialized_args(object):
    """
    Attributes:
     - scanner

    """

    __slots__ = (
        'scanner',
    )


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.scanner = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scanner_get_cells_serialized_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.I64, 1)
            oprot.writeI64(self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scanner_get_cells_serialized_args)
scanner_get_cells_serialized_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'scanner', None, None, ),  # 1
)


class scanner_get_cells_serialized_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scanner_get_cells_serialized_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scanner_get_cells_serialized_result)
scanner_get_cells_serialized_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class next_cells_serialized_args(object):
    """
    Attributes:
     - scanner

    """

    __slots__ = (
        'scanner',
    )


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.scanner = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('next_cells_serialized_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.I64, 1)
            oprot.writeI64(self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(next_cells_serialized_args)
next_cells_serialized_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'scanner', None, None, ),  # 1
)


class next_cells_serialized_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('next_cells_serialized_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(next_cells_serialized_result)
next_cells_serialized_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class scanner_get_row_args(object):
    """
    Attributes:
     - scanner

    """

    __slots__ = (
        'scanner',
    )


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.scanner = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scanner_get_row_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.I64, 1)
            oprot.writeI64(self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scanner_get_row_args)
scanner_get_row_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'scanner', None, None, ),  # 1
)


class scanner_get_row_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype112, _size109) = iprot.readListBegin()
                    for _i113 in range(_size109):
                        _elem114 = Cell()
                        _elem114.read(iprot)
                        self.success.append(_elem114)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scanner_get_row_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter115 in self.success:
                iter115.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scanner_get_row_result)
scanner_get_row_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Cell, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class next_row_args(object):
    """
    Attributes:
     - scanner

    """

    __slots__ = (
        'scanner',
    )


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.scanner = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('next_row_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.I64, 1)
            oprot.writeI64(self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(next_row_args)
next_row_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'scanner', None, None, ),  # 1
)


class next_row_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype119, _size116) = iprot.readListBegin()
                    for _i120 in range(_size116):
                        _elem121 = Cell()
                        _elem121.read(iprot)
                        self.success.append(_elem121)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('next_row_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter122 in self.success:
                iter122.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(next_row_result)
next_row_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Cell, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class scanner_get_row_as_arrays_args(object):
    """
    Attributes:
     - scanner

    """

    __slots__ = (
        'scanner',
    )


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.scanner = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scanner_get_row_as_arrays_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.I64, 1)
            oprot.writeI64(self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scanner_get_row_as_arrays_args)
scanner_get_row_as_arrays_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'scanner', None, None, ),  # 1
)


class scanner_get_row_as_arrays_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype126, _size123) = iprot.readListBegin()
                    for _i127 in range(_size123):
                        _elem128 = []
                        (_etype132, _size129) = iprot.readListBegin()
                        for _i133 in range(_size129):
                            _elem134 = iprot.readString()
                            _elem128.append(_elem134)
                        iprot.readListEnd()
                        self.success.append(_elem128)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scanner_get_row_as_arrays_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter135 in self.success:
                oprot.writeListBegin(TType.STRING, len(iter135))
                for iter136 in iter135:
                    oprot.writeString(iter136)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scanner_get_row_as_arrays_result)
scanner_get_row_as_arrays_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.STRING, None, False), False), None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class next_row_as_arrays_args(object):
    """
    Attributes:
     - scanner

    """

    __slots__ = (
        'scanner',
    )


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.scanner = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('next_row_as_arrays_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.I64, 1)
            oprot.writeI64(self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(next_row_as_arrays_args)
next_row_as_arrays_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'scanner', None, None, ),  # 1
)


class next_row_as_arrays_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype140, _size137) = iprot.readListBegin()
                    for _i141 in range(_size137):
                        _elem142 = []
                        (_etype146, _size143) = iprot.readListBegin()
                        for _i147 in range(_size143):
                            _elem148 = iprot.readString()
                            _elem142.append(_elem148)
                        iprot.readListEnd()
                        self.success.append(_elem142)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('next_row_as_arrays_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter149 in self.success:
                oprot.writeListBegin(TType.STRING, len(iter149))
                for iter150 in iter149:
                    oprot.writeString(iter150)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(next_row_as_arrays_result)
next_row_as_arrays_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.STRING, None, False), False), None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class scanner_get_row_serialized_args(object):
    """
    Attributes:
     - scanner

    """

    __slots__ = (
        'scanner',
    )


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.scanner = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scanner_get_row_serialized_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.I64, 1)
            oprot.writeI64(self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scanner_get_row_serialized_args)
scanner_get_row_serialized_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'scanner', None, None, ),  # 1
)


class scanner_get_row_serialized_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scanner_get_row_serialized_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scanner_get_row_serialized_result)
scanner_get_row_serialized_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class next_row_serialized_args(object):
    """
    Attributes:
     - scanner

    """

    __slots__ = (
        'scanner',
    )


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.scanner = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('next_row_serialized_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.I64, 1)
            oprot.writeI64(self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(next_row_serialized_args)
next_row_serialized_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'scanner', None, None, ),  # 1
)


class next_row_serialized_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('next_row_serialized_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(next_row_serialized_result)
next_row_serialized_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class get_row_args(object):
    """
    Attributes:
     - ns
     - table_name
     - row

    """

    __slots__ = (
        'ns',
        'table_name',
        'row',
    )


    def __init__(self, ns=None, table_name=None, row=None,):
        self.ns = ns
        self.table_name = table_name
        self.row = row

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.row = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_row_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.STRING, 3)
            oprot.writeString(self.row)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_row_args)
get_row_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRING, 'row', None, None, ),  # 3
)


class get_row_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype154, _size151) = iprot.readListBegin()
                    for _i155 in range(_size151):
                        _elem156 = Cell()
                        _elem156.read(iprot)
                        self.success.append(_elem156)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_row_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter157 in self.success:
                iter157.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_row_result)
get_row_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Cell, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class get_row_as_arrays_args(object):
    """
    Attributes:
     - ns
     - name
     - row

    """

    __slots__ = (
        'ns',
        'name',
        'row',
    )


    def __init__(self, ns=None, name=None, row=None,):
        self.ns = ns
        self.name = name
        self.row = row

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.row = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_row_as_arrays_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.STRING, 3)
            oprot.writeString(self.row)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_row_as_arrays_args)
get_row_as_arrays_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'name', None, None, ),  # 2
    (3, TType.STRING, 'row', None, None, ),  # 3
)


class get_row_as_arrays_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype161, _size158) = iprot.readListBegin()
                    for _i162 in range(_size158):
                        _elem163 = []
                        (_etype167, _size164) = iprot.readListBegin()
                        for _i168 in range(_size164):
                            _elem169 = iprot.readString()
                            _elem163.append(_elem169)
                        iprot.readListEnd()
                        self.success.append(_elem163)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_row_as_arrays_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter170 in self.success:
                oprot.writeListBegin(TType.STRING, len(iter170))
                for iter171 in iter170:
                    oprot.writeString(iter171)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_row_as_arrays_result)
get_row_as_arrays_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.STRING, None, False), False), None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class get_row_serialized_args(object):
    """
    Attributes:
     - ns
     - table_name
     - row

    """

    __slots__ = (
        'ns',
        'table_name',
        'row',
    )


    def __init__(self, ns=None, table_name=None, row=None,):
        self.ns = ns
        self.table_name = table_name
        self.row = row

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.row = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_row_serialized_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.STRING, 3)
            oprot.writeString(self.row)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_row_serialized_args)
get_row_serialized_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRING, 'row', None, None, ),  # 3
)


class get_row_serialized_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_row_serialized_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_row_serialized_result)
get_row_serialized_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class get_cell_args(object):
    """
    Attributes:
     - ns
     - table_name
     - row
     - column

    """

    __slots__ = (
        'ns',
        'table_name',
        'row',
        'column',
    )


    def __init__(self, ns=None, table_name=None, row=None, column=None,):
        self.ns = ns
        self.table_name = table_name
        self.row = row
        self.column = column

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.row = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.column = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cell_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.STRING, 3)
            oprot.writeString(self.row)
            oprot.writeFieldEnd()
        if self.column is not None:
            oprot.writeFieldBegin('column', TType.STRING, 4)
            oprot.writeString(self.column)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cell_args)
get_cell_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRING, 'row', None, None, ),  # 3
    (4, TType.STRING, 'column', None, None, ),  # 4
)


class get_cell_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cell_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cell_result)
get_cell_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class get_cells_args(object):
    """
    Attributes:
     - ns
     - table_name
     - scan_spec

    """

    __slots__ = (
        'ns',
        'table_name',
        'scan_spec',
    )


    def __init__(self, ns=None, table_name=None, scan_spec=None,):
        self.ns = ns
        self.table_name = table_name
        self.scan_spec = scan_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.scan_spec = ScanSpec()
                    self.scan_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cells_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.scan_spec is not None:
            oprot.writeFieldBegin('scan_spec', TType.STRUCT, 3)
            self.scan_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cells_args)
get_cells_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRUCT, 'scan_spec', [ScanSpec, None], None, ),  # 3
)


class get_cells_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype175, _size172) = iprot.readListBegin()
                    for _i176 in range(_size172):
                        _elem177 = Cell()
                        _elem177.read(iprot)
                        self.success.append(_elem177)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cells_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter178 in self.success:
                iter178.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cells_result)
get_cells_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Cell, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class get_cells_as_arrays_args(object):
    """
    Attributes:
     - ns
     - name
     - scan_spec

    """

    __slots__ = (
        'ns',
        'name',
        'scan_spec',
    )


    def __init__(self, ns=None, name=None, scan_spec=None,):
        self.ns = ns
        self.name = name
        self.scan_spec = scan_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.scan_spec = ScanSpec()
                    self.scan_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cells_as_arrays_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.scan_spec is not None:
            oprot.writeFieldBegin('scan_spec', TType.STRUCT, 3)
            self.scan_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cells_as_arrays_args)
get_cells_as_arrays_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'name', None, None, ),  # 2
    (3, TType.STRUCT, 'scan_spec', [ScanSpec, None], None, ),  # 3
)


class get_cells_as_arrays_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype182, _size179) = iprot.readListBegin()
                    for _i183 in range(_size179):
                        _elem184 = []
                        (_etype188, _size185) = iprot.readListBegin()
                        for _i189 in range(_size185):
                            _elem190 = iprot.readString()
                            _elem184.append(_elem190)
                        iprot.readListEnd()
                        self.success.append(_elem184)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cells_as_arrays_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter191 in self.success:
                oprot.writeListBegin(TType.STRING, len(iter191))
                for iter192 in iter191:
                    oprot.writeString(iter192)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cells_as_arrays_result)
get_cells_as_arrays_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.STRING, None, False), False), None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class get_cells_serialized_args(object):
    """
    Attributes:
     - ns
     - name
     - scan_spec

    """

    __slots__ = (
        'ns',
        'name',
        'scan_spec',
    )


    def __init__(self, ns=None, name=None, scan_spec=None,):
        self.ns = ns
        self.name = name
        self.scan_spec = scan_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.scan_spec = ScanSpec()
                    self.scan_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cells_serialized_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.scan_spec is not None:
            oprot.writeFieldBegin('scan_spec', TType.STRUCT, 3)
            self.scan_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cells_serialized_args)
get_cells_serialized_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'name', None, None, ),  # 2
    (3, TType.STRUCT, 'scan_spec', [ScanSpec, None], None, ),  # 3
)


class get_cells_serialized_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cells_serialized_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cells_serialized_result)
get_cells_serialized_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class shared_mutator_refresh_args(object):
    """
    Attributes:
     - ns
     - table_name
     - mutate_spec

    """

    __slots__ = (
        'ns',
        'table_name',
        'mutate_spec',
    )


    def __init__(self, ns=None, table_name=None, mutate_spec=None,):
        self.ns = ns
        self.table_name = table_name
        self.mutate_spec = mutate_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.mutate_spec = MutateSpec()
                    self.mutate_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shared_mutator_refresh_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.mutate_spec is not None:
            oprot.writeFieldBegin('mutate_spec', TType.STRUCT, 3)
            self.mutate_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shared_mutator_refresh_args)
shared_mutator_refresh_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRUCT, 'mutate_spec', [MutateSpec, None], None, ),  # 3
)


class shared_mutator_refresh_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shared_mutator_refresh_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shared_mutator_refresh_result)
shared_mutator_refresh_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class refresh_shared_mutator_args(object):
    """
    Attributes:
     - ns
     - table_name
     - mutate_spec

    """

    __slots__ = (
        'ns',
        'table_name',
        'mutate_spec',
    )


    def __init__(self, ns=None, table_name=None, mutate_spec=None,):
        self.ns = ns
        self.table_name = table_name
        self.mutate_spec = mutate_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.mutate_spec = MutateSpec()
                    self.mutate_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('refresh_shared_mutator_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.mutate_spec is not None:
            oprot.writeFieldBegin('mutate_spec', TType.STRUCT, 3)
            self.mutate_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(refresh_shared_mutator_args)
refresh_shared_mutator_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRUCT, 'mutate_spec', [MutateSpec, None], None, ),  # 3
)


class refresh_shared_mutator_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('refresh_shared_mutator_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(refresh_shared_mutator_result)
refresh_shared_mutator_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class shared_mutator_set_cells_args(object):
    """
    Attributes:
     - ns
     - table_name
     - mutate_spec
     - cells

    """

    __slots__ = (
        'ns',
        'table_name',
        'mutate_spec',
        'cells',
    )


    def __init__(self, ns=None, table_name=None, mutate_spec=None, cells=None,):
        self.ns = ns
        self.table_name = table_name
        self.mutate_spec = mutate_spec
        self.cells = cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.mutate_spec = MutateSpec()
                    self.mutate_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.cells = []
                    (_etype196, _size193) = iprot.readListBegin()
                    for _i197 in range(_size193):
                        _elem198 = Cell()
                        _elem198.read(iprot)
                        self.cells.append(_elem198)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shared_mutator_set_cells_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.mutate_spec is not None:
            oprot.writeFieldBegin('mutate_spec', TType.STRUCT, 3)
            self.mutate_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.cells))
            for iter199 in self.cells:
                iter199.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shared_mutator_set_cells_args)
shared_mutator_set_cells_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRUCT, 'mutate_spec', [MutateSpec, None], None, ),  # 3
    (4, TType.LIST, 'cells', (TType.STRUCT, [Cell, None], False), None, ),  # 4
)


class shared_mutator_set_cells_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shared_mutator_set_cells_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shared_mutator_set_cells_result)
shared_mutator_set_cells_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class offer_cells_args(object):
    """
    Attributes:
     - ns
     - table_name
     - mutate_spec
     - cells

    """

    __slots__ = (
        'ns',
        'table_name',
        'mutate_spec',
        'cells',
    )


    def __init__(self, ns=None, table_name=None, mutate_spec=None, cells=None,):
        self.ns = ns
        self.table_name = table_name
        self.mutate_spec = mutate_spec
        self.cells = cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.mutate_spec = MutateSpec()
                    self.mutate_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.cells = []
                    (_etype203, _size200) = iprot.readListBegin()
                    for _i204 in range(_size200):
                        _elem205 = Cell()
                        _elem205.read(iprot)
                        self.cells.append(_elem205)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('offer_cells_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.mutate_spec is not None:
            oprot.writeFieldBegin('mutate_spec', TType.STRUCT, 3)
            self.mutate_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.cells))
            for iter206 in self.cells:
                iter206.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(offer_cells_args)
offer_cells_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRUCT, 'mutate_spec', [MutateSpec, None], None, ),  # 3
    (4, TType.LIST, 'cells', (TType.STRUCT, [Cell, None], False), None, ),  # 4
)


class offer_cells_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('offer_cells_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(offer_cells_result)
offer_cells_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class shared_mutator_set_cells_as_arrays_args(object):
    """
    Attributes:
     - ns
     - table_name
     - mutate_spec
     - cells

    """

    __slots__ = (
        'ns',
        'table_name',
        'mutate_spec',
        'cells',
    )


    def __init__(self, ns=None, table_name=None, mutate_spec=None, cells=None,):
        self.ns = ns
        self.table_name = table_name
        self.mutate_spec = mutate_spec
        self.cells = cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.mutate_spec = MutateSpec()
                    self.mutate_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.cells = []
                    (_etype210, _size207) = iprot.readListBegin()
                    for _i211 in range(_size207):
                        _elem212 = []
                        (_etype216, _size213) = iprot.readListBegin()
                        for _i217 in range(_size213):
                            _elem218 = iprot.readString()
                            _elem212.append(_elem218)
                        iprot.readListEnd()
                        self.cells.append(_elem212)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shared_mutator_set_cells_as_arrays_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.mutate_spec is not None:
            oprot.writeFieldBegin('mutate_spec', TType.STRUCT, 3)
            self.mutate_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.LIST, 4)
            oprot.writeListBegin(TType.LIST, len(self.cells))
            for iter219 in self.cells:
                oprot.writeListBegin(TType.STRING, len(iter219))
                for iter220 in iter219:
                    oprot.writeString(iter220)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shared_mutator_set_cells_as_arrays_args)
shared_mutator_set_cells_as_arrays_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRUCT, 'mutate_spec', [MutateSpec, None], None, ),  # 3
    (4, TType.LIST, 'cells', (TType.LIST, (TType.STRING, None, False), False), None, ),  # 4
)


class shared_mutator_set_cells_as_arrays_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shared_mutator_set_cells_as_arrays_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shared_mutator_set_cells_as_arrays_result)
shared_mutator_set_cells_as_arrays_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class offer_cells_as_arrays_args(object):
    """
    Attributes:
     - ns
     - table_name
     - mutate_spec
     - cells

    """

    __slots__ = (
        'ns',
        'table_name',
        'mutate_spec',
        'cells',
    )


    def __init__(self, ns=None, table_name=None, mutate_spec=None, cells=None,):
        self.ns = ns
        self.table_name = table_name
        self.mutate_spec = mutate_spec
        self.cells = cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.mutate_spec = MutateSpec()
                    self.mutate_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.cells = []
                    (_etype224, _size221) = iprot.readListBegin()
                    for _i225 in range(_size221):
                        _elem226 = []
                        (_etype230, _size227) = iprot.readListBegin()
                        for _i231 in range(_size227):
                            _elem232 = iprot.readString()
                            _elem226.append(_elem232)
                        iprot.readListEnd()
                        self.cells.append(_elem226)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('offer_cells_as_arrays_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.mutate_spec is not None:
            oprot.writeFieldBegin('mutate_spec', TType.STRUCT, 3)
            self.mutate_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.LIST, 4)
            oprot.writeListBegin(TType.LIST, len(self.cells))
            for iter233 in self.cells:
                oprot.writeListBegin(TType.STRING, len(iter233))
                for iter234 in iter233:
                    oprot.writeString(iter234)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(offer_cells_as_arrays_args)
offer_cells_as_arrays_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRUCT, 'mutate_spec', [MutateSpec, None], None, ),  # 3
    (4, TType.LIST, 'cells', (TType.LIST, (TType.STRING, None, False), False), None, ),  # 4
)


class offer_cells_as_arrays_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('offer_cells_as_arrays_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(offer_cells_as_arrays_result)
offer_cells_as_arrays_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class shared_mutator_set_cell_args(object):
    """
    Attributes:
     - ns
     - table_name
     - mutate_spec
     - cell

    """

    __slots__ = (
        'ns',
        'table_name',
        'mutate_spec',
        'cell',
    )


    def __init__(self, ns=None, table_name=None, mutate_spec=None, cell=None,):
        self.ns = ns
        self.table_name = table_name
        self.mutate_spec = mutate_spec
        self.cell = cell

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.mutate_spec = MutateSpec()
                    self.mutate_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.cell = Cell()
                    self.cell.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shared_mutator_set_cell_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.mutate_spec is not None:
            oprot.writeFieldBegin('mutate_spec', TType.STRUCT, 3)
            self.mutate_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.cell is not None:
            oprot.writeFieldBegin('cell', TType.STRUCT, 4)
            self.cell.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shared_mutator_set_cell_args)
shared_mutator_set_cell_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRUCT, 'mutate_spec', [MutateSpec, None], None, ),  # 3
    (4, TType.STRUCT, 'cell', [Cell, None], None, ),  # 4
)


class shared_mutator_set_cell_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shared_mutator_set_cell_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shared_mutator_set_cell_result)
shared_mutator_set_cell_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class offer_cell_args(object):
    """
    Attributes:
     - ns
     - table_name
     - mutate_spec
     - cell

    """

    __slots__ = (
        'ns',
        'table_name',
        'mutate_spec',
        'cell',
    )


    def __init__(self, ns=None, table_name=None, mutate_spec=None, cell=None,):
        self.ns = ns
        self.table_name = table_name
        self.mutate_spec = mutate_spec
        self.cell = cell

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.mutate_spec = MutateSpec()
                    self.mutate_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.cell = Cell()
                    self.cell.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('offer_cell_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.mutate_spec is not None:
            oprot.writeFieldBegin('mutate_spec', TType.STRUCT, 3)
            self.mutate_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.cell is not None:
            oprot.writeFieldBegin('cell', TType.STRUCT, 4)
            self.cell.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(offer_cell_args)
offer_cell_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRUCT, 'mutate_spec', [MutateSpec, None], None, ),  # 3
    (4, TType.STRUCT, 'cell', [Cell, None], None, ),  # 4
)


class offer_cell_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('offer_cell_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(offer_cell_result)
offer_cell_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class shared_mutator_set_cell_as_array_args(object):
    """
    Attributes:
     - ns
     - table_name
     - mutate_spec
     - cell

    """

    __slots__ = (
        'ns',
        'table_name',
        'mutate_spec',
        'cell',
    )


    def __init__(self, ns=None, table_name=None, mutate_spec=None, cell=None,):
        self.ns = ns
        self.table_name = table_name
        self.mutate_spec = mutate_spec
        self.cell = cell

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.mutate_spec = MutateSpec()
                    self.mutate_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.cell = []
                    (_etype238, _size235) = iprot.readListBegin()
                    for _i239 in range(_size235):
                        _elem240 = iprot.readString()
                        self.cell.append(_elem240)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shared_mutator_set_cell_as_array_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.mutate_spec is not None:
            oprot.writeFieldBegin('mutate_spec', TType.STRUCT, 3)
            self.mutate_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.cell is not None:
            oprot.writeFieldBegin('cell', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.cell))
            for iter241 in self.cell:
                oprot.writeString(iter241)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shared_mutator_set_cell_as_array_args)
shared_mutator_set_cell_as_array_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRUCT, 'mutate_spec', [MutateSpec, None], None, ),  # 3
    (4, TType.LIST, 'cell', (TType.STRING, None, False), None, ),  # 4
)


class shared_mutator_set_cell_as_array_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shared_mutator_set_cell_as_array_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shared_mutator_set_cell_as_array_result)
shared_mutator_set_cell_as_array_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class offer_cell_as_array_args(object):
    """
    Attributes:
     - ns
     - table_name
     - mutate_spec
     - cell

    """

    __slots__ = (
        'ns',
        'table_name',
        'mutate_spec',
        'cell',
    )


    def __init__(self, ns=None, table_name=None, mutate_spec=None, cell=None,):
        self.ns = ns
        self.table_name = table_name
        self.mutate_spec = mutate_spec
        self.cell = cell

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.mutate_spec = MutateSpec()
                    self.mutate_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.cell = []
                    (_etype245, _size242) = iprot.readListBegin()
                    for _i246 in range(_size242):
                        _elem247 = iprot.readString()
                        self.cell.append(_elem247)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('offer_cell_as_array_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.mutate_spec is not None:
            oprot.writeFieldBegin('mutate_spec', TType.STRUCT, 3)
            self.mutate_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.cell is not None:
            oprot.writeFieldBegin('cell', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.cell))
            for iter248 in self.cell:
                oprot.writeString(iter248)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(offer_cell_as_array_args)
offer_cell_as_array_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRUCT, 'mutate_spec', [MutateSpec, None], None, ),  # 3
    (4, TType.LIST, 'cell', (TType.STRING, None, False), None, ),  # 4
)


class offer_cell_as_array_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('offer_cell_as_array_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(offer_cell_as_array_result)
offer_cell_as_array_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class mutator_open_args(object):
    """
    Attributes:
     - ns
     - table_name
     - flags
     - flush_interval

    """

    __slots__ = (
        'ns',
        'table_name',
        'flags',
        'flush_interval',
    )


    def __init__(self, ns=None, table_name=None, flags=0, flush_interval=0,):
        self.ns = ns
        self.table_name = table_name
        self.flags = flags
        self.flush_interval = flush_interval

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.flags = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.flush_interval = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mutator_open_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.I32, 3)
            oprot.writeI32(self.flags)
            oprot.writeFieldEnd()
        if self.flush_interval is not None:
            oprot.writeFieldBegin('flush_interval', TType.I32, 4)
            oprot.writeI32(self.flush_interval)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mutator_open_args)
mutator_open_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.I32, 'flags', None, 0, ),  # 3
    (4, TType.I32, 'flush_interval', None, 0, ),  # 4
)


class mutator_open_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mutator_open_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mutator_open_result)
mutator_open_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class open_mutator_args(object):
    """
    Attributes:
     - ns
     - table_name
     - flags
     - flush_interval

    """

    __slots__ = (
        'ns',
        'table_name',
        'flags',
        'flush_interval',
    )


    def __init__(self, ns=None, table_name=None, flags=0, flush_interval=0,):
        self.ns = ns
        self.table_name = table_name
        self.flags = flags
        self.flush_interval = flush_interval

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.flags = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.flush_interval = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('open_mutator_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.I32, 3)
            oprot.writeI32(self.flags)
            oprot.writeFieldEnd()
        if self.flush_interval is not None:
            oprot.writeFieldBegin('flush_interval', TType.I32, 4)
            oprot.writeI32(self.flush_interval)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(open_mutator_args)
open_mutator_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.I32, 'flags', None, 0, ),  # 3
    (4, TType.I32, 'flush_interval', None, 0, ),  # 4
)


class open_mutator_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('open_mutator_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(open_mutator_result)
open_mutator_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class async_mutator_open_args(object):
    """
    Attributes:
     - ns
     - table_name
     - future
     - flags

    """

    __slots__ = (
        'ns',
        'table_name',
        'future',
        'flags',
    )


    def __init__(self, ns=None, table_name=None, future=None, flags=0,):
        self.ns = ns
        self.table_name = table_name
        self.future = future
        self.flags = flags

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.future = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.flags = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_mutator_open_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.future is not None:
            oprot.writeFieldBegin('future', TType.I64, 3)
            oprot.writeI64(self.future)
            oprot.writeFieldEnd()
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.I32, 4)
            oprot.writeI32(self.flags)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_mutator_open_args)
async_mutator_open_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.I64, 'future', None, None, ),  # 3
    (4, TType.I32, 'flags', None, 0, ),  # 4
)


class async_mutator_open_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_mutator_open_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_mutator_open_result)
async_mutator_open_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class open_mutator_async_args(object):
    """
    Attributes:
     - ns
     - table_name
     - future
     - flags

    """

    __slots__ = (
        'ns',
        'table_name',
        'future',
        'flags',
    )


    def __init__(self, ns=None, table_name=None, future=None, flags=0,):
        self.ns = ns
        self.table_name = table_name
        self.future = future
        self.flags = flags

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.future = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.flags = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('open_mutator_async_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.future is not None:
            oprot.writeFieldBegin('future', TType.I64, 3)
            oprot.writeI64(self.future)
            oprot.writeFieldEnd()
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.I32, 4)
            oprot.writeI32(self.flags)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(open_mutator_async_args)
open_mutator_async_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.I64, 'future', None, None, ),  # 3
    (4, TType.I32, 'flags', None, 0, ),  # 4
)


class open_mutator_async_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('open_mutator_async_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(open_mutator_async_result)
open_mutator_async_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class mutator_close_args(object):
    """
    Attributes:
     - mutator

    """

    __slots__ = (
        'mutator',
    )


    def __init__(self, mutator=None,):
        self.mutator = mutator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mutator_close_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mutator_close_args)
mutator_close_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
)


class mutator_close_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mutator_close_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mutator_close_result)
mutator_close_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class close_mutator_args(object):
    """
    Attributes:
     - mutator

    """

    __slots__ = (
        'mutator',
    )


    def __init__(self, mutator=None,):
        self.mutator = mutator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('close_mutator_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(close_mutator_args)
close_mutator_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
)


class close_mutator_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('close_mutator_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(close_mutator_result)
close_mutator_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class async_mutator_cancel_args(object):
    """
    Attributes:
     - mutator

    """

    __slots__ = (
        'mutator',
    )


    def __init__(self, mutator=None,):
        self.mutator = mutator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_mutator_cancel_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_mutator_cancel_args)
async_mutator_cancel_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
)


class async_mutator_cancel_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_mutator_cancel_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_mutator_cancel_result)
async_mutator_cancel_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class cancel_mutator_async_args(object):
    """
    Attributes:
     - mutator

    """

    __slots__ = (
        'mutator',
    )


    def __init__(self, mutator=None,):
        self.mutator = mutator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancel_mutator_async_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancel_mutator_async_args)
cancel_mutator_async_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
)


class cancel_mutator_async_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancel_mutator_async_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancel_mutator_async_result)
cancel_mutator_async_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class async_mutator_close_args(object):
    """
    Attributes:
     - mutator

    """

    __slots__ = (
        'mutator',
    )


    def __init__(self, mutator=None,):
        self.mutator = mutator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_mutator_close_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_mutator_close_args)
async_mutator_close_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
)


class async_mutator_close_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_mutator_close_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_mutator_close_result)
async_mutator_close_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class close_mutator_async_args(object):
    """
    Attributes:
     - mutator

    """

    __slots__ = (
        'mutator',
    )


    def __init__(self, mutator=None,):
        self.mutator = mutator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('close_mutator_async_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(close_mutator_async_args)
close_mutator_async_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
)


class close_mutator_async_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('close_mutator_async_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(close_mutator_async_result)
close_mutator_async_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class mutator_set_cell_args(object):
    """
    Attributes:
     - mutator
     - cell

    """

    __slots__ = (
        'mutator',
        'cell',
    )


    def __init__(self, mutator=None, cell=None,):
        self.mutator = mutator
        self.cell = cell

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.cell = Cell()
                    self.cell.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mutator_set_cell_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        if self.cell is not None:
            oprot.writeFieldBegin('cell', TType.STRUCT, 2)
            self.cell.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mutator_set_cell_args)
mutator_set_cell_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
    (2, TType.STRUCT, 'cell', [Cell, None], None, ),  # 2
)


class mutator_set_cell_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mutator_set_cell_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mutator_set_cell_result)
mutator_set_cell_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class set_cell_args(object):
    """
    Attributes:
     - ns
     - table_name
     - cell

    """

    __slots__ = (
        'ns',
        'table_name',
        'cell',
    )


    def __init__(self, ns=None, table_name=None, cell=None,):
        self.ns = ns
        self.table_name = table_name
        self.cell = cell

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cell = Cell()
                    self.cell.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cell_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.cell is not None:
            oprot.writeFieldBegin('cell', TType.STRUCT, 3)
            self.cell.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cell_args)
set_cell_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRUCT, 'cell', [Cell, None], None, ),  # 3
)


class set_cell_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cell_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cell_result)
set_cell_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class mutator_set_cell_as_array_args(object):
    """
    Attributes:
     - mutator
     - cell

    """

    __slots__ = (
        'mutator',
        'cell',
    )


    def __init__(self, mutator=None, cell=None,):
        self.mutator = mutator
        self.cell = cell

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.cell = []
                    (_etype252, _size249) = iprot.readListBegin()
                    for _i253 in range(_size249):
                        _elem254 = iprot.readString()
                        self.cell.append(_elem254)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mutator_set_cell_as_array_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        if self.cell is not None:
            oprot.writeFieldBegin('cell', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.cell))
            for iter255 in self.cell:
                oprot.writeString(iter255)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mutator_set_cell_as_array_args)
mutator_set_cell_as_array_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
    (2, TType.LIST, 'cell', (TType.STRING, None, False), None, ),  # 2
)


class mutator_set_cell_as_array_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mutator_set_cell_as_array_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mutator_set_cell_as_array_result)
mutator_set_cell_as_array_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class set_cell_as_array_args(object):
    """
    Attributes:
     - ns
     - table_name
     - cell

    """

    __slots__ = (
        'ns',
        'table_name',
        'cell',
    )


    def __init__(self, ns=None, table_name=None, cell=None,):
        self.ns = ns
        self.table_name = table_name
        self.cell = cell

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.cell = []
                    (_etype259, _size256) = iprot.readListBegin()
                    for _i260 in range(_size256):
                        _elem261 = iprot.readString()
                        self.cell.append(_elem261)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cell_as_array_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.cell is not None:
            oprot.writeFieldBegin('cell', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.cell))
            for iter262 in self.cell:
                oprot.writeString(iter262)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cell_as_array_args)
set_cell_as_array_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.LIST, 'cell', (TType.STRING, None, False), None, ),  # 3
)


class set_cell_as_array_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cell_as_array_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cell_as_array_result)
set_cell_as_array_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class mutator_set_cells_args(object):
    """
    Attributes:
     - mutator
     - cells

    """

    __slots__ = (
        'mutator',
        'cells',
    )


    def __init__(self, mutator=None, cells=None,):
        self.mutator = mutator
        self.cells = cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.cells = []
                    (_etype266, _size263) = iprot.readListBegin()
                    for _i267 in range(_size263):
                        _elem268 = Cell()
                        _elem268.read(iprot)
                        self.cells.append(_elem268)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mutator_set_cells_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.cells))
            for iter269 in self.cells:
                iter269.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mutator_set_cells_args)
mutator_set_cells_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
    (2, TType.LIST, 'cells', (TType.STRUCT, [Cell, None], False), None, ),  # 2
)


class mutator_set_cells_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mutator_set_cells_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mutator_set_cells_result)
mutator_set_cells_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class set_cells_args(object):
    """
    Attributes:
     - ns
     - table_name
     - cells

    """

    __slots__ = (
        'ns',
        'table_name',
        'cells',
    )


    def __init__(self, ns=None, table_name=None, cells=None,):
        self.ns = ns
        self.table_name = table_name
        self.cells = cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.cells = []
                    (_etype273, _size270) = iprot.readListBegin()
                    for _i274 in range(_size270):
                        _elem275 = Cell()
                        _elem275.read(iprot)
                        self.cells.append(_elem275)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cells_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.cells))
            for iter276 in self.cells:
                iter276.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cells_args)
set_cells_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.LIST, 'cells', (TType.STRUCT, [Cell, None], False), None, ),  # 3
)


class set_cells_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cells_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cells_result)
set_cells_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class mutator_set_cells_as_arrays_args(object):
    """
    Attributes:
     - mutator
     - cells

    """

    __slots__ = (
        'mutator',
        'cells',
    )


    def __init__(self, mutator=None, cells=None,):
        self.mutator = mutator
        self.cells = cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.cells = []
                    (_etype280, _size277) = iprot.readListBegin()
                    for _i281 in range(_size277):
                        _elem282 = []
                        (_etype286, _size283) = iprot.readListBegin()
                        for _i287 in range(_size283):
                            _elem288 = iprot.readString()
                            _elem282.append(_elem288)
                        iprot.readListEnd()
                        self.cells.append(_elem282)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mutator_set_cells_as_arrays_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.cells))
            for iter289 in self.cells:
                oprot.writeListBegin(TType.STRING, len(iter289))
                for iter290 in iter289:
                    oprot.writeString(iter290)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mutator_set_cells_as_arrays_args)
mutator_set_cells_as_arrays_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
    (2, TType.LIST, 'cells', (TType.LIST, (TType.STRING, None, False), False), None, ),  # 2
)


class mutator_set_cells_as_arrays_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mutator_set_cells_as_arrays_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mutator_set_cells_as_arrays_result)
mutator_set_cells_as_arrays_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class set_cells_as_arrays_args(object):
    """
    Attributes:
     - ns
     - table_name
     - cells

    """

    __slots__ = (
        'ns',
        'table_name',
        'cells',
    )


    def __init__(self, ns=None, table_name=None, cells=None,):
        self.ns = ns
        self.table_name = table_name
        self.cells = cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.cells = []
                    (_etype294, _size291) = iprot.readListBegin()
                    for _i295 in range(_size291):
                        _elem296 = []
                        (_etype300, _size297) = iprot.readListBegin()
                        for _i301 in range(_size297):
                            _elem302 = iprot.readString()
                            _elem296.append(_elem302)
                        iprot.readListEnd()
                        self.cells.append(_elem296)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cells_as_arrays_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.cells))
            for iter303 in self.cells:
                oprot.writeListBegin(TType.STRING, len(iter303))
                for iter304 in iter303:
                    oprot.writeString(iter304)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cells_as_arrays_args)
set_cells_as_arrays_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.LIST, 'cells', (TType.LIST, (TType.STRING, None, False), False), None, ),  # 3
)


class set_cells_as_arrays_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cells_as_arrays_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cells_as_arrays_result)
set_cells_as_arrays_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class mutator_set_cells_serialized_args(object):
    """
    Attributes:
     - mutator
     - cells
     - flush

    """

    __slots__ = (
        'mutator',
        'cells',
        'flush',
    )


    def __init__(self, mutator=None, cells=None, flush=False,):
        self.mutator = mutator
        self.cells = cells
        self.flush = flush

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.cells = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.flush = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mutator_set_cells_serialized_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.STRING, 2)
            oprot.writeBinary(self.cells)
            oprot.writeFieldEnd()
        if self.flush is not None:
            oprot.writeFieldBegin('flush', TType.BOOL, 3)
            oprot.writeBool(self.flush)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mutator_set_cells_serialized_args)
mutator_set_cells_serialized_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
    (2, TType.STRING, 'cells', 'BINARY', None, ),  # 2
    (3, TType.BOOL, 'flush', None, False, ),  # 3
)


class mutator_set_cells_serialized_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mutator_set_cells_serialized_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mutator_set_cells_serialized_result)
mutator_set_cells_serialized_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class set_cells_serialized_args(object):
    """
    Attributes:
     - ns
     - table_name
     - cells

    """

    __slots__ = (
        'ns',
        'table_name',
        'cells',
    )


    def __init__(self, ns=None, table_name=None, cells=None,):
        self.ns = ns
        self.table_name = table_name
        self.cells = cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.cells = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cells_serialized_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.STRING, 3)
            oprot.writeBinary(self.cells)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cells_serialized_args)
set_cells_serialized_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRING, 'cells', 'BINARY', None, ),  # 3
)


class set_cells_serialized_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cells_serialized_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cells_serialized_result)
set_cells_serialized_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class mutator_flush_args(object):
    """
    Attributes:
     - mutator

    """

    __slots__ = (
        'mutator',
    )


    def __init__(self, mutator=None,):
        self.mutator = mutator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mutator_flush_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mutator_flush_args)
mutator_flush_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
)


class mutator_flush_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mutator_flush_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mutator_flush_result)
mutator_flush_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class flush_mutator_args(object):
    """
    Attributes:
     - mutator

    """

    __slots__ = (
        'mutator',
    )


    def __init__(self, mutator=None,):
        self.mutator = mutator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('flush_mutator_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(flush_mutator_args)
flush_mutator_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
)


class flush_mutator_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('flush_mutator_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(flush_mutator_result)
flush_mutator_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class async_mutator_set_cell_args(object):
    """
    Attributes:
     - mutator
     - cell

    """

    __slots__ = (
        'mutator',
        'cell',
    )


    def __init__(self, mutator=None, cell=None,):
        self.mutator = mutator
        self.cell = cell

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.cell = Cell()
                    self.cell.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_mutator_set_cell_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        if self.cell is not None:
            oprot.writeFieldBegin('cell', TType.STRUCT, 2)
            self.cell.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_mutator_set_cell_args)
async_mutator_set_cell_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
    (2, TType.STRUCT, 'cell', [Cell, None], None, ),  # 2
)


class async_mutator_set_cell_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_mutator_set_cell_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_mutator_set_cell_result)
async_mutator_set_cell_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class set_cell_async_args(object):
    """
    Attributes:
     - mutator
     - cell

    """

    __slots__ = (
        'mutator',
        'cell',
    )


    def __init__(self, mutator=None, cell=None,):
        self.mutator = mutator
        self.cell = cell

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.cell = Cell()
                    self.cell.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cell_async_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        if self.cell is not None:
            oprot.writeFieldBegin('cell', TType.STRUCT, 2)
            self.cell.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cell_async_args)
set_cell_async_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
    (2, TType.STRUCT, 'cell', [Cell, None], None, ),  # 2
)


class set_cell_async_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cell_async_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cell_async_result)
set_cell_async_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class async_mutator_set_cell_as_array_args(object):
    """
    Attributes:
     - mutator
     - cell

    """

    __slots__ = (
        'mutator',
        'cell',
    )


    def __init__(self, mutator=None, cell=None,):
        self.mutator = mutator
        self.cell = cell

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.cell = []
                    (_etype308, _size305) = iprot.readListBegin()
                    for _i309 in range(_size305):
                        _elem310 = iprot.readString()
                        self.cell.append(_elem310)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_mutator_set_cell_as_array_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        if self.cell is not None:
            oprot.writeFieldBegin('cell', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.cell))
            for iter311 in self.cell:
                oprot.writeString(iter311)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_mutator_set_cell_as_array_args)
async_mutator_set_cell_as_array_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
    (2, TType.LIST, 'cell', (TType.STRING, None, False), None, ),  # 2
)


class async_mutator_set_cell_as_array_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_mutator_set_cell_as_array_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_mutator_set_cell_as_array_result)
async_mutator_set_cell_as_array_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class set_cell_as_array_async_args(object):
    """
    Attributes:
     - mutator
     - cell

    """

    __slots__ = (
        'mutator',
        'cell',
    )


    def __init__(self, mutator=None, cell=None,):
        self.mutator = mutator
        self.cell = cell

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.cell = []
                    (_etype315, _size312) = iprot.readListBegin()
                    for _i316 in range(_size312):
                        _elem317 = iprot.readString()
                        self.cell.append(_elem317)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cell_as_array_async_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        if self.cell is not None:
            oprot.writeFieldBegin('cell', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.cell))
            for iter318 in self.cell:
                oprot.writeString(iter318)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cell_as_array_async_args)
set_cell_as_array_async_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
    (2, TType.LIST, 'cell', (TType.STRING, None, False), None, ),  # 2
)


class set_cell_as_array_async_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cell_as_array_async_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cell_as_array_async_result)
set_cell_as_array_async_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class async_mutator_set_cells_args(object):
    """
    Attributes:
     - mutator
     - cells

    """

    __slots__ = (
        'mutator',
        'cells',
    )


    def __init__(self, mutator=None, cells=None,):
        self.mutator = mutator
        self.cells = cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.cells = []
                    (_etype322, _size319) = iprot.readListBegin()
                    for _i323 in range(_size319):
                        _elem324 = Cell()
                        _elem324.read(iprot)
                        self.cells.append(_elem324)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_mutator_set_cells_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.cells))
            for iter325 in self.cells:
                iter325.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_mutator_set_cells_args)
async_mutator_set_cells_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
    (2, TType.LIST, 'cells', (TType.STRUCT, [Cell, None], False), None, ),  # 2
)


class async_mutator_set_cells_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_mutator_set_cells_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_mutator_set_cells_result)
async_mutator_set_cells_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class set_cells_async_args(object):
    """
    Attributes:
     - mutator
     - cells

    """

    __slots__ = (
        'mutator',
        'cells',
    )


    def __init__(self, mutator=None, cells=None,):
        self.mutator = mutator
        self.cells = cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.cells = []
                    (_etype329, _size326) = iprot.readListBegin()
                    for _i330 in range(_size326):
                        _elem331 = Cell()
                        _elem331.read(iprot)
                        self.cells.append(_elem331)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cells_async_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.cells))
            for iter332 in self.cells:
                iter332.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cells_async_args)
set_cells_async_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
    (2, TType.LIST, 'cells', (TType.STRUCT, [Cell, None], False), None, ),  # 2
)


class set_cells_async_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cells_async_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cells_async_result)
set_cells_async_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class async_mutator_set_cells_as_arrays_args(object):
    """
    Attributes:
     - mutator
     - cells

    """

    __slots__ = (
        'mutator',
        'cells',
    )


    def __init__(self, mutator=None, cells=None,):
        self.mutator = mutator
        self.cells = cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.cells = []
                    (_etype336, _size333) = iprot.readListBegin()
                    for _i337 in range(_size333):
                        _elem338 = []
                        (_etype342, _size339) = iprot.readListBegin()
                        for _i343 in range(_size339):
                            _elem344 = iprot.readString()
                            _elem338.append(_elem344)
                        iprot.readListEnd()
                        self.cells.append(_elem338)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_mutator_set_cells_as_arrays_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.cells))
            for iter345 in self.cells:
                oprot.writeListBegin(TType.STRING, len(iter345))
                for iter346 in iter345:
                    oprot.writeString(iter346)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_mutator_set_cells_as_arrays_args)
async_mutator_set_cells_as_arrays_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
    (2, TType.LIST, 'cells', (TType.LIST, (TType.STRING, None, False), False), None, ),  # 2
)


class async_mutator_set_cells_as_arrays_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_mutator_set_cells_as_arrays_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_mutator_set_cells_as_arrays_result)
async_mutator_set_cells_as_arrays_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class set_cells_as_arrays_async_args(object):
    """
    Attributes:
     - mutator
     - cells

    """

    __slots__ = (
        'mutator',
        'cells',
    )


    def __init__(self, mutator=None, cells=None,):
        self.mutator = mutator
        self.cells = cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.cells = []
                    (_etype350, _size347) = iprot.readListBegin()
                    for _i351 in range(_size347):
                        _elem352 = []
                        (_etype356, _size353) = iprot.readListBegin()
                        for _i357 in range(_size353):
                            _elem358 = iprot.readString()
                            _elem352.append(_elem358)
                        iprot.readListEnd()
                        self.cells.append(_elem352)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cells_as_arrays_async_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.cells))
            for iter359 in self.cells:
                oprot.writeListBegin(TType.STRING, len(iter359))
                for iter360 in iter359:
                    oprot.writeString(iter360)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cells_as_arrays_async_args)
set_cells_as_arrays_async_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
    (2, TType.LIST, 'cells', (TType.LIST, (TType.STRING, None, False), False), None, ),  # 2
)


class set_cells_as_arrays_async_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cells_as_arrays_async_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cells_as_arrays_async_result)
set_cells_as_arrays_async_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class async_mutator_set_cells_serialized_args(object):
    """
    Attributes:
     - mutator
     - cells
     - flush

    """

    __slots__ = (
        'mutator',
        'cells',
        'flush',
    )


    def __init__(self, mutator=None, cells=None, flush=False,):
        self.mutator = mutator
        self.cells = cells
        self.flush = flush

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.cells = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.flush = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_mutator_set_cells_serialized_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.STRING, 2)
            oprot.writeBinary(self.cells)
            oprot.writeFieldEnd()
        if self.flush is not None:
            oprot.writeFieldBegin('flush', TType.BOOL, 3)
            oprot.writeBool(self.flush)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_mutator_set_cells_serialized_args)
async_mutator_set_cells_serialized_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
    (2, TType.STRING, 'cells', 'BINARY', None, ),  # 2
    (3, TType.BOOL, 'flush', None, False, ),  # 3
)


class async_mutator_set_cells_serialized_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_mutator_set_cells_serialized_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_mutator_set_cells_serialized_result)
async_mutator_set_cells_serialized_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class set_cells_serialized_async_args(object):
    """
    Attributes:
     - mutator
     - cells
     - flush

    """

    __slots__ = (
        'mutator',
        'cells',
        'flush',
    )


    def __init__(self, mutator=None, cells=None, flush=False,):
        self.mutator = mutator
        self.cells = cells
        self.flush = flush

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.cells = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.flush = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cells_serialized_async_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.STRING, 2)
            oprot.writeBinary(self.cells)
            oprot.writeFieldEnd()
        if self.flush is not None:
            oprot.writeFieldBegin('flush', TType.BOOL, 3)
            oprot.writeBool(self.flush)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cells_serialized_async_args)
set_cells_serialized_async_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
    (2, TType.STRING, 'cells', 'BINARY', None, ),  # 2
    (3, TType.BOOL, 'flush', None, False, ),  # 3
)


class set_cells_serialized_async_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cells_serialized_async_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cells_serialized_async_result)
set_cells_serialized_async_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class async_mutator_flush_args(object):
    """
    Attributes:
     - mutator

    """

    __slots__ = (
        'mutator',
    )


    def __init__(self, mutator=None,):
        self.mutator = mutator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_mutator_flush_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_mutator_flush_args)
async_mutator_flush_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
)


class async_mutator_flush_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_mutator_flush_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_mutator_flush_result)
async_mutator_flush_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class flush_mutator_async_args(object):
    """
    Attributes:
     - mutator

    """

    __slots__ = (
        'mutator',
    )


    def __init__(self, mutator=None,):
        self.mutator = mutator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('flush_mutator_async_args')
        if self.mutator is not None:
            oprot.writeFieldBegin('mutator', TType.I64, 1)
            oprot.writeI64(self.mutator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(flush_mutator_async_args)
flush_mutator_async_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutator', None, None, ),  # 1
)


class flush_mutator_async_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('flush_mutator_async_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(flush_mutator_async_result)
flush_mutator_async_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class namespace_exists_args(object):
    """
    Attributes:
     - ns

    """

    __slots__ = (
        'ns',
    )


    def __init__(self, ns=None,):
        self.ns = ns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ns = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('namespace_exists_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.STRING, 1)
            oprot.writeString(self.ns)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(namespace_exists_args)
namespace_exists_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ns', None, None, ),  # 1
)


class namespace_exists_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('namespace_exists_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(namespace_exists_result)
namespace_exists_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class exists_namespace_args(object):
    """
    Attributes:
     - ns

    """

    __slots__ = (
        'ns',
    )


    def __init__(self, ns=None,):
        self.ns = ns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ns = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exists_namespace_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.STRING, 1)
            oprot.writeString(self.ns)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exists_namespace_args)
exists_namespace_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ns', None, None, ),  # 1
)


class exists_namespace_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exists_namespace_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exists_namespace_result)
exists_namespace_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class exists_table_args(object):
    """
    Attributes:
     - ns
     - name

    """

    __slots__ = (
        'ns',
        'name',
    )


    def __init__(self, ns=None, name=None,):
        self.ns = ns
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exists_table_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exists_table_args)
exists_table_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'name', None, None, ),  # 2
)


class exists_table_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exists_table_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exists_table_result)
exists_table_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class table_exists_args(object):
    """
    Attributes:
     - ns
     - name

    """

    __slots__ = (
        'ns',
        'name',
    )


    def __init__(self, ns=None, name=None,):
        self.ns = ns
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_exists_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_exists_args)
table_exists_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'name', None, None, ),  # 2
)


class table_exists_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_exists_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_exists_result)
table_exists_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class table_get_id_args(object):
    """
    Attributes:
     - ns
     - table_name

    """

    __slots__ = (
        'ns',
        'table_name',
    )


    def __init__(self, ns=None, table_name=None,):
        self.ns = ns
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_get_id_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_get_id_args)
table_get_id_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
)


class table_get_id_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_get_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_get_id_result)
table_get_id_result.thrift_spec = (
    (0, TType.STRING, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class get_table_id_args(object):
    """
    Attributes:
     - ns
     - table_name

    """

    __slots__ = (
        'ns',
        'table_name',
    )


    def __init__(self, ns=None, table_name=None,):
        self.ns = ns
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_id_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_id_args)
get_table_id_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
)


class get_table_id_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_id_result)
get_table_id_result.thrift_spec = (
    (0, TType.STRING, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class table_get_schema_str_args(object):
    """
    Attributes:
     - ns
     - table_name

    """

    __slots__ = (
        'ns',
        'table_name',
    )


    def __init__(self, ns=None, table_name=None,):
        self.ns = ns
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_get_schema_str_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_get_schema_str_args)
table_get_schema_str_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
)


class table_get_schema_str_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_get_schema_str_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_get_schema_str_result)
table_get_schema_str_result.thrift_spec = (
    (0, TType.STRING, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class get_schema_str_args(object):
    """
    Attributes:
     - ns
     - table_name

    """

    __slots__ = (
        'ns',
        'table_name',
    )


    def __init__(self, ns=None, table_name=None,):
        self.ns = ns
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schema_str_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schema_str_args)
get_schema_str_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
)


class get_schema_str_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schema_str_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schema_str_result)
get_schema_str_result.thrift_spec = (
    (0, TType.STRING, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class table_get_schema_str_with_ids_args(object):
    """
    Attributes:
     - ns
     - table_name

    """

    __slots__ = (
        'ns',
        'table_name',
    )


    def __init__(self, ns=None, table_name=None,):
        self.ns = ns
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_get_schema_str_with_ids_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_get_schema_str_with_ids_args)
table_get_schema_str_with_ids_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
)


class table_get_schema_str_with_ids_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_get_schema_str_with_ids_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_get_schema_str_with_ids_result)
table_get_schema_str_with_ids_result.thrift_spec = (
    (0, TType.STRING, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class get_schema_str_with_ids_args(object):
    """
    Attributes:
     - ns
     - table_name

    """

    __slots__ = (
        'ns',
        'table_name',
    )


    def __init__(self, ns=None, table_name=None,):
        self.ns = ns
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schema_str_with_ids_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schema_str_with_ids_args)
get_schema_str_with_ids_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
)


class get_schema_str_with_ids_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schema_str_with_ids_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schema_str_with_ids_result)
get_schema_str_with_ids_result.thrift_spec = (
    (0, TType.STRING, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class table_get_schema_args(object):
    """
    Attributes:
     - ns
     - table_name

    """

    __slots__ = (
        'ns',
        'table_name',
    )


    def __init__(self, ns=None, table_name=None,):
        self.ns = ns
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_get_schema_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_get_schema_args)
table_get_schema_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
)


class table_get_schema_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Schema()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_get_schema_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_get_schema_result)
table_get_schema_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Schema, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class get_schema_args(object):
    """
    Attributes:
     - ns
     - table_name

    """

    __slots__ = (
        'ns',
        'table_name',
    )


    def __init__(self, ns=None, table_name=None,):
        self.ns = ns
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schema_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schema_args)
get_schema_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
)


class get_schema_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Schema()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schema_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schema_result)
get_schema_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Schema, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class get_tables_args(object):
    """
    Attributes:
     - ns

    """

    __slots__ = (
        'ns',
    )


    def __init__(self, ns=None,):
        self.ns = ns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tables_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tables_args)
get_tables_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
)


class get_tables_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype364, _size361) = iprot.readListBegin()
                    for _i365 in range(_size361):
                        _elem366 = iprot.readString()
                        self.success.append(_elem366)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tables_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter367 in self.success:
                oprot.writeString(iter367)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tables_result)
get_tables_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, None, False), None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class namespace_get_listing_args(object):
    """
    Attributes:
     - ns

    """

    __slots__ = (
        'ns',
    )


    def __init__(self, ns=None,):
        self.ns = ns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('namespace_get_listing_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(namespace_get_listing_args)
namespace_get_listing_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
)


class namespace_get_listing_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype371, _size368) = iprot.readListBegin()
                    for _i372 in range(_size368):
                        _elem373 = NamespaceListing()
                        _elem373.read(iprot)
                        self.success.append(_elem373)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('namespace_get_listing_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter374 in self.success:
                iter374.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(namespace_get_listing_result)
namespace_get_listing_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [NamespaceListing, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class get_listing_args(object):
    """
    Attributes:
     - ns

    """

    __slots__ = (
        'ns',
    )


    def __init__(self, ns=None,):
        self.ns = ns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_listing_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_listing_args)
get_listing_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
)


class get_listing_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype378, _size375) = iprot.readListBegin()
                    for _i379 in range(_size375):
                        _elem380 = NamespaceListing()
                        _elem380.read(iprot)
                        self.success.append(_elem380)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_listing_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter381 in self.success:
                iter381.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_listing_result)
get_listing_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [NamespaceListing, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class table_get_splits_args(object):
    """
    Attributes:
     - ns
     - table_name

    """

    __slots__ = (
        'ns',
        'table_name',
    )


    def __init__(self, ns=None, table_name=None,):
        self.ns = ns
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_get_splits_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_get_splits_args)
table_get_splits_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
)


class table_get_splits_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype385, _size382) = iprot.readListBegin()
                    for _i386 in range(_size382):
                        _elem387 = TableSplit()
                        _elem387.read(iprot)
                        self.success.append(_elem387)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_get_splits_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter388 in self.success:
                iter388.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_get_splits_result)
table_get_splits_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TableSplit, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class get_table_splits_args(object):
    """
    Attributes:
     - ns
     - table_name

    """

    __slots__ = (
        'ns',
        'table_name',
    )


    def __init__(self, ns=None, table_name=None,):
        self.ns = ns
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_splits_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_splits_args)
get_table_splits_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
)


class get_table_splits_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype392, _size389) = iprot.readListBegin()
                    for _i393 in range(_size389):
                        _elem394 = TableSplit()
                        _elem394.read(iprot)
                        self.success.append(_elem394)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_table_splits_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter395 in self.success:
                iter395.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_table_splits_result)
get_table_splits_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TableSplit, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class namespace_drop_args(object):
    """
    Attributes:
     - ns
     - if_exists

    """

    __slots__ = (
        'ns',
        'if_exists',
    )


    def __init__(self, ns=None, if_exists=True,):
        self.ns = ns
        self.if_exists = if_exists

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ns = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.if_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('namespace_drop_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.STRING, 1)
            oprot.writeString(self.ns)
            oprot.writeFieldEnd()
        if self.if_exists is not None:
            oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
            oprot.writeBool(self.if_exists)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(namespace_drop_args)
namespace_drop_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ns', None, None, ),  # 1
    (2, TType.BOOL, 'if_exists', None, True, ),  # 2
)


class namespace_drop_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('namespace_drop_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(namespace_drop_result)
namespace_drop_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class drop_namespace_args(object):
    """
    Attributes:
     - ns
     - if_exists

    """

    __slots__ = (
        'ns',
        'if_exists',
    )


    def __init__(self, ns=None, if_exists=True,):
        self.ns = ns
        self.if_exists = if_exists

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ns = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.if_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_namespace_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.STRING, 1)
            oprot.writeString(self.ns)
            oprot.writeFieldEnd()
        if self.if_exists is not None:
            oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
            oprot.writeBool(self.if_exists)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_namespace_args)
drop_namespace_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ns', None, None, ),  # 1
    (2, TType.BOOL, 'if_exists', None, True, ),  # 2
)


class drop_namespace_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_namespace_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_namespace_result)
drop_namespace_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class rename_table_args(object):
    """
    Attributes:
     - ns
     - name
     - new_name

    """

    __slots__ = (
        'ns',
        'name',
        'new_name',
    )


    def __init__(self, ns=None, name=None, new_name=None,):
        self.ns = ns
        self.name = name
        self.new_name = new_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.new_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rename_table_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.new_name is not None:
            oprot.writeFieldBegin('new_name', TType.STRING, 3)
            oprot.writeString(self.new_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rename_table_args)
rename_table_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'name', None, None, ),  # 2
    (3, TType.STRING, 'new_name', None, None, ),  # 3
)


class rename_table_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rename_table_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rename_table_result)
rename_table_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class table_rename_args(object):
    """
    Attributes:
     - ns
     - name
     - new_name

    """

    __slots__ = (
        'ns',
        'name',
        'new_name',
    )


    def __init__(self, ns=None, name=None, new_name=None,):
        self.ns = ns
        self.name = name
        self.new_name = new_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.new_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_rename_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.new_name is not None:
            oprot.writeFieldBegin('new_name', TType.STRING, 3)
            oprot.writeString(self.new_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_rename_args)
table_rename_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'name', None, None, ),  # 2
    (3, TType.STRING, 'new_name', None, None, ),  # 3
)


class table_rename_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_rename_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_rename_result)
table_rename_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class drop_table_args(object):
    """
    Attributes:
     - ns
     - name
     - if_exists

    """

    __slots__ = (
        'ns',
        'name',
        'if_exists',
    )


    def __init__(self, ns=None, name=None, if_exists=True,):
        self.ns = ns
        self.name = name
        self.if_exists = if_exists

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.if_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_table_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.if_exists is not None:
            oprot.writeFieldBegin('if_exists', TType.BOOL, 3)
            oprot.writeBool(self.if_exists)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_table_args)
drop_table_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'name', None, None, ),  # 2
    (3, TType.BOOL, 'if_exists', None, True, ),  # 3
)


class drop_table_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('drop_table_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(drop_table_result)
drop_table_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class table_drop_args(object):
    """
    Attributes:
     - ns
     - name
     - if_exists

    """

    __slots__ = (
        'ns',
        'name',
        'if_exists',
    )


    def __init__(self, ns=None, name=None, if_exists=True,):
        self.ns = ns
        self.name = name
        self.if_exists = if_exists

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.if_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_drop_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.if_exists is not None:
            oprot.writeFieldBegin('if_exists', TType.BOOL, 3)
            oprot.writeBool(self.if_exists)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_drop_args)
table_drop_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'name', None, None, ),  # 2
    (3, TType.BOOL, 'if_exists', None, True, ),  # 3
)


class table_drop_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table_drop_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(table_drop_result)
table_drop_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class generate_guid_args(object):

    __slots__ = (
    )


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('generate_guid_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(generate_guid_args)
generate_guid_args.thrift_spec = (
)


class generate_guid_result(object):
    """
    Attributes:
     - success

    """

    __slots__ = (
        'success',
    )


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('generate_guid_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(generate_guid_result)
generate_guid_result.thrift_spec = (
    (0, TType.STRING, 'success', None, None, ),  # 0
)


class create_cell_unique_args(object):
    """
    Attributes:
     - ns
     - table_name
     - key
     - value

    """

    __slots__ = (
        'ns',
        'table_name',
        'key',
        'value',
    )


    def __init__(self, ns=None, table_name=None, key=None, value=None,):
        self.ns = ns
        self.table_name = table_name
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.key = Key()
                    self.key.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.value = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_cell_unique_args')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.I64, 1)
            oprot.writeI64(self.ns)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRUCT, 3)
            self.key.write(oprot)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 4)
            oprot.writeString(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_cell_unique_args)
create_cell_unique_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ns', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.STRUCT, 'key', [Key, None], None, ),  # 3
    (4, TType.STRING, 'value', None, None, ),  # 4
)


class create_cell_unique_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_cell_unique_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_cell_unique_result)
create_cell_unique_result.thrift_spec = (
    (0, TType.STRING, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class error_get_text_args(object):
    """
    Attributes:
     - error_code

    """

    __slots__ = (
        'error_code',
    )


    def __init__(self, error_code=None,):
        self.error_code = error_code

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.error_code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('error_get_text_args')
        if self.error_code is not None:
            oprot.writeFieldBegin('error_code', TType.I32, 1)
            oprot.writeI32(self.error_code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(error_get_text_args)
error_get_text_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'error_code', None, None, ),  # 1
)


class error_get_text_result(object):
    """
    Attributes:
     - success

    """

    __slots__ = (
        'success',
    )


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('error_get_text_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(error_get_text_result)
error_get_text_result.thrift_spec = (
    (0, TType.STRING, 'success', None, None, ),  # 0
)


class status_args(object):

    __slots__ = (
    )


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('status_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(status_args)
status_args.thrift_spec = (
)


class status_result(object):
    """
    Attributes:
     - success
     - e

    """

    __slots__ = (
        'success',
        'e',
    )


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Status()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(status_result)
status_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Status, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)


class shutdown_args(object):

    __slots__ = (
    )


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shutdown_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shutdown_args)
shutdown_args.thrift_spec = (
)


class shutdown_result(object):
    """
    Attributes:
     - e

    """

    __slots__ = (
        'e',
    )


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ClientException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shutdown_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shutdown_result)
shutdown_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ClientException, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs

