/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef ClientService_H
#define ClientService_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "Client_types.h"

namespace Hypertable { namespace ThriftGen {

#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class ClientServiceIf {
 public:
  virtual ~ClientServiceIf() {}

  /**
   * Create a namespace
   * 
   * @param ns - namespace name
   * 
   * @param ns
   */
  virtual void namespace_create(const std::string& ns) = 0;
  virtual void create_namespace(const std::string& ns) = 0;

  /**
   * Create a table
   * 
   * @param ns - namespace id
   * @param table_name - table name
   * @param schema - schema of the table
   * 
   * @param ns
   * @param table_name
   * @param schema
   */
  virtual void table_create(const Namespace ns, const std::string& table_name, const Schema& schema) = 0;

  /**
   * Alter a table
   * 
   * @param ns - namespace id
   * @param table_name - table name
   * @param schema - schema of the table
   * 
   * @param ns
   * @param table_name
   * @param schema
   */
  virtual void table_alter(const Namespace ns, const std::string& table_name, const Schema& schema) = 0;

  /**
   * Refreshes the cached table information
   * 
   * @param ns - namespace
   * @param table_name - name of the table
   * 
   * @param ns
   * @param table_name
   */
  virtual void refresh_table(const Namespace ns, const std::string& table_name) = 0;

  /**
   * Open a namespace
   * 
   * @param ns - namespace
   * @return value is guaranteed to be non-zero and unique
   * 
   * @param ns
   */
  virtual Namespace namespace_open(const std::string& ns) = 0;
  virtual Namespace open_namespace(const std::string& ns) = 0;

  /**
   * Close a namespace
   * 
   * @param ns - namespace
   * 
   * @param ns
   */
  virtual void namespace_close(const Namespace ns) = 0;
  virtual void close_namespace(const Namespace ns) = 0;

  /**
   * Open a future object
   * @param capacity - Amount of result data the future object can enqueue without blocking threads
   * 
   * @param capacity
   */
  virtual Future future_open(const int32_t capacity) = 0;
  virtual Future open_future(const int32_t capacity) = 0;

  /**
   * Cancel tasks outstanding in a future object
   * @param ff - Future object
   * 
   * @param ff
   */
  virtual void future_cancel(const Future ff) = 0;
  virtual void cancel_future(const Future ff) = 0;

  /**
   * Fetch asynchronous results
   * @param ff - Future object which has the asynchronous results
   * @return - result from async scanner/mutator
   * 
   * @param ff
   * @param timeout_millis
   */
  virtual void future_get_result(Result& _return, const Future ff, const int32_t timeout_millis) = 0;
  virtual void get_future_result(Result& _return, const Future ff, const int32_t timeout_millis) = 0;

  /**
   * Fetch asynchronous results
   * @param ff - Future object which has the asynchronous results
   * @return - result from async scanner/mutator
   * 
   * @param ff
   * @param timeout_millis
   */
  virtual void future_get_result_as_arrays(ResultAsArrays& _return, const Future ff, const int32_t timeout_millis) = 0;
  virtual void get_future_result_as_arrays(ResultAsArrays& _return, const Future ff, const int32_t timeout_millis) = 0;

  /**
   * Fetch asynchronous results
   * @param ff - Future object which has the asynchronous results
   * @return - result from async scanner/mutator
   * 
   * @param ff
   * @param timeout_millis
   */
  virtual void future_get_result_serialized(ResultSerialized& _return, const Future ff, const int32_t timeout_millis) = 0;
  virtual void get_future_result_serialized(ResultSerialized& _return, const Future ff, const int32_t timeout_millis) = 0;

  /**
   * Check if future object's queue is empty
   * 
   * @param ff
   */
  virtual bool future_is_empty(const Future ff) = 0;

  /**
   * Check if future object's queue is full
   * 
   * @param ff
   */
  virtual bool future_is_full(const Future ff) = 0;

  /**
   * Check if future object has been cancelled
   * 
   * @param ff
   */
  virtual bool future_is_cancelled(const Future ff) = 0;

  /**
   * Check if future object has outstanding operations
   * 
   * @param ff
   */
  virtual bool future_has_outstanding(const Future ff) = 0;

  /**
   * Close a future object
   * @param ff - the future object to be closed
   * 
   * @param ff
   */
  virtual void future_close(const Future ff) = 0;
  virtual void close_future(const Future ff) = 0;

  /**
   * Open a table scanner
   * @param ns - namespace id
   * @param table_name - table name
   * @param scan_spec - scan specification
   * 
   * @param ns
   * @param table_name
   * @param scan_spec
   */
  virtual Scanner scanner_open(const Namespace ns, const std::string& table_name, const ScanSpec& scan_spec) = 0;
  virtual Scanner open_scanner(const Namespace ns, const std::string& table_name, const ScanSpec& scan_spec) = 0;

  /**
   * Open an asynchronous table scanner
   * @param ns - namespace id
   * @param table_name - table name
   * @param future - callback object
   * @param scan_spec - scan specification
   * 
   * @param ns
   * @param table_name
   * @param future
   * @param scan_spec
   */
  virtual ScannerAsync async_scanner_open(const Namespace ns, const std::string& table_name, const Future future, const ScanSpec& scan_spec) = 0;
  virtual ScannerAsync open_scanner_async(const Namespace ns, const std::string& table_name, const Future future, const ScanSpec& scan_spec) = 0;

  /**
   * Close a table scanner
   * 
   * @param scanner - scanner id to close
   * 
   * @param scanner
   */
  virtual void scanner_close(const Scanner scanner) = 0;
  virtual void close_scanner(const Scanner scanner) = 0;

  /**
   * Cancel a table scanner
   * 
   * @param scanner - scanner id to close
   * 
   * @param scanner
   */
  virtual void async_scanner_cancel(const ScannerAsync scanner) = 0;
  virtual void cancel_scanner_async(const ScannerAsync scanner) = 0;

  /**
   * Close a table scanner
   * 
   * @param scanner - scanner id to close
   * 
   * @param scanner
   */
  virtual void async_scanner_close(const ScannerAsync scanner) = 0;
  virtual void close_scanner_async(const ScannerAsync scanner) = 0;

  /**
   * Iterate over cells of a scanner
   * 
   * @param scanner - scanner id
   * 
   * @param scanner
   */
  virtual void scanner_get_cells(std::vector<Cell> & _return, const Scanner scanner) = 0;
  virtual void next_cells(std::vector<Cell> & _return, const Scanner scanner) = 0;
  virtual void scanner_get_cells_as_arrays(std::vector<CellAsArray> & _return, const Scanner scanner) = 0;
  virtual void next_cells_as_arrays(std::vector<CellAsArray> & _return, const Scanner scanner) = 0;

  /**
   * Alternative interface returning buffer of serialized cells
   * 
   * @param scanner
   */
  virtual void scanner_get_cells_serialized(CellsSerialized& _return, const Scanner scanner) = 0;
  virtual void next_cells_serialized(CellsSerialized& _return, const Scanner scanner) = 0;

  /**
   * Iterate over rows of a scanner
   * 
   * @param scanner - scanner id
   * 
   * @param scanner
   */
  virtual void scanner_get_row(std::vector<Cell> & _return, const Scanner scanner) = 0;
  virtual void next_row(std::vector<Cell> & _return, const Scanner scanner) = 0;

  /**
   * Alternative interface using array as cell
   * 
   * @param scanner
   */
  virtual void scanner_get_row_as_arrays(std::vector<CellAsArray> & _return, const Scanner scanner) = 0;
  virtual void next_row_as_arrays(std::vector<CellAsArray> & _return, const Scanner scanner) = 0;

  /**
   * Alternate interface returning a buffer of serialized cells for iterating by row
   * for a given scanner
   * 
   * @param scanner - scanner id
   * 
   * @param scanner
   */
  virtual void scanner_get_row_serialized(CellsSerialized& _return, const Scanner scanner) = 0;
  virtual void next_row_serialized(CellsSerialized& _return, const Scanner scanner) = 0;

  /**
   * Get a row (convenience method for random access a row)
   * 
   * @param ns - namespace id
   * 
   * @param table_name - table name
   * 
   * @param row - row key
   * 
   * @return a list of cells (with row_keys unset)
   * 
   * @param ns
   * @param table_name
   * @param row
   */
  virtual void get_row(std::vector<Cell> & _return, const Namespace ns, const std::string& table_name, const std::string& row) = 0;

  /**
   * Alternative interface using array as cell
   * 
   * @param ns
   * @param name
   * @param row
   */
  virtual void get_row_as_arrays(std::vector<CellAsArray> & _return, const Namespace ns, const std::string& name, const std::string& row) = 0;

  /**
   * Alternative interface returning buffer of serialized cells
   * 
   * @param ns
   * @param table_name
   * @param row
   */
  virtual void get_row_serialized(CellsSerialized& _return, const Namespace ns, const std::string& table_name, const std::string& row) = 0;

  /**
   * Get a cell (convenience method for random access a cell)
   * 
   * @param ns - namespace id
   * 
   * @param table_name - table name
   * 
   * @param row - row key
   * 
   * @param column - column name
   * 
   * @return value (byte sequence)
   * 
   * @param ns
   * @param table_name
   * @param row
   * @param column
   */
  virtual void get_cell(Value& _return, const Namespace ns, const std::string& table_name, const std::string& row, const std::string& column) = 0;

  /**
   * Get cells (convenience method for access small amount of cells)
   * 
   * @param ns - namespace id
   *  
   * @param table_name - table name
   * 
   * @param scan_spec - scan specification
   * 
   * @return a list of cells (a cell with no row key set is assumed to have
   *         the same row key as the previous cell)
   * 
   * @param ns
   * @param table_name
   * @param scan_spec
   */
  virtual void get_cells(std::vector<Cell> & _return, const Namespace ns, const std::string& table_name, const ScanSpec& scan_spec) = 0;

  /**
   * Alternative interface using array as cell
   * 
   * @param ns
   * @param name
   * @param scan_spec
   */
  virtual void get_cells_as_arrays(std::vector<CellAsArray> & _return, const Namespace ns, const std::string& name, const ScanSpec& scan_spec) = 0;

  /**
   * Alternative interface returning buffer of serialized cells
   * 
   * @param ns
   * @param name
   * @param scan_spec
   */
  virtual void get_cells_serialized(CellsSerialized& _return, const Namespace ns, const std::string& name, const ScanSpec& scan_spec) = 0;

  /**
   * Create a shared mutator with specified MutateSpec.
   * Delete and recreate it if the mutator exists.
   * 
   * @param ns - namespace id
   *  
   * @param table_name - table name
   * 
   * @param mutate_spec - mutator specification
   * 
   * 
   * @param ns
   * @param table_name
   * @param mutate_spec
   */
  virtual void shared_mutator_refresh(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec) = 0;
  virtual void refresh_shared_mutator(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec) = 0;

  /**
   * Open a shared periodic mutator which causes cells to be written asyncronously.
   * Users beware: calling this method merely writes
   * cells to a local buffer and does not guarantee that the cells have been persisted.
   * If you want guaranteed durability, use the open_mutator+set_cells* interface instead.
   * 
   * @param ns - namespace id
   * 
   * @param table_name - table name
   * 
   * @param mutate_spec - mutator specification
   * 
   * @param cells - set of cells to be written
   * 
   * @param ns
   * @param table_name
   * @param mutate_spec
   * @param cells
   */
  virtual void shared_mutator_set_cells(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<Cell> & cells) = 0;
  virtual void offer_cells(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<Cell> & cells) = 0;

  /**
   * Alternative to offer_cell interface using array as cell
   * 
   * @param ns
   * @param table_name
   * @param mutate_spec
   * @param cells
   */
  virtual void shared_mutator_set_cells_as_arrays(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<CellAsArray> & cells) = 0;
  virtual void offer_cells_as_arrays(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<CellAsArray> & cells) = 0;

  /**
   * Open a shared periodic mutator which causes cells to be written asyncronously.
   * Users beware: calling this method merely writes
   * cells to a local buffer and does not guarantee that the cells have been persisted.
   * If you want guaranteed durability, use the open_mutator+set_cells* interface instead.
   * 
   * @param ns - namespace id
   * 
   * @param table_name - table name
   * 
   * @param mutate_spec - mutator specification
   * 
   * @param cell - cell to be written
   * 
   * @param ns
   * @param table_name
   * @param mutate_spec
   * @param cell
   */
  virtual void shared_mutator_set_cell(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const Cell& cell) = 0;
  virtual void offer_cell(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const Cell& cell) = 0;

  /**
   * Alternative to offer_cell interface using array as cell
   * 
   * @param ns
   * @param table_name
   * @param mutate_spec
   * @param cell
   */
  virtual void shared_mutator_set_cell_as_array(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const CellAsArray& cell) = 0;
  virtual void offer_cell_as_array(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const CellAsArray& cell) = 0;

  /**
   * Open a table mutator
   * 
   * @param ns - namespace id
   * 
   * @param table_name - table name
   * 
   * @param flags - mutator flags
   * 
   * @param flush_interval - auto-flush interval in milliseconds; 0 disables it.
   * 
   * @return mutator id
   * 
   * @param ns
   * @param table_name
   * @param flags
   * @param flush_interval
   */
  virtual Mutator mutator_open(const Namespace ns, const std::string& table_name, const int32_t flags, const int32_t flush_interval) = 0;
  virtual Mutator open_mutator(const Namespace ns, const std::string& table_name, const int32_t flags, const int32_t flush_interval) = 0;

  /**
   * Open an asynchronous table mutator
   * 
   * @param ns - namespace id
   * @param table_name - table name
   * @param future - callback object
   * @param flags - mutator flags
   * 
   * @return mutator id
   * 
   * @param ns
   * @param table_name
   * @param future
   * @param flags
   */
  virtual MutatorAsync async_mutator_open(const Namespace ns, const std::string& table_name, const Future future, const int32_t flags) = 0;
  virtual MutatorAsync open_mutator_async(const Namespace ns, const std::string& table_name, const Future future, const int32_t flags) = 0;

  /**
   * Close a table mutator
   * 
   * @param mutator - mutator id to close
   * 
   * @param mutator
   */
  virtual void mutator_close(const Mutator mutator) = 0;
  virtual void close_mutator(const Mutator mutator) = 0;

  /**
   * Cancel an asynchronous table mutator
   * 
   * @param mutator -  mutator id to cancel
   * 
   * @param mutator
   */
  virtual void async_mutator_cancel(const MutatorAsync mutator) = 0;
  virtual void cancel_mutator_async(const MutatorAsync mutator) = 0;

  /**
   * Close an asynchronous table mutator
   * 
   * @param mutator - mutator id to close
   * 
   * @param mutator
   */
  virtual void async_mutator_close(const MutatorAsync mutator) = 0;
  virtual void close_mutator_async(const MutatorAsync mutator) = 0;

  /**
   * Set a cell via mutator
   * 
   * @param mutator - mutator id
   * 
   * @param cell - the cell to set
   * 
   * @param mutator
   * @param cell
   */
  virtual void mutator_set_cell(const Mutator mutator, const Cell& cell) = 0;

  /**
   * Set a cell in the table
   * 
   * @param ns - namespace id
   * 
   * @param table_name - table name
   * 
   * @param cell - the cell to set
   * 
   * @param ns
   * @param table_name
   * @param cell
   */
  virtual void set_cell(const Namespace ns, const std::string& table_name, const Cell& cell) = 0;

  /**
   * Alternative interface using array as cell
   * 
   * @param mutator
   * @param cell
   */
  virtual void mutator_set_cell_as_array(const Mutator mutator, const CellAsArray& cell) = 0;

  /**
   * Alternative interface using array as cell
   * 
   * @param ns
   * @param table_name
   * @param cell
   */
  virtual void set_cell_as_array(const Namespace ns, const std::string& table_name, const CellAsArray& cell) = 0;

  /**
   * Put a list of cells into a table via mutator
   * 
   * @param mutator - mutator id
   * 
   * @param cells - a list of cells (a cell with no row key set is assumed
   *        to have the same row key as the previous cell)
   * 
   * @param mutator
   * @param cells
   */
  virtual void mutator_set_cells(const Mutator mutator, const std::vector<Cell> & cells) = 0;

  /**
   * Put a list of cells into a table
   * 
   * @param ns - namespace id
   * 
   * @param table_name - table name
   * 
   * @param cells - a list of cells (a cell with no row key set is assumed
   *        to have the same row key as the previous cell)
   * 
   * @param ns
   * @param table_name
   * @param cells
   */
  virtual void set_cells(const Namespace ns, const std::string& table_name, const std::vector<Cell> & cells) = 0;

  /**
   * Alternative interface using array as cell
   * 
   * @param mutator
   * @param cells
   */
  virtual void mutator_set_cells_as_arrays(const Mutator mutator, const std::vector<CellAsArray> & cells) = 0;

  /**
   * Alternative interface using array as cell
   * 
   * @param ns
   * @param table_name
   * @param cells
   */
  virtual void set_cells_as_arrays(const Namespace ns, const std::string& table_name, const std::vector<CellAsArray> & cells) = 0;

  /**
   * Alternative interface using buffer of serialized cells
   * 
   * @param mutator
   * @param cells
   * @param flush
   */
  virtual void mutator_set_cells_serialized(const Mutator mutator, const CellsSerialized& cells, const bool flush) = 0;

  /**
   * Alternative interface using buffer of serialized cells
   * 
   * @param ns
   * @param table_name
   * @param cells
   */
  virtual void set_cells_serialized(const Namespace ns, const std::string& table_name, const CellsSerialized& cells) = 0;

  /**
   * Flush mutator buffers
   * 
   * @param mutator
   */
  virtual void mutator_flush(const Mutator mutator) = 0;
  virtual void flush_mutator(const Mutator mutator) = 0;

  /**
   * Set a cell in the table using an asynchonous mutator
   * 
   * @param mutator - mutator id
   * 
   * @param cell - the cell to set
   * 
   * @param mutator
   * @param cell
   */
  virtual void async_mutator_set_cell(const MutatorAsync mutator, const Cell& cell) = 0;
  virtual void set_cell_async(const MutatorAsync mutator, const Cell& cell) = 0;

  /**
   * Alternative interface using array as cell using an asynchonous mutator
   * 
   * @param mutator
   * @param cell
   */
  virtual void async_mutator_set_cell_as_array(const MutatorAsync mutator, const CellAsArray& cell) = 0;
  virtual void set_cell_as_array_async(const MutatorAsync mutator, const CellAsArray& cell) = 0;

  /**
   * Put a list of cells into a table using asynchonous mutator
   * 
   * @param mutator - mutator id
   * 
   * @param cells - a list of cells (a cell with no row key set is assumed
   *        to have the same row key as the previous cell)
   * 
   * @param mutator
   * @param cells
   */
  virtual void async_mutator_set_cells(const MutatorAsync mutator, const std::vector<Cell> & cells) = 0;
  virtual void set_cells_async(const MutatorAsync mutator, const std::vector<Cell> & cells) = 0;

  /**
   * Alternative interface using array as cell
   * 
   * @param mutator
   * @param cells
   */
  virtual void async_mutator_set_cells_as_arrays(const MutatorAsync mutator, const std::vector<CellAsArray> & cells) = 0;
  virtual void set_cells_as_arrays_async(const MutatorAsync mutator, const std::vector<CellAsArray> & cells) = 0;

  /**
   * Alternative interface using buffer of serialized cells
   * 
   * @param mutator
   * @param cells
   * @param flush
   */
  virtual void async_mutator_set_cells_serialized(const MutatorAsync mutator, const CellsSerialized& cells, const bool flush) = 0;
  virtual void set_cells_serialized_async(const MutatorAsync mutator, const CellsSerialized& cells, const bool flush) = 0;

  /**
   * Flush mutator buffers
   * 
   * @param mutator
   */
  virtual void async_mutator_flush(const MutatorAsync mutator) = 0;
  virtual void flush_mutator_async(const MutatorAsync mutator) = 0;

  /**
   * Check if the namespace exists
   * 
   * @param ns - namespace name
   * 
   * @return true if ns exists, false ow
   * 
   * @param ns
   */
  virtual bool namespace_exists(const std::string& ns) = 0;
  virtual bool exists_namespace(const std::string& ns) = 0;

  /**
   * Check if the table exists
   * 
   * @param ns - namespace id
   * 
   * @param name - table name
   * 
   * @return true if table exists, false ow
   * 
   * @param ns
   * @param name
   */
  virtual bool exists_table(const Namespace ns, const std::string& name) = 0;
  virtual bool table_exists(const Namespace ns, const std::string& name) = 0;

  /**
   * Get the id of a table
   * 
   * @param ns - namespace id
   * 
   * @param table_name - table name
   * 
   * @return table id string
   * 
   * @param ns
   * @param table_name
   */
  virtual void table_get_id(std::string& _return, const Namespace ns, const std::string& table_name) = 0;
  virtual void get_table_id(std::string& _return, const Namespace ns, const std::string& table_name) = 0;

  /**
   * Get the schema of a table as a string (that can be used with create_table)
   * 
   * @param ns - namespace id
   * 
   * @param table_name - table name
   * 
   * @return schema string (in xml)
   * 
   * @param ns
   * @param table_name
   */
  virtual void table_get_schema_str(std::string& _return, const Namespace ns, const std::string& table_name) = 0;
  virtual void get_schema_str(std::string& _return, const Namespace ns, const std::string& table_name) = 0;

  /**
   * Get the schema of a table as a string along with column family ids
   * 
   * @param ns - namespace id
   * 
   * @param table_name - table name
   * 
   * @return schema string (in xml)
   * 
   * @param ns
   * @param table_name
   */
  virtual void table_get_schema_str_with_ids(std::string& _return, const Namespace ns, const std::string& table_name) = 0;
  virtual void get_schema_str_with_ids(std::string& _return, const Namespace ns, const std::string& table_name) = 0;

  /**
   * Get the schema of a table as a string (that can be used with create_table)
   *   
   * @param ns - namespace id
   * 
   * @param table_name - table name
   * 
   * @return schema object describing a table
   * 
   * @param ns
   * @param table_name
   */
  virtual void table_get_schema(Schema& _return, const Namespace ns, const std::string& table_name) = 0;
  virtual void get_schema(Schema& _return, const Namespace ns, const std::string& table_name) = 0;

  /**
   * Get a list of table names in the namespace
   * 
   * @param ns - namespace id
   * 
   * @return a list of table names
   * 
   * @param ns
   */
  virtual void get_tables(std::vector<std::string> & _return, const Namespace ns) = 0;

  /**
   * Get a list of namespaces and table names table names in the namespace
   * 
   * @param ns - namespace
   * 
   * @return a list of table names
   * 
   * @param ns
   */
  virtual void namespace_get_listing(std::vector<NamespaceListing> & _return, const Namespace ns) = 0;
  virtual void get_listing(std::vector<NamespaceListing> & _return, const Namespace ns) = 0;

  /**
   * Get a list of table splits
   * 
   * @param ns - namespace id
   * 
   * @param table_name - table name
   * 
   * @return a list of table names
   * 
   * @param ns
   * @param table_name
   */
  virtual void table_get_splits(std::vector<TableSplit> & _return, const Namespace ns, const std::string& table_name) = 0;
  virtual void get_table_splits(std::vector<TableSplit> & _return, const Namespace ns, const std::string& table_name) = 0;

  /**
   * Drop a namespace
   * 
   * @param ns - namespace name
   * 
   * @param if_exists - if true, don't barf if the table doesn't exist
   * 
   * @param ns
   * @param if_exists
   */
  virtual void namespace_drop(const std::string& ns, const bool if_exists) = 0;
  virtual void drop_namespace(const std::string& ns, const bool if_exists) = 0;

  /**
   * Rename a table
   * 
   * @param ns - namespace id
   * 
   * @param name - current table name
   * 
   * @param new_name - new table name
   * 
   * @param ns
   * @param name
   * @param new_name
   */
  virtual void rename_table(const Namespace ns, const std::string& name, const std::string& new_name) = 0;
  virtual void table_rename(const Namespace ns, const std::string& name, const std::string& new_name) = 0;

  /**
   * Drop a table
   * 
   * @param ns - namespace id
   * 
   * @param name - table name
   * 
   * @param if_exists - if true, don't barf if the table doesn't exist
   * 
   * @param ns
   * @param name
   * @param if_exists
   */
  virtual void drop_table(const Namespace ns, const std::string& name, const bool if_exists) = 0;
  virtual void table_drop(const Namespace ns, const std::string& name, const bool if_exists) = 0;

  /**
   * Generate a GUID
   * 
   * GUIDs are globally unique. The generated string is 36 bytes long and
   * has a format similar to "9cf7da31-307a-4bef-b65e-19fb05aa57d8".
   */
  virtual void generate_guid(std::string& _return) = 0;

  /**
   * Inserts a unique value into a table
   * 
   * This function inserts a unique value into a table. The table must be
   * created with TIME_ORDER DESC, MAX_VERSIONS 1 (although the latter is
   * optional).
   * 
   * If the value is empty then a new GUID will be assigned
   * (using @a generate_guid).
   * 
   * @param ns - namespace id
   * @param table_name - table name
   * @param key - the Key of the value
   * @param value - the unique value. Can be empty; in this case a new
   *    guid will be generated internally
   * 
   * @return the inserted unique value (which is identical to the @a value
   *    parameter or a new guid, if value is empty)
   * 
   * @param ns
   * @param table_name
   * @param key
   * @param value
   */
  virtual void create_cell_unique(std::string& _return, const Namespace ns, const std::string& table_name, const Key& key, const std::string& value) = 0;

  /**
   * Retrieves a descriptive error string from an error code
   * 
   * @param error_code - the numeric error code
   * 
   * @return the descriptive string, or "ERROR NOT REGISTERED" if the error
   *    code is unknown
   * 
   * @param error_code
   */
  virtual void error_get_text(std::string& _return, const int32_t error_code) = 0;

  /**
   * Status check.
   * @return Status information
   */
  virtual void status(Status& _return) = 0;

  /**
   * Shutdown broker.
   */
  virtual void shutdown() = 0;
};

class ClientServiceIfFactory {
 public:
  typedef ClientServiceIf Handler;

  virtual ~ClientServiceIfFactory() {}

  virtual ClientServiceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(ClientServiceIf* /* handler */) = 0;
};

class ClientServiceIfSingletonFactory : virtual public ClientServiceIfFactory {
 public:
  ClientServiceIfSingletonFactory(const ::apache::thrift::stdcxx::shared_ptr<ClientServiceIf>& iface) : iface_(iface) {}
  virtual ~ClientServiceIfSingletonFactory() {}

  virtual ClientServiceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(ClientServiceIf* /* handler */) {}

 protected:
  ::apache::thrift::stdcxx::shared_ptr<ClientServiceIf> iface_;
};

class ClientServiceNull : virtual public ClientServiceIf {
 public:
  virtual ~ClientServiceNull() {}
  void namespace_create(const std::string& /* ns */) {
    return;
  }
  void create_namespace(const std::string& /* ns */) {
    return;
  }
  void table_create(const Namespace /* ns */, const std::string& /* table_name */, const Schema& /* schema */) {
    return;
  }
  void table_alter(const Namespace /* ns */, const std::string& /* table_name */, const Schema& /* schema */) {
    return;
  }
  void refresh_table(const Namespace /* ns */, const std::string& /* table_name */) {
    return;
  }
  Namespace namespace_open(const std::string& /* ns */) {
    Namespace _return = 0;
    return _return;
  }
  Namespace open_namespace(const std::string& /* ns */) {
    Namespace _return = 0;
    return _return;
  }
  void namespace_close(const Namespace /* ns */) {
    return;
  }
  void close_namespace(const Namespace /* ns */) {
    return;
  }
  Future future_open(const int32_t /* capacity */) {
    Future _return = 0;
    return _return;
  }
  Future open_future(const int32_t /* capacity */) {
    Future _return = 0;
    return _return;
  }
  void future_cancel(const Future /* ff */) {
    return;
  }
  void cancel_future(const Future /* ff */) {
    return;
  }
  void future_get_result(Result& /* _return */, const Future /* ff */, const int32_t /* timeout_millis */) {
    return;
  }
  void get_future_result(Result& /* _return */, const Future /* ff */, const int32_t /* timeout_millis */) {
    return;
  }
  void future_get_result_as_arrays(ResultAsArrays& /* _return */, const Future /* ff */, const int32_t /* timeout_millis */) {
    return;
  }
  void get_future_result_as_arrays(ResultAsArrays& /* _return */, const Future /* ff */, const int32_t /* timeout_millis */) {
    return;
  }
  void future_get_result_serialized(ResultSerialized& /* _return */, const Future /* ff */, const int32_t /* timeout_millis */) {
    return;
  }
  void get_future_result_serialized(ResultSerialized& /* _return */, const Future /* ff */, const int32_t /* timeout_millis */) {
    return;
  }
  bool future_is_empty(const Future /* ff */) {
    bool _return = false;
    return _return;
  }
  bool future_is_full(const Future /* ff */) {
    bool _return = false;
    return _return;
  }
  bool future_is_cancelled(const Future /* ff */) {
    bool _return = false;
    return _return;
  }
  bool future_has_outstanding(const Future /* ff */) {
    bool _return = false;
    return _return;
  }
  void future_close(const Future /* ff */) {
    return;
  }
  void close_future(const Future /* ff */) {
    return;
  }
  Scanner scanner_open(const Namespace /* ns */, const std::string& /* table_name */, const ScanSpec& /* scan_spec */) {
    Scanner _return = 0;
    return _return;
  }
  Scanner open_scanner(const Namespace /* ns */, const std::string& /* table_name */, const ScanSpec& /* scan_spec */) {
    Scanner _return = 0;
    return _return;
  }
  ScannerAsync async_scanner_open(const Namespace /* ns */, const std::string& /* table_name */, const Future /* future */, const ScanSpec& /* scan_spec */) {
    ScannerAsync _return = 0;
    return _return;
  }
  ScannerAsync open_scanner_async(const Namespace /* ns */, const std::string& /* table_name */, const Future /* future */, const ScanSpec& /* scan_spec */) {
    ScannerAsync _return = 0;
    return _return;
  }
  void scanner_close(const Scanner /* scanner */) {
    return;
  }
  void close_scanner(const Scanner /* scanner */) {
    return;
  }
  void async_scanner_cancel(const ScannerAsync /* scanner */) {
    return;
  }
  void cancel_scanner_async(const ScannerAsync /* scanner */) {
    return;
  }
  void async_scanner_close(const ScannerAsync /* scanner */) {
    return;
  }
  void close_scanner_async(const ScannerAsync /* scanner */) {
    return;
  }
  void scanner_get_cells(std::vector<Cell> & /* _return */, const Scanner /* scanner */) {
    return;
  }
  void next_cells(std::vector<Cell> & /* _return */, const Scanner /* scanner */) {
    return;
  }
  void scanner_get_cells_as_arrays(std::vector<CellAsArray> & /* _return */, const Scanner /* scanner */) {
    return;
  }
  void next_cells_as_arrays(std::vector<CellAsArray> & /* _return */, const Scanner /* scanner */) {
    return;
  }
  void scanner_get_cells_serialized(CellsSerialized& /* _return */, const Scanner /* scanner */) {
    return;
  }
  void next_cells_serialized(CellsSerialized& /* _return */, const Scanner /* scanner */) {
    return;
  }
  void scanner_get_row(std::vector<Cell> & /* _return */, const Scanner /* scanner */) {
    return;
  }
  void next_row(std::vector<Cell> & /* _return */, const Scanner /* scanner */) {
    return;
  }
  void scanner_get_row_as_arrays(std::vector<CellAsArray> & /* _return */, const Scanner /* scanner */) {
    return;
  }
  void next_row_as_arrays(std::vector<CellAsArray> & /* _return */, const Scanner /* scanner */) {
    return;
  }
  void scanner_get_row_serialized(CellsSerialized& /* _return */, const Scanner /* scanner */) {
    return;
  }
  void next_row_serialized(CellsSerialized& /* _return */, const Scanner /* scanner */) {
    return;
  }
  void get_row(std::vector<Cell> & /* _return */, const Namespace /* ns */, const std::string& /* table_name */, const std::string& /* row */) {
    return;
  }
  void get_row_as_arrays(std::vector<CellAsArray> & /* _return */, const Namespace /* ns */, const std::string& /* name */, const std::string& /* row */) {
    return;
  }
  void get_row_serialized(CellsSerialized& /* _return */, const Namespace /* ns */, const std::string& /* table_name */, const std::string& /* row */) {
    return;
  }
  void get_cell(Value& /* _return */, const Namespace /* ns */, const std::string& /* table_name */, const std::string& /* row */, const std::string& /* column */) {
    return;
  }
  void get_cells(std::vector<Cell> & /* _return */, const Namespace /* ns */, const std::string& /* table_name */, const ScanSpec& /* scan_spec */) {
    return;
  }
  void get_cells_as_arrays(std::vector<CellAsArray> & /* _return */, const Namespace /* ns */, const std::string& /* name */, const ScanSpec& /* scan_spec */) {
    return;
  }
  void get_cells_serialized(CellsSerialized& /* _return */, const Namespace /* ns */, const std::string& /* name */, const ScanSpec& /* scan_spec */) {
    return;
  }
  void shared_mutator_refresh(const Namespace /* ns */, const std::string& /* table_name */, const MutateSpec& /* mutate_spec */) {
    return;
  }
  void refresh_shared_mutator(const Namespace /* ns */, const std::string& /* table_name */, const MutateSpec& /* mutate_spec */) {
    return;
  }
  void shared_mutator_set_cells(const Namespace /* ns */, const std::string& /* table_name */, const MutateSpec& /* mutate_spec */, const std::vector<Cell> & /* cells */) {
    return;
  }
  void offer_cells(const Namespace /* ns */, const std::string& /* table_name */, const MutateSpec& /* mutate_spec */, const std::vector<Cell> & /* cells */) {
    return;
  }
  void shared_mutator_set_cells_as_arrays(const Namespace /* ns */, const std::string& /* table_name */, const MutateSpec& /* mutate_spec */, const std::vector<CellAsArray> & /* cells */) {
    return;
  }
  void offer_cells_as_arrays(const Namespace /* ns */, const std::string& /* table_name */, const MutateSpec& /* mutate_spec */, const std::vector<CellAsArray> & /* cells */) {
    return;
  }
  void shared_mutator_set_cell(const Namespace /* ns */, const std::string& /* table_name */, const MutateSpec& /* mutate_spec */, const Cell& /* cell */) {
    return;
  }
  void offer_cell(const Namespace /* ns */, const std::string& /* table_name */, const MutateSpec& /* mutate_spec */, const Cell& /* cell */) {
    return;
  }
  void shared_mutator_set_cell_as_array(const Namespace /* ns */, const std::string& /* table_name */, const MutateSpec& /* mutate_spec */, const CellAsArray& /* cell */) {
    return;
  }
  void offer_cell_as_array(const Namespace /* ns */, const std::string& /* table_name */, const MutateSpec& /* mutate_spec */, const CellAsArray& /* cell */) {
    return;
  }
  Mutator mutator_open(const Namespace /* ns */, const std::string& /* table_name */, const int32_t /* flags */, const int32_t /* flush_interval */) {
    Mutator _return = 0;
    return _return;
  }
  Mutator open_mutator(const Namespace /* ns */, const std::string& /* table_name */, const int32_t /* flags */, const int32_t /* flush_interval */) {
    Mutator _return = 0;
    return _return;
  }
  MutatorAsync async_mutator_open(const Namespace /* ns */, const std::string& /* table_name */, const Future /* future */, const int32_t /* flags */) {
    MutatorAsync _return = 0;
    return _return;
  }
  MutatorAsync open_mutator_async(const Namespace /* ns */, const std::string& /* table_name */, const Future /* future */, const int32_t /* flags */) {
    MutatorAsync _return = 0;
    return _return;
  }
  void mutator_close(const Mutator /* mutator */) {
    return;
  }
  void close_mutator(const Mutator /* mutator */) {
    return;
  }
  void async_mutator_cancel(const MutatorAsync /* mutator */) {
    return;
  }
  void cancel_mutator_async(const MutatorAsync /* mutator */) {
    return;
  }
  void async_mutator_close(const MutatorAsync /* mutator */) {
    return;
  }
  void close_mutator_async(const MutatorAsync /* mutator */) {
    return;
  }
  void mutator_set_cell(const Mutator /* mutator */, const Cell& /* cell */) {
    return;
  }
  void set_cell(const Namespace /* ns */, const std::string& /* table_name */, const Cell& /* cell */) {
    return;
  }
  void mutator_set_cell_as_array(const Mutator /* mutator */, const CellAsArray& /* cell */) {
    return;
  }
  void set_cell_as_array(const Namespace /* ns */, const std::string& /* table_name */, const CellAsArray& /* cell */) {
    return;
  }
  void mutator_set_cells(const Mutator /* mutator */, const std::vector<Cell> & /* cells */) {
    return;
  }
  void set_cells(const Namespace /* ns */, const std::string& /* table_name */, const std::vector<Cell> & /* cells */) {
    return;
  }
  void mutator_set_cells_as_arrays(const Mutator /* mutator */, const std::vector<CellAsArray> & /* cells */) {
    return;
  }
  void set_cells_as_arrays(const Namespace /* ns */, const std::string& /* table_name */, const std::vector<CellAsArray> & /* cells */) {
    return;
  }
  void mutator_set_cells_serialized(const Mutator /* mutator */, const CellsSerialized& /* cells */, const bool /* flush */) {
    return;
  }
  void set_cells_serialized(const Namespace /* ns */, const std::string& /* table_name */, const CellsSerialized& /* cells */) {
    return;
  }
  void mutator_flush(const Mutator /* mutator */) {
    return;
  }
  void flush_mutator(const Mutator /* mutator */) {
    return;
  }
  void async_mutator_set_cell(const MutatorAsync /* mutator */, const Cell& /* cell */) {
    return;
  }
  void set_cell_async(const MutatorAsync /* mutator */, const Cell& /* cell */) {
    return;
  }
  void async_mutator_set_cell_as_array(const MutatorAsync /* mutator */, const CellAsArray& /* cell */) {
    return;
  }
  void set_cell_as_array_async(const MutatorAsync /* mutator */, const CellAsArray& /* cell */) {
    return;
  }
  void async_mutator_set_cells(const MutatorAsync /* mutator */, const std::vector<Cell> & /* cells */) {
    return;
  }
  void set_cells_async(const MutatorAsync /* mutator */, const std::vector<Cell> & /* cells */) {
    return;
  }
  void async_mutator_set_cells_as_arrays(const MutatorAsync /* mutator */, const std::vector<CellAsArray> & /* cells */) {
    return;
  }
  void set_cells_as_arrays_async(const MutatorAsync /* mutator */, const std::vector<CellAsArray> & /* cells */) {
    return;
  }
  void async_mutator_set_cells_serialized(const MutatorAsync /* mutator */, const CellsSerialized& /* cells */, const bool /* flush */) {
    return;
  }
  void set_cells_serialized_async(const MutatorAsync /* mutator */, const CellsSerialized& /* cells */, const bool /* flush */) {
    return;
  }
  void async_mutator_flush(const MutatorAsync /* mutator */) {
    return;
  }
  void flush_mutator_async(const MutatorAsync /* mutator */) {
    return;
  }
  bool namespace_exists(const std::string& /* ns */) {
    bool _return = false;
    return _return;
  }
  bool exists_namespace(const std::string& /* ns */) {
    bool _return = false;
    return _return;
  }
  bool exists_table(const Namespace /* ns */, const std::string& /* name */) {
    bool _return = false;
    return _return;
  }
  bool table_exists(const Namespace /* ns */, const std::string& /* name */) {
    bool _return = false;
    return _return;
  }
  void table_get_id(std::string& /* _return */, const Namespace /* ns */, const std::string& /* table_name */) {
    return;
  }
  void get_table_id(std::string& /* _return */, const Namespace /* ns */, const std::string& /* table_name */) {
    return;
  }
  void table_get_schema_str(std::string& /* _return */, const Namespace /* ns */, const std::string& /* table_name */) {
    return;
  }
  void get_schema_str(std::string& /* _return */, const Namespace /* ns */, const std::string& /* table_name */) {
    return;
  }
  void table_get_schema_str_with_ids(std::string& /* _return */, const Namespace /* ns */, const std::string& /* table_name */) {
    return;
  }
  void get_schema_str_with_ids(std::string& /* _return */, const Namespace /* ns */, const std::string& /* table_name */) {
    return;
  }
  void table_get_schema(Schema& /* _return */, const Namespace /* ns */, const std::string& /* table_name */) {
    return;
  }
  void get_schema(Schema& /* _return */, const Namespace /* ns */, const std::string& /* table_name */) {
    return;
  }
  void get_tables(std::vector<std::string> & /* _return */, const Namespace /* ns */) {
    return;
  }
  void namespace_get_listing(std::vector<NamespaceListing> & /* _return */, const Namespace /* ns */) {
    return;
  }
  void get_listing(std::vector<NamespaceListing> & /* _return */, const Namespace /* ns */) {
    return;
  }
  void table_get_splits(std::vector<TableSplit> & /* _return */, const Namespace /* ns */, const std::string& /* table_name */) {
    return;
  }
  void get_table_splits(std::vector<TableSplit> & /* _return */, const Namespace /* ns */, const std::string& /* table_name */) {
    return;
  }
  void namespace_drop(const std::string& /* ns */, const bool /* if_exists */) {
    return;
  }
  void drop_namespace(const std::string& /* ns */, const bool /* if_exists */) {
    return;
  }
  void rename_table(const Namespace /* ns */, const std::string& /* name */, const std::string& /* new_name */) {
    return;
  }
  void table_rename(const Namespace /* ns */, const std::string& /* name */, const std::string& /* new_name */) {
    return;
  }
  void drop_table(const Namespace /* ns */, const std::string& /* name */, const bool /* if_exists */) {
    return;
  }
  void table_drop(const Namespace /* ns */, const std::string& /* name */, const bool /* if_exists */) {
    return;
  }
  void generate_guid(std::string& /* _return */) {
    return;
  }
  void create_cell_unique(std::string& /* _return */, const Namespace /* ns */, const std::string& /* table_name */, const Key& /* key */, const std::string& /* value */) {
    return;
  }
  void error_get_text(std::string& /* _return */, const int32_t /* error_code */) {
    return;
  }
  void status(Status& /* _return */) {
    return;
  }
  void shutdown() {
    return;
  }
};

typedef struct _ClientService_namespace_create_args__isset {
  _ClientService_namespace_create_args__isset() : ns(false) {}
  bool ns :1;
} _ClientService_namespace_create_args__isset;

class ClientService_namespace_create_args {
 public:

  ClientService_namespace_create_args(const ClientService_namespace_create_args&);
  ClientService_namespace_create_args& operator=(const ClientService_namespace_create_args&);
  ClientService_namespace_create_args() : ns() {
  }

  virtual ~ClientService_namespace_create_args() throw();
  std::string ns;

  _ClientService_namespace_create_args__isset __isset;

  void __set_ns(const std::string& val);

  bool operator == (const ClientService_namespace_create_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const ClientService_namespace_create_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_namespace_create_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_namespace_create_pargs {
 public:


  virtual ~ClientService_namespace_create_pargs() throw();
  const std::string* ns;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_namespace_create_result__isset {
  _ClientService_namespace_create_result__isset() : e(false) {}
  bool e :1;
} _ClientService_namespace_create_result__isset;

class ClientService_namespace_create_result {
 public:

  ClientService_namespace_create_result(const ClientService_namespace_create_result&);
  ClientService_namespace_create_result& operator=(const ClientService_namespace_create_result&);
  ClientService_namespace_create_result() {
  }

  virtual ~ClientService_namespace_create_result() throw();
  ClientException e;

  _ClientService_namespace_create_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_namespace_create_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_namespace_create_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_namespace_create_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_namespace_create_presult__isset {
  _ClientService_namespace_create_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_namespace_create_presult__isset;

class ClientService_namespace_create_presult {
 public:


  virtual ~ClientService_namespace_create_presult() throw();
  ClientException e;

  _ClientService_namespace_create_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_create_namespace_args__isset {
  _ClientService_create_namespace_args__isset() : ns(false) {}
  bool ns :1;
} _ClientService_create_namespace_args__isset;

class ClientService_create_namespace_args {
 public:

  ClientService_create_namespace_args(const ClientService_create_namespace_args&);
  ClientService_create_namespace_args& operator=(const ClientService_create_namespace_args&);
  ClientService_create_namespace_args() : ns() {
  }

  virtual ~ClientService_create_namespace_args() throw();
  std::string ns;

  _ClientService_create_namespace_args__isset __isset;

  void __set_ns(const std::string& val);

  bool operator == (const ClientService_create_namespace_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const ClientService_create_namespace_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_create_namespace_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_create_namespace_pargs {
 public:


  virtual ~ClientService_create_namespace_pargs() throw();
  const std::string* ns;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_create_namespace_result__isset {
  _ClientService_create_namespace_result__isset() : e(false) {}
  bool e :1;
} _ClientService_create_namespace_result__isset;

class ClientService_create_namespace_result {
 public:

  ClientService_create_namespace_result(const ClientService_create_namespace_result&);
  ClientService_create_namespace_result& operator=(const ClientService_create_namespace_result&);
  ClientService_create_namespace_result() {
  }

  virtual ~ClientService_create_namespace_result() throw();
  ClientException e;

  _ClientService_create_namespace_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_create_namespace_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_create_namespace_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_create_namespace_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_create_namespace_presult__isset {
  _ClientService_create_namespace_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_create_namespace_presult__isset;

class ClientService_create_namespace_presult {
 public:


  virtual ~ClientService_create_namespace_presult() throw();
  ClientException e;

  _ClientService_create_namespace_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_table_create_args__isset {
  _ClientService_table_create_args__isset() : ns(false), table_name(false), schema(false) {}
  bool ns :1;
  bool table_name :1;
  bool schema :1;
} _ClientService_table_create_args__isset;

class ClientService_table_create_args {
 public:

  ClientService_table_create_args(const ClientService_table_create_args&);
  ClientService_table_create_args& operator=(const ClientService_table_create_args&);
  ClientService_table_create_args() : ns(0), table_name() {
  }

  virtual ~ClientService_table_create_args() throw();
  Namespace ns;
  std::string table_name;
  Schema schema;

  _ClientService_table_create_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_schema(const Schema& val);

  bool operator == (const ClientService_table_create_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(schema == rhs.schema))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_create_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_create_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_table_create_pargs {
 public:


  virtual ~ClientService_table_create_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const Schema* schema;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_create_result__isset {
  _ClientService_table_create_result__isset() : e(false) {}
  bool e :1;
} _ClientService_table_create_result__isset;

class ClientService_table_create_result {
 public:

  ClientService_table_create_result(const ClientService_table_create_result&);
  ClientService_table_create_result& operator=(const ClientService_table_create_result&);
  ClientService_table_create_result() {
  }

  virtual ~ClientService_table_create_result() throw();
  ClientException e;

  _ClientService_table_create_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_table_create_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_create_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_create_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_create_presult__isset {
  _ClientService_table_create_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_table_create_presult__isset;

class ClientService_table_create_presult {
 public:


  virtual ~ClientService_table_create_presult() throw();
  ClientException e;

  _ClientService_table_create_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_table_alter_args__isset {
  _ClientService_table_alter_args__isset() : ns(false), table_name(false), schema(false) {}
  bool ns :1;
  bool table_name :1;
  bool schema :1;
} _ClientService_table_alter_args__isset;

class ClientService_table_alter_args {
 public:

  ClientService_table_alter_args(const ClientService_table_alter_args&);
  ClientService_table_alter_args& operator=(const ClientService_table_alter_args&);
  ClientService_table_alter_args() : ns(0), table_name() {
  }

  virtual ~ClientService_table_alter_args() throw();
  Namespace ns;
  std::string table_name;
  Schema schema;

  _ClientService_table_alter_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_schema(const Schema& val);

  bool operator == (const ClientService_table_alter_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(schema == rhs.schema))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_alter_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_alter_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_table_alter_pargs {
 public:


  virtual ~ClientService_table_alter_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const Schema* schema;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_alter_result__isset {
  _ClientService_table_alter_result__isset() : e(false) {}
  bool e :1;
} _ClientService_table_alter_result__isset;

class ClientService_table_alter_result {
 public:

  ClientService_table_alter_result(const ClientService_table_alter_result&);
  ClientService_table_alter_result& operator=(const ClientService_table_alter_result&);
  ClientService_table_alter_result() {
  }

  virtual ~ClientService_table_alter_result() throw();
  ClientException e;

  _ClientService_table_alter_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_table_alter_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_alter_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_alter_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_alter_presult__isset {
  _ClientService_table_alter_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_table_alter_presult__isset;

class ClientService_table_alter_presult {
 public:


  virtual ~ClientService_table_alter_presult() throw();
  ClientException e;

  _ClientService_table_alter_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_refresh_table_args__isset {
  _ClientService_refresh_table_args__isset() : ns(false), table_name(false) {}
  bool ns :1;
  bool table_name :1;
} _ClientService_refresh_table_args__isset;

class ClientService_refresh_table_args {
 public:

  ClientService_refresh_table_args(const ClientService_refresh_table_args&);
  ClientService_refresh_table_args& operator=(const ClientService_refresh_table_args&);
  ClientService_refresh_table_args() : ns(0), table_name() {
  }

  virtual ~ClientService_refresh_table_args() throw();
  Namespace ns;
  std::string table_name;

  _ClientService_refresh_table_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  bool operator == (const ClientService_refresh_table_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    return true;
  }
  bool operator != (const ClientService_refresh_table_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_refresh_table_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_refresh_table_pargs {
 public:


  virtual ~ClientService_refresh_table_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_refresh_table_result__isset {
  _ClientService_refresh_table_result__isset() : e(false) {}
  bool e :1;
} _ClientService_refresh_table_result__isset;

class ClientService_refresh_table_result {
 public:

  ClientService_refresh_table_result(const ClientService_refresh_table_result&);
  ClientService_refresh_table_result& operator=(const ClientService_refresh_table_result&);
  ClientService_refresh_table_result() {
  }

  virtual ~ClientService_refresh_table_result() throw();
  ClientException e;

  _ClientService_refresh_table_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_refresh_table_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_refresh_table_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_refresh_table_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_refresh_table_presult__isset {
  _ClientService_refresh_table_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_refresh_table_presult__isset;

class ClientService_refresh_table_presult {
 public:


  virtual ~ClientService_refresh_table_presult() throw();
  ClientException e;

  _ClientService_refresh_table_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_namespace_open_args__isset {
  _ClientService_namespace_open_args__isset() : ns(false) {}
  bool ns :1;
} _ClientService_namespace_open_args__isset;

class ClientService_namespace_open_args {
 public:

  ClientService_namespace_open_args(const ClientService_namespace_open_args&);
  ClientService_namespace_open_args& operator=(const ClientService_namespace_open_args&);
  ClientService_namespace_open_args() : ns() {
  }

  virtual ~ClientService_namespace_open_args() throw();
  std::string ns;

  _ClientService_namespace_open_args__isset __isset;

  void __set_ns(const std::string& val);

  bool operator == (const ClientService_namespace_open_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const ClientService_namespace_open_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_namespace_open_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_namespace_open_pargs {
 public:


  virtual ~ClientService_namespace_open_pargs() throw();
  const std::string* ns;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_namespace_open_result__isset {
  _ClientService_namespace_open_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_namespace_open_result__isset;

class ClientService_namespace_open_result {
 public:

  ClientService_namespace_open_result(const ClientService_namespace_open_result&);
  ClientService_namespace_open_result& operator=(const ClientService_namespace_open_result&);
  ClientService_namespace_open_result() : success(0) {
  }

  virtual ~ClientService_namespace_open_result() throw();
  Namespace success;
  ClientException e;

  _ClientService_namespace_open_result__isset __isset;

  void __set_success(const Namespace val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_namespace_open_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_namespace_open_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_namespace_open_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_namespace_open_presult__isset {
  _ClientService_namespace_open_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_namespace_open_presult__isset;

class ClientService_namespace_open_presult {
 public:


  virtual ~ClientService_namespace_open_presult() throw();
  Namespace* success;
  ClientException e;

  _ClientService_namespace_open_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_open_namespace_args__isset {
  _ClientService_open_namespace_args__isset() : ns(false) {}
  bool ns :1;
} _ClientService_open_namespace_args__isset;

class ClientService_open_namespace_args {
 public:

  ClientService_open_namespace_args(const ClientService_open_namespace_args&);
  ClientService_open_namespace_args& operator=(const ClientService_open_namespace_args&);
  ClientService_open_namespace_args() : ns() {
  }

  virtual ~ClientService_open_namespace_args() throw();
  std::string ns;

  _ClientService_open_namespace_args__isset __isset;

  void __set_ns(const std::string& val);

  bool operator == (const ClientService_open_namespace_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const ClientService_open_namespace_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_open_namespace_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_open_namespace_pargs {
 public:


  virtual ~ClientService_open_namespace_pargs() throw();
  const std::string* ns;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_open_namespace_result__isset {
  _ClientService_open_namespace_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_open_namespace_result__isset;

class ClientService_open_namespace_result {
 public:

  ClientService_open_namespace_result(const ClientService_open_namespace_result&);
  ClientService_open_namespace_result& operator=(const ClientService_open_namespace_result&);
  ClientService_open_namespace_result() : success(0) {
  }

  virtual ~ClientService_open_namespace_result() throw();
  Namespace success;
  ClientException e;

  _ClientService_open_namespace_result__isset __isset;

  void __set_success(const Namespace val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_open_namespace_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_open_namespace_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_open_namespace_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_open_namespace_presult__isset {
  _ClientService_open_namespace_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_open_namespace_presult__isset;

class ClientService_open_namespace_presult {
 public:


  virtual ~ClientService_open_namespace_presult() throw();
  Namespace* success;
  ClientException e;

  _ClientService_open_namespace_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_namespace_close_args__isset {
  _ClientService_namespace_close_args__isset() : ns(false) {}
  bool ns :1;
} _ClientService_namespace_close_args__isset;

class ClientService_namespace_close_args {
 public:

  ClientService_namespace_close_args(const ClientService_namespace_close_args&);
  ClientService_namespace_close_args& operator=(const ClientService_namespace_close_args&);
  ClientService_namespace_close_args() : ns(0) {
  }

  virtual ~ClientService_namespace_close_args() throw();
  Namespace ns;

  _ClientService_namespace_close_args__isset __isset;

  void __set_ns(const Namespace val);

  bool operator == (const ClientService_namespace_close_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const ClientService_namespace_close_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_namespace_close_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_namespace_close_pargs {
 public:


  virtual ~ClientService_namespace_close_pargs() throw();
  const Namespace* ns;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_namespace_close_result__isset {
  _ClientService_namespace_close_result__isset() : e(false) {}
  bool e :1;
} _ClientService_namespace_close_result__isset;

class ClientService_namespace_close_result {
 public:

  ClientService_namespace_close_result(const ClientService_namespace_close_result&);
  ClientService_namespace_close_result& operator=(const ClientService_namespace_close_result&);
  ClientService_namespace_close_result() {
  }

  virtual ~ClientService_namespace_close_result() throw();
  ClientException e;

  _ClientService_namespace_close_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_namespace_close_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_namespace_close_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_namespace_close_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_namespace_close_presult__isset {
  _ClientService_namespace_close_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_namespace_close_presult__isset;

class ClientService_namespace_close_presult {
 public:


  virtual ~ClientService_namespace_close_presult() throw();
  ClientException e;

  _ClientService_namespace_close_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_close_namespace_args__isset {
  _ClientService_close_namespace_args__isset() : ns(false) {}
  bool ns :1;
} _ClientService_close_namespace_args__isset;

class ClientService_close_namespace_args {
 public:

  ClientService_close_namespace_args(const ClientService_close_namespace_args&);
  ClientService_close_namespace_args& operator=(const ClientService_close_namespace_args&);
  ClientService_close_namespace_args() : ns(0) {
  }

  virtual ~ClientService_close_namespace_args() throw();
  Namespace ns;

  _ClientService_close_namespace_args__isset __isset;

  void __set_ns(const Namespace val);

  bool operator == (const ClientService_close_namespace_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const ClientService_close_namespace_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_close_namespace_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_close_namespace_pargs {
 public:


  virtual ~ClientService_close_namespace_pargs() throw();
  const Namespace* ns;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_close_namespace_result__isset {
  _ClientService_close_namespace_result__isset() : e(false) {}
  bool e :1;
} _ClientService_close_namespace_result__isset;

class ClientService_close_namespace_result {
 public:

  ClientService_close_namespace_result(const ClientService_close_namespace_result&);
  ClientService_close_namespace_result& operator=(const ClientService_close_namespace_result&);
  ClientService_close_namespace_result() {
  }

  virtual ~ClientService_close_namespace_result() throw();
  ClientException e;

  _ClientService_close_namespace_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_close_namespace_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_close_namespace_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_close_namespace_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_close_namespace_presult__isset {
  _ClientService_close_namespace_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_close_namespace_presult__isset;

class ClientService_close_namespace_presult {
 public:


  virtual ~ClientService_close_namespace_presult() throw();
  ClientException e;

  _ClientService_close_namespace_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_future_open_args__isset {
  _ClientService_future_open_args__isset() : capacity(true) {}
  bool capacity :1;
} _ClientService_future_open_args__isset;

class ClientService_future_open_args {
 public:

  ClientService_future_open_args(const ClientService_future_open_args&);
  ClientService_future_open_args& operator=(const ClientService_future_open_args&);
  ClientService_future_open_args() : capacity(0) {
  }

  virtual ~ClientService_future_open_args() throw();
  int32_t capacity;

  _ClientService_future_open_args__isset __isset;

  void __set_capacity(const int32_t val);

  bool operator == (const ClientService_future_open_args & rhs) const
  {
    if (!(capacity == rhs.capacity))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_open_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_open_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_future_open_pargs {
 public:


  virtual ~ClientService_future_open_pargs() throw();
  const int32_t* capacity;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_open_result__isset {
  _ClientService_future_open_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_future_open_result__isset;

class ClientService_future_open_result {
 public:

  ClientService_future_open_result(const ClientService_future_open_result&);
  ClientService_future_open_result& operator=(const ClientService_future_open_result&);
  ClientService_future_open_result() : success(0) {
  }

  virtual ~ClientService_future_open_result() throw();
  Future success;
  ClientException e;

  _ClientService_future_open_result__isset __isset;

  void __set_success(const Future val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_future_open_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_open_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_open_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_open_presult__isset {
  _ClientService_future_open_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_future_open_presult__isset;

class ClientService_future_open_presult {
 public:


  virtual ~ClientService_future_open_presult() throw();
  Future* success;
  ClientException e;

  _ClientService_future_open_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_open_future_args__isset {
  _ClientService_open_future_args__isset() : capacity(true) {}
  bool capacity :1;
} _ClientService_open_future_args__isset;

class ClientService_open_future_args {
 public:

  ClientService_open_future_args(const ClientService_open_future_args&);
  ClientService_open_future_args& operator=(const ClientService_open_future_args&);
  ClientService_open_future_args() : capacity(0) {
  }

  virtual ~ClientService_open_future_args() throw();
  int32_t capacity;

  _ClientService_open_future_args__isset __isset;

  void __set_capacity(const int32_t val);

  bool operator == (const ClientService_open_future_args & rhs) const
  {
    if (!(capacity == rhs.capacity))
      return false;
    return true;
  }
  bool operator != (const ClientService_open_future_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_open_future_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_open_future_pargs {
 public:


  virtual ~ClientService_open_future_pargs() throw();
  const int32_t* capacity;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_open_future_result__isset {
  _ClientService_open_future_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_open_future_result__isset;

class ClientService_open_future_result {
 public:

  ClientService_open_future_result(const ClientService_open_future_result&);
  ClientService_open_future_result& operator=(const ClientService_open_future_result&);
  ClientService_open_future_result() : success(0) {
  }

  virtual ~ClientService_open_future_result() throw();
  Future success;
  ClientException e;

  _ClientService_open_future_result__isset __isset;

  void __set_success(const Future val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_open_future_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_open_future_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_open_future_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_open_future_presult__isset {
  _ClientService_open_future_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_open_future_presult__isset;

class ClientService_open_future_presult {
 public:


  virtual ~ClientService_open_future_presult() throw();
  Future* success;
  ClientException e;

  _ClientService_open_future_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_future_cancel_args__isset {
  _ClientService_future_cancel_args__isset() : ff(false) {}
  bool ff :1;
} _ClientService_future_cancel_args__isset;

class ClientService_future_cancel_args {
 public:

  ClientService_future_cancel_args(const ClientService_future_cancel_args&);
  ClientService_future_cancel_args& operator=(const ClientService_future_cancel_args&);
  ClientService_future_cancel_args() : ff(0) {
  }

  virtual ~ClientService_future_cancel_args() throw();
  Future ff;

  _ClientService_future_cancel_args__isset __isset;

  void __set_ff(const Future val);

  bool operator == (const ClientService_future_cancel_args & rhs) const
  {
    if (!(ff == rhs.ff))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_cancel_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_cancel_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_future_cancel_pargs {
 public:


  virtual ~ClientService_future_cancel_pargs() throw();
  const Future* ff;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_cancel_result__isset {
  _ClientService_future_cancel_result__isset() : e(false) {}
  bool e :1;
} _ClientService_future_cancel_result__isset;

class ClientService_future_cancel_result {
 public:

  ClientService_future_cancel_result(const ClientService_future_cancel_result&);
  ClientService_future_cancel_result& operator=(const ClientService_future_cancel_result&);
  ClientService_future_cancel_result() {
  }

  virtual ~ClientService_future_cancel_result() throw();
  ClientException e;

  _ClientService_future_cancel_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_future_cancel_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_cancel_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_cancel_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_cancel_presult__isset {
  _ClientService_future_cancel_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_future_cancel_presult__isset;

class ClientService_future_cancel_presult {
 public:


  virtual ~ClientService_future_cancel_presult() throw();
  ClientException e;

  _ClientService_future_cancel_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_cancel_future_args__isset {
  _ClientService_cancel_future_args__isset() : ff(false) {}
  bool ff :1;
} _ClientService_cancel_future_args__isset;

class ClientService_cancel_future_args {
 public:

  ClientService_cancel_future_args(const ClientService_cancel_future_args&);
  ClientService_cancel_future_args& operator=(const ClientService_cancel_future_args&);
  ClientService_cancel_future_args() : ff(0) {
  }

  virtual ~ClientService_cancel_future_args() throw();
  Future ff;

  _ClientService_cancel_future_args__isset __isset;

  void __set_ff(const Future val);

  bool operator == (const ClientService_cancel_future_args & rhs) const
  {
    if (!(ff == rhs.ff))
      return false;
    return true;
  }
  bool operator != (const ClientService_cancel_future_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_cancel_future_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_cancel_future_pargs {
 public:


  virtual ~ClientService_cancel_future_pargs() throw();
  const Future* ff;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_cancel_future_result__isset {
  _ClientService_cancel_future_result__isset() : e(false) {}
  bool e :1;
} _ClientService_cancel_future_result__isset;

class ClientService_cancel_future_result {
 public:

  ClientService_cancel_future_result(const ClientService_cancel_future_result&);
  ClientService_cancel_future_result& operator=(const ClientService_cancel_future_result&);
  ClientService_cancel_future_result() {
  }

  virtual ~ClientService_cancel_future_result() throw();
  ClientException e;

  _ClientService_cancel_future_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_cancel_future_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_cancel_future_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_cancel_future_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_cancel_future_presult__isset {
  _ClientService_cancel_future_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_cancel_future_presult__isset;

class ClientService_cancel_future_presult {
 public:


  virtual ~ClientService_cancel_future_presult() throw();
  ClientException e;

  _ClientService_cancel_future_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_future_get_result_args__isset {
  _ClientService_future_get_result_args__isset() : ff(false), timeout_millis(true) {}
  bool ff :1;
  bool timeout_millis :1;
} _ClientService_future_get_result_args__isset;

class ClientService_future_get_result_args {
 public:

  ClientService_future_get_result_args(const ClientService_future_get_result_args&);
  ClientService_future_get_result_args& operator=(const ClientService_future_get_result_args&);
  ClientService_future_get_result_args() : ff(0), timeout_millis(0) {
  }

  virtual ~ClientService_future_get_result_args() throw();
  Future ff;
  int32_t timeout_millis;

  _ClientService_future_get_result_args__isset __isset;

  void __set_ff(const Future val);

  void __set_timeout_millis(const int32_t val);

  bool operator == (const ClientService_future_get_result_args & rhs) const
  {
    if (!(ff == rhs.ff))
      return false;
    if (!(timeout_millis == rhs.timeout_millis))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_get_result_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_get_result_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_future_get_result_pargs {
 public:


  virtual ~ClientService_future_get_result_pargs() throw();
  const Future* ff;
  const int32_t* timeout_millis;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_get_result_result__isset {
  _ClientService_future_get_result_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_future_get_result_result__isset;

class ClientService_future_get_result_result {
 public:

  ClientService_future_get_result_result(const ClientService_future_get_result_result&);
  ClientService_future_get_result_result& operator=(const ClientService_future_get_result_result&);
  ClientService_future_get_result_result() {
  }

  virtual ~ClientService_future_get_result_result() throw();
  Result success;
  ClientException e;

  _ClientService_future_get_result_result__isset __isset;

  void __set_success(const Result& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_future_get_result_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_get_result_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_get_result_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_get_result_presult__isset {
  _ClientService_future_get_result_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_future_get_result_presult__isset;

class ClientService_future_get_result_presult {
 public:


  virtual ~ClientService_future_get_result_presult() throw();
  Result* success;
  ClientException e;

  _ClientService_future_get_result_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_get_future_result_args__isset {
  _ClientService_get_future_result_args__isset() : ff(false), timeout_millis(true) {}
  bool ff :1;
  bool timeout_millis :1;
} _ClientService_get_future_result_args__isset;

class ClientService_get_future_result_args {
 public:

  ClientService_get_future_result_args(const ClientService_get_future_result_args&);
  ClientService_get_future_result_args& operator=(const ClientService_get_future_result_args&);
  ClientService_get_future_result_args() : ff(0), timeout_millis(0) {
  }

  virtual ~ClientService_get_future_result_args() throw();
  Future ff;
  int32_t timeout_millis;

  _ClientService_get_future_result_args__isset __isset;

  void __set_ff(const Future val);

  void __set_timeout_millis(const int32_t val);

  bool operator == (const ClientService_get_future_result_args & rhs) const
  {
    if (!(ff == rhs.ff))
      return false;
    if (!(timeout_millis == rhs.timeout_millis))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_future_result_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_future_result_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_get_future_result_pargs {
 public:


  virtual ~ClientService_get_future_result_pargs() throw();
  const Future* ff;
  const int32_t* timeout_millis;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_future_result_result__isset {
  _ClientService_get_future_result_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_future_result_result__isset;

class ClientService_get_future_result_result {
 public:

  ClientService_get_future_result_result(const ClientService_get_future_result_result&);
  ClientService_get_future_result_result& operator=(const ClientService_get_future_result_result&);
  ClientService_get_future_result_result() {
  }

  virtual ~ClientService_get_future_result_result() throw();
  Result success;
  ClientException e;

  _ClientService_get_future_result_result__isset __isset;

  void __set_success(const Result& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_get_future_result_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_future_result_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_future_result_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_future_result_presult__isset {
  _ClientService_get_future_result_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_future_result_presult__isset;

class ClientService_get_future_result_presult {
 public:


  virtual ~ClientService_get_future_result_presult() throw();
  Result* success;
  ClientException e;

  _ClientService_get_future_result_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_future_get_result_as_arrays_args__isset {
  _ClientService_future_get_result_as_arrays_args__isset() : ff(false), timeout_millis(true) {}
  bool ff :1;
  bool timeout_millis :1;
} _ClientService_future_get_result_as_arrays_args__isset;

class ClientService_future_get_result_as_arrays_args {
 public:

  ClientService_future_get_result_as_arrays_args(const ClientService_future_get_result_as_arrays_args&);
  ClientService_future_get_result_as_arrays_args& operator=(const ClientService_future_get_result_as_arrays_args&);
  ClientService_future_get_result_as_arrays_args() : ff(0), timeout_millis(0) {
  }

  virtual ~ClientService_future_get_result_as_arrays_args() throw();
  Future ff;
  int32_t timeout_millis;

  _ClientService_future_get_result_as_arrays_args__isset __isset;

  void __set_ff(const Future val);

  void __set_timeout_millis(const int32_t val);

  bool operator == (const ClientService_future_get_result_as_arrays_args & rhs) const
  {
    if (!(ff == rhs.ff))
      return false;
    if (!(timeout_millis == rhs.timeout_millis))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_get_result_as_arrays_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_get_result_as_arrays_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_future_get_result_as_arrays_pargs {
 public:


  virtual ~ClientService_future_get_result_as_arrays_pargs() throw();
  const Future* ff;
  const int32_t* timeout_millis;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_get_result_as_arrays_result__isset {
  _ClientService_future_get_result_as_arrays_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_future_get_result_as_arrays_result__isset;

class ClientService_future_get_result_as_arrays_result {
 public:

  ClientService_future_get_result_as_arrays_result(const ClientService_future_get_result_as_arrays_result&);
  ClientService_future_get_result_as_arrays_result& operator=(const ClientService_future_get_result_as_arrays_result&);
  ClientService_future_get_result_as_arrays_result() {
  }

  virtual ~ClientService_future_get_result_as_arrays_result() throw();
  ResultAsArrays success;
  ClientException e;

  _ClientService_future_get_result_as_arrays_result__isset __isset;

  void __set_success(const ResultAsArrays& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_future_get_result_as_arrays_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_get_result_as_arrays_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_get_result_as_arrays_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_get_result_as_arrays_presult__isset {
  _ClientService_future_get_result_as_arrays_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_future_get_result_as_arrays_presult__isset;

class ClientService_future_get_result_as_arrays_presult {
 public:


  virtual ~ClientService_future_get_result_as_arrays_presult() throw();
  ResultAsArrays* success;
  ClientException e;

  _ClientService_future_get_result_as_arrays_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_get_future_result_as_arrays_args__isset {
  _ClientService_get_future_result_as_arrays_args__isset() : ff(false), timeout_millis(true) {}
  bool ff :1;
  bool timeout_millis :1;
} _ClientService_get_future_result_as_arrays_args__isset;

class ClientService_get_future_result_as_arrays_args {
 public:

  ClientService_get_future_result_as_arrays_args(const ClientService_get_future_result_as_arrays_args&);
  ClientService_get_future_result_as_arrays_args& operator=(const ClientService_get_future_result_as_arrays_args&);
  ClientService_get_future_result_as_arrays_args() : ff(0), timeout_millis(0) {
  }

  virtual ~ClientService_get_future_result_as_arrays_args() throw();
  Future ff;
  int32_t timeout_millis;

  _ClientService_get_future_result_as_arrays_args__isset __isset;

  void __set_ff(const Future val);

  void __set_timeout_millis(const int32_t val);

  bool operator == (const ClientService_get_future_result_as_arrays_args & rhs) const
  {
    if (!(ff == rhs.ff))
      return false;
    if (!(timeout_millis == rhs.timeout_millis))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_future_result_as_arrays_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_future_result_as_arrays_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_get_future_result_as_arrays_pargs {
 public:


  virtual ~ClientService_get_future_result_as_arrays_pargs() throw();
  const Future* ff;
  const int32_t* timeout_millis;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_future_result_as_arrays_result__isset {
  _ClientService_get_future_result_as_arrays_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_future_result_as_arrays_result__isset;

class ClientService_get_future_result_as_arrays_result {
 public:

  ClientService_get_future_result_as_arrays_result(const ClientService_get_future_result_as_arrays_result&);
  ClientService_get_future_result_as_arrays_result& operator=(const ClientService_get_future_result_as_arrays_result&);
  ClientService_get_future_result_as_arrays_result() {
  }

  virtual ~ClientService_get_future_result_as_arrays_result() throw();
  ResultAsArrays success;
  ClientException e;

  _ClientService_get_future_result_as_arrays_result__isset __isset;

  void __set_success(const ResultAsArrays& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_get_future_result_as_arrays_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_future_result_as_arrays_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_future_result_as_arrays_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_future_result_as_arrays_presult__isset {
  _ClientService_get_future_result_as_arrays_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_future_result_as_arrays_presult__isset;

class ClientService_get_future_result_as_arrays_presult {
 public:


  virtual ~ClientService_get_future_result_as_arrays_presult() throw();
  ResultAsArrays* success;
  ClientException e;

  _ClientService_get_future_result_as_arrays_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_future_get_result_serialized_args__isset {
  _ClientService_future_get_result_serialized_args__isset() : ff(false), timeout_millis(true) {}
  bool ff :1;
  bool timeout_millis :1;
} _ClientService_future_get_result_serialized_args__isset;

class ClientService_future_get_result_serialized_args {
 public:

  ClientService_future_get_result_serialized_args(const ClientService_future_get_result_serialized_args&);
  ClientService_future_get_result_serialized_args& operator=(const ClientService_future_get_result_serialized_args&);
  ClientService_future_get_result_serialized_args() : ff(0), timeout_millis(0) {
  }

  virtual ~ClientService_future_get_result_serialized_args() throw();
  Future ff;
  int32_t timeout_millis;

  _ClientService_future_get_result_serialized_args__isset __isset;

  void __set_ff(const Future val);

  void __set_timeout_millis(const int32_t val);

  bool operator == (const ClientService_future_get_result_serialized_args & rhs) const
  {
    if (!(ff == rhs.ff))
      return false;
    if (!(timeout_millis == rhs.timeout_millis))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_get_result_serialized_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_get_result_serialized_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_future_get_result_serialized_pargs {
 public:


  virtual ~ClientService_future_get_result_serialized_pargs() throw();
  const Future* ff;
  const int32_t* timeout_millis;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_get_result_serialized_result__isset {
  _ClientService_future_get_result_serialized_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_future_get_result_serialized_result__isset;

class ClientService_future_get_result_serialized_result {
 public:

  ClientService_future_get_result_serialized_result(const ClientService_future_get_result_serialized_result&);
  ClientService_future_get_result_serialized_result& operator=(const ClientService_future_get_result_serialized_result&);
  ClientService_future_get_result_serialized_result() {
  }

  virtual ~ClientService_future_get_result_serialized_result() throw();
  ResultSerialized success;
  ClientException e;

  _ClientService_future_get_result_serialized_result__isset __isset;

  void __set_success(const ResultSerialized& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_future_get_result_serialized_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_get_result_serialized_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_get_result_serialized_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_get_result_serialized_presult__isset {
  _ClientService_future_get_result_serialized_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_future_get_result_serialized_presult__isset;

class ClientService_future_get_result_serialized_presult {
 public:


  virtual ~ClientService_future_get_result_serialized_presult() throw();
  ResultSerialized* success;
  ClientException e;

  _ClientService_future_get_result_serialized_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_get_future_result_serialized_args__isset {
  _ClientService_get_future_result_serialized_args__isset() : ff(false), timeout_millis(true) {}
  bool ff :1;
  bool timeout_millis :1;
} _ClientService_get_future_result_serialized_args__isset;

class ClientService_get_future_result_serialized_args {
 public:

  ClientService_get_future_result_serialized_args(const ClientService_get_future_result_serialized_args&);
  ClientService_get_future_result_serialized_args& operator=(const ClientService_get_future_result_serialized_args&);
  ClientService_get_future_result_serialized_args() : ff(0), timeout_millis(0) {
  }

  virtual ~ClientService_get_future_result_serialized_args() throw();
  Future ff;
  int32_t timeout_millis;

  _ClientService_get_future_result_serialized_args__isset __isset;

  void __set_ff(const Future val);

  void __set_timeout_millis(const int32_t val);

  bool operator == (const ClientService_get_future_result_serialized_args & rhs) const
  {
    if (!(ff == rhs.ff))
      return false;
    if (!(timeout_millis == rhs.timeout_millis))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_future_result_serialized_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_future_result_serialized_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_get_future_result_serialized_pargs {
 public:


  virtual ~ClientService_get_future_result_serialized_pargs() throw();
  const Future* ff;
  const int32_t* timeout_millis;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_future_result_serialized_result__isset {
  _ClientService_get_future_result_serialized_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_future_result_serialized_result__isset;

class ClientService_get_future_result_serialized_result {
 public:

  ClientService_get_future_result_serialized_result(const ClientService_get_future_result_serialized_result&);
  ClientService_get_future_result_serialized_result& operator=(const ClientService_get_future_result_serialized_result&);
  ClientService_get_future_result_serialized_result() {
  }

  virtual ~ClientService_get_future_result_serialized_result() throw();
  ResultSerialized success;
  ClientException e;

  _ClientService_get_future_result_serialized_result__isset __isset;

  void __set_success(const ResultSerialized& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_get_future_result_serialized_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_future_result_serialized_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_future_result_serialized_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_future_result_serialized_presult__isset {
  _ClientService_get_future_result_serialized_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_future_result_serialized_presult__isset;

class ClientService_get_future_result_serialized_presult {
 public:


  virtual ~ClientService_get_future_result_serialized_presult() throw();
  ResultSerialized* success;
  ClientException e;

  _ClientService_get_future_result_serialized_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_future_is_empty_args__isset {
  _ClientService_future_is_empty_args__isset() : ff(false) {}
  bool ff :1;
} _ClientService_future_is_empty_args__isset;

class ClientService_future_is_empty_args {
 public:

  ClientService_future_is_empty_args(const ClientService_future_is_empty_args&);
  ClientService_future_is_empty_args& operator=(const ClientService_future_is_empty_args&);
  ClientService_future_is_empty_args() : ff(0) {
  }

  virtual ~ClientService_future_is_empty_args() throw();
  Future ff;

  _ClientService_future_is_empty_args__isset __isset;

  void __set_ff(const Future val);

  bool operator == (const ClientService_future_is_empty_args & rhs) const
  {
    if (!(ff == rhs.ff))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_is_empty_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_is_empty_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_future_is_empty_pargs {
 public:


  virtual ~ClientService_future_is_empty_pargs() throw();
  const Future* ff;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_is_empty_result__isset {
  _ClientService_future_is_empty_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_future_is_empty_result__isset;

class ClientService_future_is_empty_result {
 public:

  ClientService_future_is_empty_result(const ClientService_future_is_empty_result&);
  ClientService_future_is_empty_result& operator=(const ClientService_future_is_empty_result&);
  ClientService_future_is_empty_result() : success(0) {
  }

  virtual ~ClientService_future_is_empty_result() throw();
  bool success;
  ClientException e;

  _ClientService_future_is_empty_result__isset __isset;

  void __set_success(const bool val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_future_is_empty_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_is_empty_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_is_empty_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_is_empty_presult__isset {
  _ClientService_future_is_empty_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_future_is_empty_presult__isset;

class ClientService_future_is_empty_presult {
 public:


  virtual ~ClientService_future_is_empty_presult() throw();
  bool* success;
  ClientException e;

  _ClientService_future_is_empty_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_future_is_full_args__isset {
  _ClientService_future_is_full_args__isset() : ff(false) {}
  bool ff :1;
} _ClientService_future_is_full_args__isset;

class ClientService_future_is_full_args {
 public:

  ClientService_future_is_full_args(const ClientService_future_is_full_args&);
  ClientService_future_is_full_args& operator=(const ClientService_future_is_full_args&);
  ClientService_future_is_full_args() : ff(0) {
  }

  virtual ~ClientService_future_is_full_args() throw();
  Future ff;

  _ClientService_future_is_full_args__isset __isset;

  void __set_ff(const Future val);

  bool operator == (const ClientService_future_is_full_args & rhs) const
  {
    if (!(ff == rhs.ff))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_is_full_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_is_full_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_future_is_full_pargs {
 public:


  virtual ~ClientService_future_is_full_pargs() throw();
  const Future* ff;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_is_full_result__isset {
  _ClientService_future_is_full_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_future_is_full_result__isset;

class ClientService_future_is_full_result {
 public:

  ClientService_future_is_full_result(const ClientService_future_is_full_result&);
  ClientService_future_is_full_result& operator=(const ClientService_future_is_full_result&);
  ClientService_future_is_full_result() : success(0) {
  }

  virtual ~ClientService_future_is_full_result() throw();
  bool success;
  ClientException e;

  _ClientService_future_is_full_result__isset __isset;

  void __set_success(const bool val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_future_is_full_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_is_full_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_is_full_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_is_full_presult__isset {
  _ClientService_future_is_full_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_future_is_full_presult__isset;

class ClientService_future_is_full_presult {
 public:


  virtual ~ClientService_future_is_full_presult() throw();
  bool* success;
  ClientException e;

  _ClientService_future_is_full_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_future_is_cancelled_args__isset {
  _ClientService_future_is_cancelled_args__isset() : ff(false) {}
  bool ff :1;
} _ClientService_future_is_cancelled_args__isset;

class ClientService_future_is_cancelled_args {
 public:

  ClientService_future_is_cancelled_args(const ClientService_future_is_cancelled_args&);
  ClientService_future_is_cancelled_args& operator=(const ClientService_future_is_cancelled_args&);
  ClientService_future_is_cancelled_args() : ff(0) {
  }

  virtual ~ClientService_future_is_cancelled_args() throw();
  Future ff;

  _ClientService_future_is_cancelled_args__isset __isset;

  void __set_ff(const Future val);

  bool operator == (const ClientService_future_is_cancelled_args & rhs) const
  {
    if (!(ff == rhs.ff))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_is_cancelled_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_is_cancelled_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_future_is_cancelled_pargs {
 public:


  virtual ~ClientService_future_is_cancelled_pargs() throw();
  const Future* ff;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_is_cancelled_result__isset {
  _ClientService_future_is_cancelled_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_future_is_cancelled_result__isset;

class ClientService_future_is_cancelled_result {
 public:

  ClientService_future_is_cancelled_result(const ClientService_future_is_cancelled_result&);
  ClientService_future_is_cancelled_result& operator=(const ClientService_future_is_cancelled_result&);
  ClientService_future_is_cancelled_result() : success(0) {
  }

  virtual ~ClientService_future_is_cancelled_result() throw();
  bool success;
  ClientException e;

  _ClientService_future_is_cancelled_result__isset __isset;

  void __set_success(const bool val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_future_is_cancelled_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_is_cancelled_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_is_cancelled_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_is_cancelled_presult__isset {
  _ClientService_future_is_cancelled_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_future_is_cancelled_presult__isset;

class ClientService_future_is_cancelled_presult {
 public:


  virtual ~ClientService_future_is_cancelled_presult() throw();
  bool* success;
  ClientException e;

  _ClientService_future_is_cancelled_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_future_has_outstanding_args__isset {
  _ClientService_future_has_outstanding_args__isset() : ff(false) {}
  bool ff :1;
} _ClientService_future_has_outstanding_args__isset;

class ClientService_future_has_outstanding_args {
 public:

  ClientService_future_has_outstanding_args(const ClientService_future_has_outstanding_args&);
  ClientService_future_has_outstanding_args& operator=(const ClientService_future_has_outstanding_args&);
  ClientService_future_has_outstanding_args() : ff(0) {
  }

  virtual ~ClientService_future_has_outstanding_args() throw();
  Future ff;

  _ClientService_future_has_outstanding_args__isset __isset;

  void __set_ff(const Future val);

  bool operator == (const ClientService_future_has_outstanding_args & rhs) const
  {
    if (!(ff == rhs.ff))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_has_outstanding_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_has_outstanding_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_future_has_outstanding_pargs {
 public:


  virtual ~ClientService_future_has_outstanding_pargs() throw();
  const Future* ff;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_has_outstanding_result__isset {
  _ClientService_future_has_outstanding_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_future_has_outstanding_result__isset;

class ClientService_future_has_outstanding_result {
 public:

  ClientService_future_has_outstanding_result(const ClientService_future_has_outstanding_result&);
  ClientService_future_has_outstanding_result& operator=(const ClientService_future_has_outstanding_result&);
  ClientService_future_has_outstanding_result() : success(0) {
  }

  virtual ~ClientService_future_has_outstanding_result() throw();
  bool success;
  ClientException e;

  _ClientService_future_has_outstanding_result__isset __isset;

  void __set_success(const bool val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_future_has_outstanding_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_has_outstanding_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_has_outstanding_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_has_outstanding_presult__isset {
  _ClientService_future_has_outstanding_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_future_has_outstanding_presult__isset;

class ClientService_future_has_outstanding_presult {
 public:


  virtual ~ClientService_future_has_outstanding_presult() throw();
  bool* success;
  ClientException e;

  _ClientService_future_has_outstanding_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_future_close_args__isset {
  _ClientService_future_close_args__isset() : ff(false) {}
  bool ff :1;
} _ClientService_future_close_args__isset;

class ClientService_future_close_args {
 public:

  ClientService_future_close_args(const ClientService_future_close_args&);
  ClientService_future_close_args& operator=(const ClientService_future_close_args&);
  ClientService_future_close_args() : ff(0) {
  }

  virtual ~ClientService_future_close_args() throw();
  Future ff;

  _ClientService_future_close_args__isset __isset;

  void __set_ff(const Future val);

  bool operator == (const ClientService_future_close_args & rhs) const
  {
    if (!(ff == rhs.ff))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_close_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_close_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_future_close_pargs {
 public:


  virtual ~ClientService_future_close_pargs() throw();
  const Future* ff;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_close_result__isset {
  _ClientService_future_close_result__isset() : e(false) {}
  bool e :1;
} _ClientService_future_close_result__isset;

class ClientService_future_close_result {
 public:

  ClientService_future_close_result(const ClientService_future_close_result&);
  ClientService_future_close_result& operator=(const ClientService_future_close_result&);
  ClientService_future_close_result() {
  }

  virtual ~ClientService_future_close_result() throw();
  ClientException e;

  _ClientService_future_close_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_future_close_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_future_close_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_future_close_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_future_close_presult__isset {
  _ClientService_future_close_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_future_close_presult__isset;

class ClientService_future_close_presult {
 public:


  virtual ~ClientService_future_close_presult() throw();
  ClientException e;

  _ClientService_future_close_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_close_future_args__isset {
  _ClientService_close_future_args__isset() : ff(false) {}
  bool ff :1;
} _ClientService_close_future_args__isset;

class ClientService_close_future_args {
 public:

  ClientService_close_future_args(const ClientService_close_future_args&);
  ClientService_close_future_args& operator=(const ClientService_close_future_args&);
  ClientService_close_future_args() : ff(0) {
  }

  virtual ~ClientService_close_future_args() throw();
  Future ff;

  _ClientService_close_future_args__isset __isset;

  void __set_ff(const Future val);

  bool operator == (const ClientService_close_future_args & rhs) const
  {
    if (!(ff == rhs.ff))
      return false;
    return true;
  }
  bool operator != (const ClientService_close_future_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_close_future_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_close_future_pargs {
 public:


  virtual ~ClientService_close_future_pargs() throw();
  const Future* ff;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_close_future_result__isset {
  _ClientService_close_future_result__isset() : e(false) {}
  bool e :1;
} _ClientService_close_future_result__isset;

class ClientService_close_future_result {
 public:

  ClientService_close_future_result(const ClientService_close_future_result&);
  ClientService_close_future_result& operator=(const ClientService_close_future_result&);
  ClientService_close_future_result() {
  }

  virtual ~ClientService_close_future_result() throw();
  ClientException e;

  _ClientService_close_future_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_close_future_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_close_future_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_close_future_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_close_future_presult__isset {
  _ClientService_close_future_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_close_future_presult__isset;

class ClientService_close_future_presult {
 public:


  virtual ~ClientService_close_future_presult() throw();
  ClientException e;

  _ClientService_close_future_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_scanner_open_args__isset {
  _ClientService_scanner_open_args__isset() : ns(false), table_name(false), scan_spec(false) {}
  bool ns :1;
  bool table_name :1;
  bool scan_spec :1;
} _ClientService_scanner_open_args__isset;

class ClientService_scanner_open_args {
 public:

  ClientService_scanner_open_args(const ClientService_scanner_open_args&);
  ClientService_scanner_open_args& operator=(const ClientService_scanner_open_args&);
  ClientService_scanner_open_args() : ns(0), table_name() {
  }

  virtual ~ClientService_scanner_open_args() throw();
  Namespace ns;
  std::string table_name;
  ScanSpec scan_spec;

  _ClientService_scanner_open_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_scan_spec(const ScanSpec& val);

  bool operator == (const ClientService_scanner_open_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(scan_spec == rhs.scan_spec))
      return false;
    return true;
  }
  bool operator != (const ClientService_scanner_open_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_scanner_open_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_scanner_open_pargs {
 public:


  virtual ~ClientService_scanner_open_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const ScanSpec* scan_spec;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_scanner_open_result__isset {
  _ClientService_scanner_open_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_scanner_open_result__isset;

class ClientService_scanner_open_result {
 public:

  ClientService_scanner_open_result(const ClientService_scanner_open_result&);
  ClientService_scanner_open_result& operator=(const ClientService_scanner_open_result&);
  ClientService_scanner_open_result() : success(0) {
  }

  virtual ~ClientService_scanner_open_result() throw();
  Scanner success;
  ClientException e;

  _ClientService_scanner_open_result__isset __isset;

  void __set_success(const Scanner val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_scanner_open_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_scanner_open_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_scanner_open_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_scanner_open_presult__isset {
  _ClientService_scanner_open_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_scanner_open_presult__isset;

class ClientService_scanner_open_presult {
 public:


  virtual ~ClientService_scanner_open_presult() throw();
  Scanner* success;
  ClientException e;

  _ClientService_scanner_open_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_open_scanner_args__isset {
  _ClientService_open_scanner_args__isset() : ns(false), table_name(false), scan_spec(false) {}
  bool ns :1;
  bool table_name :1;
  bool scan_spec :1;
} _ClientService_open_scanner_args__isset;

class ClientService_open_scanner_args {
 public:

  ClientService_open_scanner_args(const ClientService_open_scanner_args&);
  ClientService_open_scanner_args& operator=(const ClientService_open_scanner_args&);
  ClientService_open_scanner_args() : ns(0), table_name() {
  }

  virtual ~ClientService_open_scanner_args() throw();
  Namespace ns;
  std::string table_name;
  ScanSpec scan_spec;

  _ClientService_open_scanner_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_scan_spec(const ScanSpec& val);

  bool operator == (const ClientService_open_scanner_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(scan_spec == rhs.scan_spec))
      return false;
    return true;
  }
  bool operator != (const ClientService_open_scanner_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_open_scanner_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_open_scanner_pargs {
 public:


  virtual ~ClientService_open_scanner_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const ScanSpec* scan_spec;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_open_scanner_result__isset {
  _ClientService_open_scanner_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_open_scanner_result__isset;

class ClientService_open_scanner_result {
 public:

  ClientService_open_scanner_result(const ClientService_open_scanner_result&);
  ClientService_open_scanner_result& operator=(const ClientService_open_scanner_result&);
  ClientService_open_scanner_result() : success(0) {
  }

  virtual ~ClientService_open_scanner_result() throw();
  Scanner success;
  ClientException e;

  _ClientService_open_scanner_result__isset __isset;

  void __set_success(const Scanner val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_open_scanner_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_open_scanner_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_open_scanner_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_open_scanner_presult__isset {
  _ClientService_open_scanner_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_open_scanner_presult__isset;

class ClientService_open_scanner_presult {
 public:


  virtual ~ClientService_open_scanner_presult() throw();
  Scanner* success;
  ClientException e;

  _ClientService_open_scanner_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_async_scanner_open_args__isset {
  _ClientService_async_scanner_open_args__isset() : ns(false), table_name(false), future(false), scan_spec(false) {}
  bool ns :1;
  bool table_name :1;
  bool future :1;
  bool scan_spec :1;
} _ClientService_async_scanner_open_args__isset;

class ClientService_async_scanner_open_args {
 public:

  ClientService_async_scanner_open_args(const ClientService_async_scanner_open_args&);
  ClientService_async_scanner_open_args& operator=(const ClientService_async_scanner_open_args&);
  ClientService_async_scanner_open_args() : ns(0), table_name(), future(0) {
  }

  virtual ~ClientService_async_scanner_open_args() throw();
  Namespace ns;
  std::string table_name;
  Future future;
  ScanSpec scan_spec;

  _ClientService_async_scanner_open_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_future(const Future val);

  void __set_scan_spec(const ScanSpec& val);

  bool operator == (const ClientService_async_scanner_open_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(future == rhs.future))
      return false;
    if (!(scan_spec == rhs.scan_spec))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_scanner_open_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_scanner_open_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_async_scanner_open_pargs {
 public:


  virtual ~ClientService_async_scanner_open_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const Future* future;
  const ScanSpec* scan_spec;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_scanner_open_result__isset {
  _ClientService_async_scanner_open_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_async_scanner_open_result__isset;

class ClientService_async_scanner_open_result {
 public:

  ClientService_async_scanner_open_result(const ClientService_async_scanner_open_result&);
  ClientService_async_scanner_open_result& operator=(const ClientService_async_scanner_open_result&);
  ClientService_async_scanner_open_result() : success(0) {
  }

  virtual ~ClientService_async_scanner_open_result() throw();
  ScannerAsync success;
  ClientException e;

  _ClientService_async_scanner_open_result__isset __isset;

  void __set_success(const ScannerAsync val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_async_scanner_open_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_scanner_open_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_scanner_open_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_scanner_open_presult__isset {
  _ClientService_async_scanner_open_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_async_scanner_open_presult__isset;

class ClientService_async_scanner_open_presult {
 public:


  virtual ~ClientService_async_scanner_open_presult() throw();
  ScannerAsync* success;
  ClientException e;

  _ClientService_async_scanner_open_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_open_scanner_async_args__isset {
  _ClientService_open_scanner_async_args__isset() : ns(false), table_name(false), future(false), scan_spec(false) {}
  bool ns :1;
  bool table_name :1;
  bool future :1;
  bool scan_spec :1;
} _ClientService_open_scanner_async_args__isset;

class ClientService_open_scanner_async_args {
 public:

  ClientService_open_scanner_async_args(const ClientService_open_scanner_async_args&);
  ClientService_open_scanner_async_args& operator=(const ClientService_open_scanner_async_args&);
  ClientService_open_scanner_async_args() : ns(0), table_name(), future(0) {
  }

  virtual ~ClientService_open_scanner_async_args() throw();
  Namespace ns;
  std::string table_name;
  Future future;
  ScanSpec scan_spec;

  _ClientService_open_scanner_async_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_future(const Future val);

  void __set_scan_spec(const ScanSpec& val);

  bool operator == (const ClientService_open_scanner_async_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(future == rhs.future))
      return false;
    if (!(scan_spec == rhs.scan_spec))
      return false;
    return true;
  }
  bool operator != (const ClientService_open_scanner_async_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_open_scanner_async_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_open_scanner_async_pargs {
 public:


  virtual ~ClientService_open_scanner_async_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const Future* future;
  const ScanSpec* scan_spec;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_open_scanner_async_result__isset {
  _ClientService_open_scanner_async_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_open_scanner_async_result__isset;

class ClientService_open_scanner_async_result {
 public:

  ClientService_open_scanner_async_result(const ClientService_open_scanner_async_result&);
  ClientService_open_scanner_async_result& operator=(const ClientService_open_scanner_async_result&);
  ClientService_open_scanner_async_result() : success(0) {
  }

  virtual ~ClientService_open_scanner_async_result() throw();
  ScannerAsync success;
  ClientException e;

  _ClientService_open_scanner_async_result__isset __isset;

  void __set_success(const ScannerAsync val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_open_scanner_async_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_open_scanner_async_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_open_scanner_async_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_open_scanner_async_presult__isset {
  _ClientService_open_scanner_async_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_open_scanner_async_presult__isset;

class ClientService_open_scanner_async_presult {
 public:


  virtual ~ClientService_open_scanner_async_presult() throw();
  ScannerAsync* success;
  ClientException e;

  _ClientService_open_scanner_async_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_scanner_close_args__isset {
  _ClientService_scanner_close_args__isset() : scanner(false) {}
  bool scanner :1;
} _ClientService_scanner_close_args__isset;

class ClientService_scanner_close_args {
 public:

  ClientService_scanner_close_args(const ClientService_scanner_close_args&);
  ClientService_scanner_close_args& operator=(const ClientService_scanner_close_args&);
  ClientService_scanner_close_args() : scanner(0) {
  }

  virtual ~ClientService_scanner_close_args() throw();
  Scanner scanner;

  _ClientService_scanner_close_args__isset __isset;

  void __set_scanner(const Scanner val);

  bool operator == (const ClientService_scanner_close_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const ClientService_scanner_close_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_scanner_close_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_scanner_close_pargs {
 public:


  virtual ~ClientService_scanner_close_pargs() throw();
  const Scanner* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_scanner_close_result__isset {
  _ClientService_scanner_close_result__isset() : e(false) {}
  bool e :1;
} _ClientService_scanner_close_result__isset;

class ClientService_scanner_close_result {
 public:

  ClientService_scanner_close_result(const ClientService_scanner_close_result&);
  ClientService_scanner_close_result& operator=(const ClientService_scanner_close_result&);
  ClientService_scanner_close_result() {
  }

  virtual ~ClientService_scanner_close_result() throw();
  ClientException e;

  _ClientService_scanner_close_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_scanner_close_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_scanner_close_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_scanner_close_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_scanner_close_presult__isset {
  _ClientService_scanner_close_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_scanner_close_presult__isset;

class ClientService_scanner_close_presult {
 public:


  virtual ~ClientService_scanner_close_presult() throw();
  ClientException e;

  _ClientService_scanner_close_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_close_scanner_args__isset {
  _ClientService_close_scanner_args__isset() : scanner(false) {}
  bool scanner :1;
} _ClientService_close_scanner_args__isset;

class ClientService_close_scanner_args {
 public:

  ClientService_close_scanner_args(const ClientService_close_scanner_args&);
  ClientService_close_scanner_args& operator=(const ClientService_close_scanner_args&);
  ClientService_close_scanner_args() : scanner(0) {
  }

  virtual ~ClientService_close_scanner_args() throw();
  Scanner scanner;

  _ClientService_close_scanner_args__isset __isset;

  void __set_scanner(const Scanner val);

  bool operator == (const ClientService_close_scanner_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const ClientService_close_scanner_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_close_scanner_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_close_scanner_pargs {
 public:


  virtual ~ClientService_close_scanner_pargs() throw();
  const Scanner* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_close_scanner_result__isset {
  _ClientService_close_scanner_result__isset() : e(false) {}
  bool e :1;
} _ClientService_close_scanner_result__isset;

class ClientService_close_scanner_result {
 public:

  ClientService_close_scanner_result(const ClientService_close_scanner_result&);
  ClientService_close_scanner_result& operator=(const ClientService_close_scanner_result&);
  ClientService_close_scanner_result() {
  }

  virtual ~ClientService_close_scanner_result() throw();
  ClientException e;

  _ClientService_close_scanner_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_close_scanner_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_close_scanner_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_close_scanner_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_close_scanner_presult__isset {
  _ClientService_close_scanner_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_close_scanner_presult__isset;

class ClientService_close_scanner_presult {
 public:


  virtual ~ClientService_close_scanner_presult() throw();
  ClientException e;

  _ClientService_close_scanner_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_async_scanner_cancel_args__isset {
  _ClientService_async_scanner_cancel_args__isset() : scanner(false) {}
  bool scanner :1;
} _ClientService_async_scanner_cancel_args__isset;

class ClientService_async_scanner_cancel_args {
 public:

  ClientService_async_scanner_cancel_args(const ClientService_async_scanner_cancel_args&);
  ClientService_async_scanner_cancel_args& operator=(const ClientService_async_scanner_cancel_args&);
  ClientService_async_scanner_cancel_args() : scanner(0) {
  }

  virtual ~ClientService_async_scanner_cancel_args() throw();
  ScannerAsync scanner;

  _ClientService_async_scanner_cancel_args__isset __isset;

  void __set_scanner(const ScannerAsync val);

  bool operator == (const ClientService_async_scanner_cancel_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_scanner_cancel_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_scanner_cancel_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_async_scanner_cancel_pargs {
 public:


  virtual ~ClientService_async_scanner_cancel_pargs() throw();
  const ScannerAsync* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_scanner_cancel_result__isset {
  _ClientService_async_scanner_cancel_result__isset() : e(false) {}
  bool e :1;
} _ClientService_async_scanner_cancel_result__isset;

class ClientService_async_scanner_cancel_result {
 public:

  ClientService_async_scanner_cancel_result(const ClientService_async_scanner_cancel_result&);
  ClientService_async_scanner_cancel_result& operator=(const ClientService_async_scanner_cancel_result&);
  ClientService_async_scanner_cancel_result() {
  }

  virtual ~ClientService_async_scanner_cancel_result() throw();
  ClientException e;

  _ClientService_async_scanner_cancel_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_async_scanner_cancel_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_scanner_cancel_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_scanner_cancel_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_scanner_cancel_presult__isset {
  _ClientService_async_scanner_cancel_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_async_scanner_cancel_presult__isset;

class ClientService_async_scanner_cancel_presult {
 public:


  virtual ~ClientService_async_scanner_cancel_presult() throw();
  ClientException e;

  _ClientService_async_scanner_cancel_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_cancel_scanner_async_args__isset {
  _ClientService_cancel_scanner_async_args__isset() : scanner(false) {}
  bool scanner :1;
} _ClientService_cancel_scanner_async_args__isset;

class ClientService_cancel_scanner_async_args {
 public:

  ClientService_cancel_scanner_async_args(const ClientService_cancel_scanner_async_args&);
  ClientService_cancel_scanner_async_args& operator=(const ClientService_cancel_scanner_async_args&);
  ClientService_cancel_scanner_async_args() : scanner(0) {
  }

  virtual ~ClientService_cancel_scanner_async_args() throw();
  ScannerAsync scanner;

  _ClientService_cancel_scanner_async_args__isset __isset;

  void __set_scanner(const ScannerAsync val);

  bool operator == (const ClientService_cancel_scanner_async_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const ClientService_cancel_scanner_async_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_cancel_scanner_async_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_cancel_scanner_async_pargs {
 public:


  virtual ~ClientService_cancel_scanner_async_pargs() throw();
  const ScannerAsync* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_cancel_scanner_async_result__isset {
  _ClientService_cancel_scanner_async_result__isset() : e(false) {}
  bool e :1;
} _ClientService_cancel_scanner_async_result__isset;

class ClientService_cancel_scanner_async_result {
 public:

  ClientService_cancel_scanner_async_result(const ClientService_cancel_scanner_async_result&);
  ClientService_cancel_scanner_async_result& operator=(const ClientService_cancel_scanner_async_result&);
  ClientService_cancel_scanner_async_result() {
  }

  virtual ~ClientService_cancel_scanner_async_result() throw();
  ClientException e;

  _ClientService_cancel_scanner_async_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_cancel_scanner_async_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_cancel_scanner_async_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_cancel_scanner_async_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_cancel_scanner_async_presult__isset {
  _ClientService_cancel_scanner_async_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_cancel_scanner_async_presult__isset;

class ClientService_cancel_scanner_async_presult {
 public:


  virtual ~ClientService_cancel_scanner_async_presult() throw();
  ClientException e;

  _ClientService_cancel_scanner_async_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_async_scanner_close_args__isset {
  _ClientService_async_scanner_close_args__isset() : scanner(false) {}
  bool scanner :1;
} _ClientService_async_scanner_close_args__isset;

class ClientService_async_scanner_close_args {
 public:

  ClientService_async_scanner_close_args(const ClientService_async_scanner_close_args&);
  ClientService_async_scanner_close_args& operator=(const ClientService_async_scanner_close_args&);
  ClientService_async_scanner_close_args() : scanner(0) {
  }

  virtual ~ClientService_async_scanner_close_args() throw();
  ScannerAsync scanner;

  _ClientService_async_scanner_close_args__isset __isset;

  void __set_scanner(const ScannerAsync val);

  bool operator == (const ClientService_async_scanner_close_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_scanner_close_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_scanner_close_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_async_scanner_close_pargs {
 public:


  virtual ~ClientService_async_scanner_close_pargs() throw();
  const ScannerAsync* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_scanner_close_result__isset {
  _ClientService_async_scanner_close_result__isset() : e(false) {}
  bool e :1;
} _ClientService_async_scanner_close_result__isset;

class ClientService_async_scanner_close_result {
 public:

  ClientService_async_scanner_close_result(const ClientService_async_scanner_close_result&);
  ClientService_async_scanner_close_result& operator=(const ClientService_async_scanner_close_result&);
  ClientService_async_scanner_close_result() {
  }

  virtual ~ClientService_async_scanner_close_result() throw();
  ClientException e;

  _ClientService_async_scanner_close_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_async_scanner_close_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_scanner_close_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_scanner_close_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_scanner_close_presult__isset {
  _ClientService_async_scanner_close_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_async_scanner_close_presult__isset;

class ClientService_async_scanner_close_presult {
 public:


  virtual ~ClientService_async_scanner_close_presult() throw();
  ClientException e;

  _ClientService_async_scanner_close_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_close_scanner_async_args__isset {
  _ClientService_close_scanner_async_args__isset() : scanner(false) {}
  bool scanner :1;
} _ClientService_close_scanner_async_args__isset;

class ClientService_close_scanner_async_args {
 public:

  ClientService_close_scanner_async_args(const ClientService_close_scanner_async_args&);
  ClientService_close_scanner_async_args& operator=(const ClientService_close_scanner_async_args&);
  ClientService_close_scanner_async_args() : scanner(0) {
  }

  virtual ~ClientService_close_scanner_async_args() throw();
  ScannerAsync scanner;

  _ClientService_close_scanner_async_args__isset __isset;

  void __set_scanner(const ScannerAsync val);

  bool operator == (const ClientService_close_scanner_async_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const ClientService_close_scanner_async_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_close_scanner_async_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_close_scanner_async_pargs {
 public:


  virtual ~ClientService_close_scanner_async_pargs() throw();
  const ScannerAsync* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_close_scanner_async_result__isset {
  _ClientService_close_scanner_async_result__isset() : e(false) {}
  bool e :1;
} _ClientService_close_scanner_async_result__isset;

class ClientService_close_scanner_async_result {
 public:

  ClientService_close_scanner_async_result(const ClientService_close_scanner_async_result&);
  ClientService_close_scanner_async_result& operator=(const ClientService_close_scanner_async_result&);
  ClientService_close_scanner_async_result() {
  }

  virtual ~ClientService_close_scanner_async_result() throw();
  ClientException e;

  _ClientService_close_scanner_async_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_close_scanner_async_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_close_scanner_async_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_close_scanner_async_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_close_scanner_async_presult__isset {
  _ClientService_close_scanner_async_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_close_scanner_async_presult__isset;

class ClientService_close_scanner_async_presult {
 public:


  virtual ~ClientService_close_scanner_async_presult() throw();
  ClientException e;

  _ClientService_close_scanner_async_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_scanner_get_cells_args__isset {
  _ClientService_scanner_get_cells_args__isset() : scanner(false) {}
  bool scanner :1;
} _ClientService_scanner_get_cells_args__isset;

class ClientService_scanner_get_cells_args {
 public:

  ClientService_scanner_get_cells_args(const ClientService_scanner_get_cells_args&);
  ClientService_scanner_get_cells_args& operator=(const ClientService_scanner_get_cells_args&);
  ClientService_scanner_get_cells_args() : scanner(0) {
  }

  virtual ~ClientService_scanner_get_cells_args() throw();
  Scanner scanner;

  _ClientService_scanner_get_cells_args__isset __isset;

  void __set_scanner(const Scanner val);

  bool operator == (const ClientService_scanner_get_cells_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const ClientService_scanner_get_cells_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_scanner_get_cells_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_scanner_get_cells_pargs {
 public:


  virtual ~ClientService_scanner_get_cells_pargs() throw();
  const Scanner* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_scanner_get_cells_result__isset {
  _ClientService_scanner_get_cells_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_scanner_get_cells_result__isset;

class ClientService_scanner_get_cells_result {
 public:

  ClientService_scanner_get_cells_result(const ClientService_scanner_get_cells_result&);
  ClientService_scanner_get_cells_result& operator=(const ClientService_scanner_get_cells_result&);
  ClientService_scanner_get_cells_result() {
  }

  virtual ~ClientService_scanner_get_cells_result() throw();
  std::vector<Cell>  success;
  ClientException e;

  _ClientService_scanner_get_cells_result__isset __isset;

  void __set_success(const std::vector<Cell> & val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_scanner_get_cells_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_scanner_get_cells_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_scanner_get_cells_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_scanner_get_cells_presult__isset {
  _ClientService_scanner_get_cells_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_scanner_get_cells_presult__isset;

class ClientService_scanner_get_cells_presult {
 public:


  virtual ~ClientService_scanner_get_cells_presult() throw();
  std::vector<Cell> * success;
  ClientException e;

  _ClientService_scanner_get_cells_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_next_cells_args__isset {
  _ClientService_next_cells_args__isset() : scanner(false) {}
  bool scanner :1;
} _ClientService_next_cells_args__isset;

class ClientService_next_cells_args {
 public:

  ClientService_next_cells_args(const ClientService_next_cells_args&);
  ClientService_next_cells_args& operator=(const ClientService_next_cells_args&);
  ClientService_next_cells_args() : scanner(0) {
  }

  virtual ~ClientService_next_cells_args() throw();
  Scanner scanner;

  _ClientService_next_cells_args__isset __isset;

  void __set_scanner(const Scanner val);

  bool operator == (const ClientService_next_cells_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const ClientService_next_cells_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_next_cells_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_next_cells_pargs {
 public:


  virtual ~ClientService_next_cells_pargs() throw();
  const Scanner* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_next_cells_result__isset {
  _ClientService_next_cells_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_next_cells_result__isset;

class ClientService_next_cells_result {
 public:

  ClientService_next_cells_result(const ClientService_next_cells_result&);
  ClientService_next_cells_result& operator=(const ClientService_next_cells_result&);
  ClientService_next_cells_result() {
  }

  virtual ~ClientService_next_cells_result() throw();
  std::vector<Cell>  success;
  ClientException e;

  _ClientService_next_cells_result__isset __isset;

  void __set_success(const std::vector<Cell> & val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_next_cells_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_next_cells_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_next_cells_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_next_cells_presult__isset {
  _ClientService_next_cells_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_next_cells_presult__isset;

class ClientService_next_cells_presult {
 public:


  virtual ~ClientService_next_cells_presult() throw();
  std::vector<Cell> * success;
  ClientException e;

  _ClientService_next_cells_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_scanner_get_cells_as_arrays_args__isset {
  _ClientService_scanner_get_cells_as_arrays_args__isset() : scanner(false) {}
  bool scanner :1;
} _ClientService_scanner_get_cells_as_arrays_args__isset;

class ClientService_scanner_get_cells_as_arrays_args {
 public:

  ClientService_scanner_get_cells_as_arrays_args(const ClientService_scanner_get_cells_as_arrays_args&);
  ClientService_scanner_get_cells_as_arrays_args& operator=(const ClientService_scanner_get_cells_as_arrays_args&);
  ClientService_scanner_get_cells_as_arrays_args() : scanner(0) {
  }

  virtual ~ClientService_scanner_get_cells_as_arrays_args() throw();
  Scanner scanner;

  _ClientService_scanner_get_cells_as_arrays_args__isset __isset;

  void __set_scanner(const Scanner val);

  bool operator == (const ClientService_scanner_get_cells_as_arrays_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const ClientService_scanner_get_cells_as_arrays_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_scanner_get_cells_as_arrays_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_scanner_get_cells_as_arrays_pargs {
 public:


  virtual ~ClientService_scanner_get_cells_as_arrays_pargs() throw();
  const Scanner* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_scanner_get_cells_as_arrays_result__isset {
  _ClientService_scanner_get_cells_as_arrays_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_scanner_get_cells_as_arrays_result__isset;

class ClientService_scanner_get_cells_as_arrays_result {
 public:

  ClientService_scanner_get_cells_as_arrays_result(const ClientService_scanner_get_cells_as_arrays_result&);
  ClientService_scanner_get_cells_as_arrays_result& operator=(const ClientService_scanner_get_cells_as_arrays_result&);
  ClientService_scanner_get_cells_as_arrays_result() {
  }

  virtual ~ClientService_scanner_get_cells_as_arrays_result() throw();
  std::vector<CellAsArray>  success;
  ClientException e;

  _ClientService_scanner_get_cells_as_arrays_result__isset __isset;

  void __set_success(const std::vector<CellAsArray> & val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_scanner_get_cells_as_arrays_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_scanner_get_cells_as_arrays_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_scanner_get_cells_as_arrays_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_scanner_get_cells_as_arrays_presult__isset {
  _ClientService_scanner_get_cells_as_arrays_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_scanner_get_cells_as_arrays_presult__isset;

class ClientService_scanner_get_cells_as_arrays_presult {
 public:


  virtual ~ClientService_scanner_get_cells_as_arrays_presult() throw();
  std::vector<CellAsArray> * success;
  ClientException e;

  _ClientService_scanner_get_cells_as_arrays_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_next_cells_as_arrays_args__isset {
  _ClientService_next_cells_as_arrays_args__isset() : scanner(false) {}
  bool scanner :1;
} _ClientService_next_cells_as_arrays_args__isset;

class ClientService_next_cells_as_arrays_args {
 public:

  ClientService_next_cells_as_arrays_args(const ClientService_next_cells_as_arrays_args&);
  ClientService_next_cells_as_arrays_args& operator=(const ClientService_next_cells_as_arrays_args&);
  ClientService_next_cells_as_arrays_args() : scanner(0) {
  }

  virtual ~ClientService_next_cells_as_arrays_args() throw();
  Scanner scanner;

  _ClientService_next_cells_as_arrays_args__isset __isset;

  void __set_scanner(const Scanner val);

  bool operator == (const ClientService_next_cells_as_arrays_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const ClientService_next_cells_as_arrays_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_next_cells_as_arrays_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_next_cells_as_arrays_pargs {
 public:


  virtual ~ClientService_next_cells_as_arrays_pargs() throw();
  const Scanner* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_next_cells_as_arrays_result__isset {
  _ClientService_next_cells_as_arrays_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_next_cells_as_arrays_result__isset;

class ClientService_next_cells_as_arrays_result {
 public:

  ClientService_next_cells_as_arrays_result(const ClientService_next_cells_as_arrays_result&);
  ClientService_next_cells_as_arrays_result& operator=(const ClientService_next_cells_as_arrays_result&);
  ClientService_next_cells_as_arrays_result() {
  }

  virtual ~ClientService_next_cells_as_arrays_result() throw();
  std::vector<CellAsArray>  success;
  ClientException e;

  _ClientService_next_cells_as_arrays_result__isset __isset;

  void __set_success(const std::vector<CellAsArray> & val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_next_cells_as_arrays_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_next_cells_as_arrays_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_next_cells_as_arrays_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_next_cells_as_arrays_presult__isset {
  _ClientService_next_cells_as_arrays_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_next_cells_as_arrays_presult__isset;

class ClientService_next_cells_as_arrays_presult {
 public:


  virtual ~ClientService_next_cells_as_arrays_presult() throw();
  std::vector<CellAsArray> * success;
  ClientException e;

  _ClientService_next_cells_as_arrays_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_scanner_get_cells_serialized_args__isset {
  _ClientService_scanner_get_cells_serialized_args__isset() : scanner(false) {}
  bool scanner :1;
} _ClientService_scanner_get_cells_serialized_args__isset;

class ClientService_scanner_get_cells_serialized_args {
 public:

  ClientService_scanner_get_cells_serialized_args(const ClientService_scanner_get_cells_serialized_args&);
  ClientService_scanner_get_cells_serialized_args& operator=(const ClientService_scanner_get_cells_serialized_args&);
  ClientService_scanner_get_cells_serialized_args() : scanner(0) {
  }

  virtual ~ClientService_scanner_get_cells_serialized_args() throw();
  Scanner scanner;

  _ClientService_scanner_get_cells_serialized_args__isset __isset;

  void __set_scanner(const Scanner val);

  bool operator == (const ClientService_scanner_get_cells_serialized_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const ClientService_scanner_get_cells_serialized_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_scanner_get_cells_serialized_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_scanner_get_cells_serialized_pargs {
 public:


  virtual ~ClientService_scanner_get_cells_serialized_pargs() throw();
  const Scanner* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_scanner_get_cells_serialized_result__isset {
  _ClientService_scanner_get_cells_serialized_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_scanner_get_cells_serialized_result__isset;

class ClientService_scanner_get_cells_serialized_result {
 public:

  ClientService_scanner_get_cells_serialized_result(const ClientService_scanner_get_cells_serialized_result&);
  ClientService_scanner_get_cells_serialized_result& operator=(const ClientService_scanner_get_cells_serialized_result&);
  ClientService_scanner_get_cells_serialized_result() : success() {
  }

  virtual ~ClientService_scanner_get_cells_serialized_result() throw();
  CellsSerialized success;
  ClientException e;

  _ClientService_scanner_get_cells_serialized_result__isset __isset;

  void __set_success(const CellsSerialized& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_scanner_get_cells_serialized_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_scanner_get_cells_serialized_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_scanner_get_cells_serialized_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_scanner_get_cells_serialized_presult__isset {
  _ClientService_scanner_get_cells_serialized_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_scanner_get_cells_serialized_presult__isset;

class ClientService_scanner_get_cells_serialized_presult {
 public:


  virtual ~ClientService_scanner_get_cells_serialized_presult() throw();
  CellsSerialized* success;
  ClientException e;

  _ClientService_scanner_get_cells_serialized_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_next_cells_serialized_args__isset {
  _ClientService_next_cells_serialized_args__isset() : scanner(false) {}
  bool scanner :1;
} _ClientService_next_cells_serialized_args__isset;

class ClientService_next_cells_serialized_args {
 public:

  ClientService_next_cells_serialized_args(const ClientService_next_cells_serialized_args&);
  ClientService_next_cells_serialized_args& operator=(const ClientService_next_cells_serialized_args&);
  ClientService_next_cells_serialized_args() : scanner(0) {
  }

  virtual ~ClientService_next_cells_serialized_args() throw();
  Scanner scanner;

  _ClientService_next_cells_serialized_args__isset __isset;

  void __set_scanner(const Scanner val);

  bool operator == (const ClientService_next_cells_serialized_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const ClientService_next_cells_serialized_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_next_cells_serialized_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_next_cells_serialized_pargs {
 public:


  virtual ~ClientService_next_cells_serialized_pargs() throw();
  const Scanner* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_next_cells_serialized_result__isset {
  _ClientService_next_cells_serialized_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_next_cells_serialized_result__isset;

class ClientService_next_cells_serialized_result {
 public:

  ClientService_next_cells_serialized_result(const ClientService_next_cells_serialized_result&);
  ClientService_next_cells_serialized_result& operator=(const ClientService_next_cells_serialized_result&);
  ClientService_next_cells_serialized_result() : success() {
  }

  virtual ~ClientService_next_cells_serialized_result() throw();
  CellsSerialized success;
  ClientException e;

  _ClientService_next_cells_serialized_result__isset __isset;

  void __set_success(const CellsSerialized& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_next_cells_serialized_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_next_cells_serialized_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_next_cells_serialized_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_next_cells_serialized_presult__isset {
  _ClientService_next_cells_serialized_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_next_cells_serialized_presult__isset;

class ClientService_next_cells_serialized_presult {
 public:


  virtual ~ClientService_next_cells_serialized_presult() throw();
  CellsSerialized* success;
  ClientException e;

  _ClientService_next_cells_serialized_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_scanner_get_row_args__isset {
  _ClientService_scanner_get_row_args__isset() : scanner(false) {}
  bool scanner :1;
} _ClientService_scanner_get_row_args__isset;

class ClientService_scanner_get_row_args {
 public:

  ClientService_scanner_get_row_args(const ClientService_scanner_get_row_args&);
  ClientService_scanner_get_row_args& operator=(const ClientService_scanner_get_row_args&);
  ClientService_scanner_get_row_args() : scanner(0) {
  }

  virtual ~ClientService_scanner_get_row_args() throw();
  Scanner scanner;

  _ClientService_scanner_get_row_args__isset __isset;

  void __set_scanner(const Scanner val);

  bool operator == (const ClientService_scanner_get_row_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const ClientService_scanner_get_row_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_scanner_get_row_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_scanner_get_row_pargs {
 public:


  virtual ~ClientService_scanner_get_row_pargs() throw();
  const Scanner* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_scanner_get_row_result__isset {
  _ClientService_scanner_get_row_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_scanner_get_row_result__isset;

class ClientService_scanner_get_row_result {
 public:

  ClientService_scanner_get_row_result(const ClientService_scanner_get_row_result&);
  ClientService_scanner_get_row_result& operator=(const ClientService_scanner_get_row_result&);
  ClientService_scanner_get_row_result() {
  }

  virtual ~ClientService_scanner_get_row_result() throw();
  std::vector<Cell>  success;
  ClientException e;

  _ClientService_scanner_get_row_result__isset __isset;

  void __set_success(const std::vector<Cell> & val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_scanner_get_row_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_scanner_get_row_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_scanner_get_row_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_scanner_get_row_presult__isset {
  _ClientService_scanner_get_row_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_scanner_get_row_presult__isset;

class ClientService_scanner_get_row_presult {
 public:


  virtual ~ClientService_scanner_get_row_presult() throw();
  std::vector<Cell> * success;
  ClientException e;

  _ClientService_scanner_get_row_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_next_row_args__isset {
  _ClientService_next_row_args__isset() : scanner(false) {}
  bool scanner :1;
} _ClientService_next_row_args__isset;

class ClientService_next_row_args {
 public:

  ClientService_next_row_args(const ClientService_next_row_args&);
  ClientService_next_row_args& operator=(const ClientService_next_row_args&);
  ClientService_next_row_args() : scanner(0) {
  }

  virtual ~ClientService_next_row_args() throw();
  Scanner scanner;

  _ClientService_next_row_args__isset __isset;

  void __set_scanner(const Scanner val);

  bool operator == (const ClientService_next_row_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const ClientService_next_row_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_next_row_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_next_row_pargs {
 public:


  virtual ~ClientService_next_row_pargs() throw();
  const Scanner* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_next_row_result__isset {
  _ClientService_next_row_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_next_row_result__isset;

class ClientService_next_row_result {
 public:

  ClientService_next_row_result(const ClientService_next_row_result&);
  ClientService_next_row_result& operator=(const ClientService_next_row_result&);
  ClientService_next_row_result() {
  }

  virtual ~ClientService_next_row_result() throw();
  std::vector<Cell>  success;
  ClientException e;

  _ClientService_next_row_result__isset __isset;

  void __set_success(const std::vector<Cell> & val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_next_row_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_next_row_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_next_row_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_next_row_presult__isset {
  _ClientService_next_row_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_next_row_presult__isset;

class ClientService_next_row_presult {
 public:


  virtual ~ClientService_next_row_presult() throw();
  std::vector<Cell> * success;
  ClientException e;

  _ClientService_next_row_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_scanner_get_row_as_arrays_args__isset {
  _ClientService_scanner_get_row_as_arrays_args__isset() : scanner(false) {}
  bool scanner :1;
} _ClientService_scanner_get_row_as_arrays_args__isset;

class ClientService_scanner_get_row_as_arrays_args {
 public:

  ClientService_scanner_get_row_as_arrays_args(const ClientService_scanner_get_row_as_arrays_args&);
  ClientService_scanner_get_row_as_arrays_args& operator=(const ClientService_scanner_get_row_as_arrays_args&);
  ClientService_scanner_get_row_as_arrays_args() : scanner(0) {
  }

  virtual ~ClientService_scanner_get_row_as_arrays_args() throw();
  Scanner scanner;

  _ClientService_scanner_get_row_as_arrays_args__isset __isset;

  void __set_scanner(const Scanner val);

  bool operator == (const ClientService_scanner_get_row_as_arrays_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const ClientService_scanner_get_row_as_arrays_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_scanner_get_row_as_arrays_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_scanner_get_row_as_arrays_pargs {
 public:


  virtual ~ClientService_scanner_get_row_as_arrays_pargs() throw();
  const Scanner* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_scanner_get_row_as_arrays_result__isset {
  _ClientService_scanner_get_row_as_arrays_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_scanner_get_row_as_arrays_result__isset;

class ClientService_scanner_get_row_as_arrays_result {
 public:

  ClientService_scanner_get_row_as_arrays_result(const ClientService_scanner_get_row_as_arrays_result&);
  ClientService_scanner_get_row_as_arrays_result& operator=(const ClientService_scanner_get_row_as_arrays_result&);
  ClientService_scanner_get_row_as_arrays_result() {
  }

  virtual ~ClientService_scanner_get_row_as_arrays_result() throw();
  std::vector<CellAsArray>  success;
  ClientException e;

  _ClientService_scanner_get_row_as_arrays_result__isset __isset;

  void __set_success(const std::vector<CellAsArray> & val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_scanner_get_row_as_arrays_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_scanner_get_row_as_arrays_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_scanner_get_row_as_arrays_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_scanner_get_row_as_arrays_presult__isset {
  _ClientService_scanner_get_row_as_arrays_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_scanner_get_row_as_arrays_presult__isset;

class ClientService_scanner_get_row_as_arrays_presult {
 public:


  virtual ~ClientService_scanner_get_row_as_arrays_presult() throw();
  std::vector<CellAsArray> * success;
  ClientException e;

  _ClientService_scanner_get_row_as_arrays_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_next_row_as_arrays_args__isset {
  _ClientService_next_row_as_arrays_args__isset() : scanner(false) {}
  bool scanner :1;
} _ClientService_next_row_as_arrays_args__isset;

class ClientService_next_row_as_arrays_args {
 public:

  ClientService_next_row_as_arrays_args(const ClientService_next_row_as_arrays_args&);
  ClientService_next_row_as_arrays_args& operator=(const ClientService_next_row_as_arrays_args&);
  ClientService_next_row_as_arrays_args() : scanner(0) {
  }

  virtual ~ClientService_next_row_as_arrays_args() throw();
  Scanner scanner;

  _ClientService_next_row_as_arrays_args__isset __isset;

  void __set_scanner(const Scanner val);

  bool operator == (const ClientService_next_row_as_arrays_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const ClientService_next_row_as_arrays_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_next_row_as_arrays_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_next_row_as_arrays_pargs {
 public:


  virtual ~ClientService_next_row_as_arrays_pargs() throw();
  const Scanner* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_next_row_as_arrays_result__isset {
  _ClientService_next_row_as_arrays_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_next_row_as_arrays_result__isset;

class ClientService_next_row_as_arrays_result {
 public:

  ClientService_next_row_as_arrays_result(const ClientService_next_row_as_arrays_result&);
  ClientService_next_row_as_arrays_result& operator=(const ClientService_next_row_as_arrays_result&);
  ClientService_next_row_as_arrays_result() {
  }

  virtual ~ClientService_next_row_as_arrays_result() throw();
  std::vector<CellAsArray>  success;
  ClientException e;

  _ClientService_next_row_as_arrays_result__isset __isset;

  void __set_success(const std::vector<CellAsArray> & val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_next_row_as_arrays_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_next_row_as_arrays_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_next_row_as_arrays_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_next_row_as_arrays_presult__isset {
  _ClientService_next_row_as_arrays_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_next_row_as_arrays_presult__isset;

class ClientService_next_row_as_arrays_presult {
 public:


  virtual ~ClientService_next_row_as_arrays_presult() throw();
  std::vector<CellAsArray> * success;
  ClientException e;

  _ClientService_next_row_as_arrays_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_scanner_get_row_serialized_args__isset {
  _ClientService_scanner_get_row_serialized_args__isset() : scanner(false) {}
  bool scanner :1;
} _ClientService_scanner_get_row_serialized_args__isset;

class ClientService_scanner_get_row_serialized_args {
 public:

  ClientService_scanner_get_row_serialized_args(const ClientService_scanner_get_row_serialized_args&);
  ClientService_scanner_get_row_serialized_args& operator=(const ClientService_scanner_get_row_serialized_args&);
  ClientService_scanner_get_row_serialized_args() : scanner(0) {
  }

  virtual ~ClientService_scanner_get_row_serialized_args() throw();
  Scanner scanner;

  _ClientService_scanner_get_row_serialized_args__isset __isset;

  void __set_scanner(const Scanner val);

  bool operator == (const ClientService_scanner_get_row_serialized_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const ClientService_scanner_get_row_serialized_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_scanner_get_row_serialized_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_scanner_get_row_serialized_pargs {
 public:


  virtual ~ClientService_scanner_get_row_serialized_pargs() throw();
  const Scanner* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_scanner_get_row_serialized_result__isset {
  _ClientService_scanner_get_row_serialized_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_scanner_get_row_serialized_result__isset;

class ClientService_scanner_get_row_serialized_result {
 public:

  ClientService_scanner_get_row_serialized_result(const ClientService_scanner_get_row_serialized_result&);
  ClientService_scanner_get_row_serialized_result& operator=(const ClientService_scanner_get_row_serialized_result&);
  ClientService_scanner_get_row_serialized_result() : success() {
  }

  virtual ~ClientService_scanner_get_row_serialized_result() throw();
  CellsSerialized success;
  ClientException e;

  _ClientService_scanner_get_row_serialized_result__isset __isset;

  void __set_success(const CellsSerialized& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_scanner_get_row_serialized_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_scanner_get_row_serialized_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_scanner_get_row_serialized_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_scanner_get_row_serialized_presult__isset {
  _ClientService_scanner_get_row_serialized_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_scanner_get_row_serialized_presult__isset;

class ClientService_scanner_get_row_serialized_presult {
 public:


  virtual ~ClientService_scanner_get_row_serialized_presult() throw();
  CellsSerialized* success;
  ClientException e;

  _ClientService_scanner_get_row_serialized_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_next_row_serialized_args__isset {
  _ClientService_next_row_serialized_args__isset() : scanner(false) {}
  bool scanner :1;
} _ClientService_next_row_serialized_args__isset;

class ClientService_next_row_serialized_args {
 public:

  ClientService_next_row_serialized_args(const ClientService_next_row_serialized_args&);
  ClientService_next_row_serialized_args& operator=(const ClientService_next_row_serialized_args&);
  ClientService_next_row_serialized_args() : scanner(0) {
  }

  virtual ~ClientService_next_row_serialized_args() throw();
  Scanner scanner;

  _ClientService_next_row_serialized_args__isset __isset;

  void __set_scanner(const Scanner val);

  bool operator == (const ClientService_next_row_serialized_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const ClientService_next_row_serialized_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_next_row_serialized_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_next_row_serialized_pargs {
 public:


  virtual ~ClientService_next_row_serialized_pargs() throw();
  const Scanner* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_next_row_serialized_result__isset {
  _ClientService_next_row_serialized_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_next_row_serialized_result__isset;

class ClientService_next_row_serialized_result {
 public:

  ClientService_next_row_serialized_result(const ClientService_next_row_serialized_result&);
  ClientService_next_row_serialized_result& operator=(const ClientService_next_row_serialized_result&);
  ClientService_next_row_serialized_result() : success() {
  }

  virtual ~ClientService_next_row_serialized_result() throw();
  CellsSerialized success;
  ClientException e;

  _ClientService_next_row_serialized_result__isset __isset;

  void __set_success(const CellsSerialized& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_next_row_serialized_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_next_row_serialized_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_next_row_serialized_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_next_row_serialized_presult__isset {
  _ClientService_next_row_serialized_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_next_row_serialized_presult__isset;

class ClientService_next_row_serialized_presult {
 public:


  virtual ~ClientService_next_row_serialized_presult() throw();
  CellsSerialized* success;
  ClientException e;

  _ClientService_next_row_serialized_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_get_row_args__isset {
  _ClientService_get_row_args__isset() : ns(false), table_name(false), row(false) {}
  bool ns :1;
  bool table_name :1;
  bool row :1;
} _ClientService_get_row_args__isset;

class ClientService_get_row_args {
 public:

  ClientService_get_row_args(const ClientService_get_row_args&);
  ClientService_get_row_args& operator=(const ClientService_get_row_args&);
  ClientService_get_row_args() : ns(0), table_name(), row() {
  }

  virtual ~ClientService_get_row_args() throw();
  Namespace ns;
  std::string table_name;
  std::string row;

  _ClientService_get_row_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_row(const std::string& val);

  bool operator == (const ClientService_get_row_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(row == rhs.row))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_row_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_row_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_get_row_pargs {
 public:


  virtual ~ClientService_get_row_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const std::string* row;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_row_result__isset {
  _ClientService_get_row_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_row_result__isset;

class ClientService_get_row_result {
 public:

  ClientService_get_row_result(const ClientService_get_row_result&);
  ClientService_get_row_result& operator=(const ClientService_get_row_result&);
  ClientService_get_row_result() {
  }

  virtual ~ClientService_get_row_result() throw();
  std::vector<Cell>  success;
  ClientException e;

  _ClientService_get_row_result__isset __isset;

  void __set_success(const std::vector<Cell> & val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_get_row_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_row_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_row_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_row_presult__isset {
  _ClientService_get_row_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_row_presult__isset;

class ClientService_get_row_presult {
 public:


  virtual ~ClientService_get_row_presult() throw();
  std::vector<Cell> * success;
  ClientException e;

  _ClientService_get_row_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_get_row_as_arrays_args__isset {
  _ClientService_get_row_as_arrays_args__isset() : ns(false), name(false), row(false) {}
  bool ns :1;
  bool name :1;
  bool row :1;
} _ClientService_get_row_as_arrays_args__isset;

class ClientService_get_row_as_arrays_args {
 public:

  ClientService_get_row_as_arrays_args(const ClientService_get_row_as_arrays_args&);
  ClientService_get_row_as_arrays_args& operator=(const ClientService_get_row_as_arrays_args&);
  ClientService_get_row_as_arrays_args() : ns(0), name(), row() {
  }

  virtual ~ClientService_get_row_as_arrays_args() throw();
  Namespace ns;
  std::string name;
  std::string row;

  _ClientService_get_row_as_arrays_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_name(const std::string& val);

  void __set_row(const std::string& val);

  bool operator == (const ClientService_get_row_as_arrays_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(row == rhs.row))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_row_as_arrays_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_row_as_arrays_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_get_row_as_arrays_pargs {
 public:


  virtual ~ClientService_get_row_as_arrays_pargs() throw();
  const Namespace* ns;
  const std::string* name;
  const std::string* row;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_row_as_arrays_result__isset {
  _ClientService_get_row_as_arrays_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_row_as_arrays_result__isset;

class ClientService_get_row_as_arrays_result {
 public:

  ClientService_get_row_as_arrays_result(const ClientService_get_row_as_arrays_result&);
  ClientService_get_row_as_arrays_result& operator=(const ClientService_get_row_as_arrays_result&);
  ClientService_get_row_as_arrays_result() {
  }

  virtual ~ClientService_get_row_as_arrays_result() throw();
  std::vector<CellAsArray>  success;
  ClientException e;

  _ClientService_get_row_as_arrays_result__isset __isset;

  void __set_success(const std::vector<CellAsArray> & val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_get_row_as_arrays_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_row_as_arrays_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_row_as_arrays_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_row_as_arrays_presult__isset {
  _ClientService_get_row_as_arrays_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_row_as_arrays_presult__isset;

class ClientService_get_row_as_arrays_presult {
 public:


  virtual ~ClientService_get_row_as_arrays_presult() throw();
  std::vector<CellAsArray> * success;
  ClientException e;

  _ClientService_get_row_as_arrays_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_get_row_serialized_args__isset {
  _ClientService_get_row_serialized_args__isset() : ns(false), table_name(false), row(false) {}
  bool ns :1;
  bool table_name :1;
  bool row :1;
} _ClientService_get_row_serialized_args__isset;

class ClientService_get_row_serialized_args {
 public:

  ClientService_get_row_serialized_args(const ClientService_get_row_serialized_args&);
  ClientService_get_row_serialized_args& operator=(const ClientService_get_row_serialized_args&);
  ClientService_get_row_serialized_args() : ns(0), table_name(), row() {
  }

  virtual ~ClientService_get_row_serialized_args() throw();
  Namespace ns;
  std::string table_name;
  std::string row;

  _ClientService_get_row_serialized_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_row(const std::string& val);

  bool operator == (const ClientService_get_row_serialized_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(row == rhs.row))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_row_serialized_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_row_serialized_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_get_row_serialized_pargs {
 public:


  virtual ~ClientService_get_row_serialized_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const std::string* row;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_row_serialized_result__isset {
  _ClientService_get_row_serialized_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_row_serialized_result__isset;

class ClientService_get_row_serialized_result {
 public:

  ClientService_get_row_serialized_result(const ClientService_get_row_serialized_result&);
  ClientService_get_row_serialized_result& operator=(const ClientService_get_row_serialized_result&);
  ClientService_get_row_serialized_result() : success() {
  }

  virtual ~ClientService_get_row_serialized_result() throw();
  CellsSerialized success;
  ClientException e;

  _ClientService_get_row_serialized_result__isset __isset;

  void __set_success(const CellsSerialized& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_get_row_serialized_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_row_serialized_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_row_serialized_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_row_serialized_presult__isset {
  _ClientService_get_row_serialized_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_row_serialized_presult__isset;

class ClientService_get_row_serialized_presult {
 public:


  virtual ~ClientService_get_row_serialized_presult() throw();
  CellsSerialized* success;
  ClientException e;

  _ClientService_get_row_serialized_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_get_cell_args__isset {
  _ClientService_get_cell_args__isset() : ns(false), table_name(false), row(false), column(false) {}
  bool ns :1;
  bool table_name :1;
  bool row :1;
  bool column :1;
} _ClientService_get_cell_args__isset;

class ClientService_get_cell_args {
 public:

  ClientService_get_cell_args(const ClientService_get_cell_args&);
  ClientService_get_cell_args& operator=(const ClientService_get_cell_args&);
  ClientService_get_cell_args() : ns(0), table_name(), row(), column() {
  }

  virtual ~ClientService_get_cell_args() throw();
  Namespace ns;
  std::string table_name;
  std::string row;
  std::string column;

  _ClientService_get_cell_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_row(const std::string& val);

  void __set_column(const std::string& val);

  bool operator == (const ClientService_get_cell_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_cell_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_cell_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_get_cell_pargs {
 public:


  virtual ~ClientService_get_cell_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const std::string* row;
  const std::string* column;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_cell_result__isset {
  _ClientService_get_cell_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_cell_result__isset;

class ClientService_get_cell_result {
 public:

  ClientService_get_cell_result(const ClientService_get_cell_result&);
  ClientService_get_cell_result& operator=(const ClientService_get_cell_result&);
  ClientService_get_cell_result() : success() {
  }

  virtual ~ClientService_get_cell_result() throw();
  Value success;
  ClientException e;

  _ClientService_get_cell_result__isset __isset;

  void __set_success(const Value& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_get_cell_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_cell_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_cell_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_cell_presult__isset {
  _ClientService_get_cell_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_cell_presult__isset;

class ClientService_get_cell_presult {
 public:


  virtual ~ClientService_get_cell_presult() throw();
  Value* success;
  ClientException e;

  _ClientService_get_cell_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_get_cells_args__isset {
  _ClientService_get_cells_args__isset() : ns(false), table_name(false), scan_spec(false) {}
  bool ns :1;
  bool table_name :1;
  bool scan_spec :1;
} _ClientService_get_cells_args__isset;

class ClientService_get_cells_args {
 public:

  ClientService_get_cells_args(const ClientService_get_cells_args&);
  ClientService_get_cells_args& operator=(const ClientService_get_cells_args&);
  ClientService_get_cells_args() : ns(0), table_name() {
  }

  virtual ~ClientService_get_cells_args() throw();
  Namespace ns;
  std::string table_name;
  ScanSpec scan_spec;

  _ClientService_get_cells_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_scan_spec(const ScanSpec& val);

  bool operator == (const ClientService_get_cells_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(scan_spec == rhs.scan_spec))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_cells_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_cells_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_get_cells_pargs {
 public:


  virtual ~ClientService_get_cells_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const ScanSpec* scan_spec;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_cells_result__isset {
  _ClientService_get_cells_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_cells_result__isset;

class ClientService_get_cells_result {
 public:

  ClientService_get_cells_result(const ClientService_get_cells_result&);
  ClientService_get_cells_result& operator=(const ClientService_get_cells_result&);
  ClientService_get_cells_result() {
  }

  virtual ~ClientService_get_cells_result() throw();
  std::vector<Cell>  success;
  ClientException e;

  _ClientService_get_cells_result__isset __isset;

  void __set_success(const std::vector<Cell> & val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_get_cells_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_cells_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_cells_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_cells_presult__isset {
  _ClientService_get_cells_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_cells_presult__isset;

class ClientService_get_cells_presult {
 public:


  virtual ~ClientService_get_cells_presult() throw();
  std::vector<Cell> * success;
  ClientException e;

  _ClientService_get_cells_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_get_cells_as_arrays_args__isset {
  _ClientService_get_cells_as_arrays_args__isset() : ns(false), name(false), scan_spec(false) {}
  bool ns :1;
  bool name :1;
  bool scan_spec :1;
} _ClientService_get_cells_as_arrays_args__isset;

class ClientService_get_cells_as_arrays_args {
 public:

  ClientService_get_cells_as_arrays_args(const ClientService_get_cells_as_arrays_args&);
  ClientService_get_cells_as_arrays_args& operator=(const ClientService_get_cells_as_arrays_args&);
  ClientService_get_cells_as_arrays_args() : ns(0), name() {
  }

  virtual ~ClientService_get_cells_as_arrays_args() throw();
  Namespace ns;
  std::string name;
  ScanSpec scan_spec;

  _ClientService_get_cells_as_arrays_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_name(const std::string& val);

  void __set_scan_spec(const ScanSpec& val);

  bool operator == (const ClientService_get_cells_as_arrays_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(scan_spec == rhs.scan_spec))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_cells_as_arrays_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_cells_as_arrays_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_get_cells_as_arrays_pargs {
 public:


  virtual ~ClientService_get_cells_as_arrays_pargs() throw();
  const Namespace* ns;
  const std::string* name;
  const ScanSpec* scan_spec;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_cells_as_arrays_result__isset {
  _ClientService_get_cells_as_arrays_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_cells_as_arrays_result__isset;

class ClientService_get_cells_as_arrays_result {
 public:

  ClientService_get_cells_as_arrays_result(const ClientService_get_cells_as_arrays_result&);
  ClientService_get_cells_as_arrays_result& operator=(const ClientService_get_cells_as_arrays_result&);
  ClientService_get_cells_as_arrays_result() {
  }

  virtual ~ClientService_get_cells_as_arrays_result() throw();
  std::vector<CellAsArray>  success;
  ClientException e;

  _ClientService_get_cells_as_arrays_result__isset __isset;

  void __set_success(const std::vector<CellAsArray> & val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_get_cells_as_arrays_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_cells_as_arrays_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_cells_as_arrays_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_cells_as_arrays_presult__isset {
  _ClientService_get_cells_as_arrays_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_cells_as_arrays_presult__isset;

class ClientService_get_cells_as_arrays_presult {
 public:


  virtual ~ClientService_get_cells_as_arrays_presult() throw();
  std::vector<CellAsArray> * success;
  ClientException e;

  _ClientService_get_cells_as_arrays_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_get_cells_serialized_args__isset {
  _ClientService_get_cells_serialized_args__isset() : ns(false), name(false), scan_spec(false) {}
  bool ns :1;
  bool name :1;
  bool scan_spec :1;
} _ClientService_get_cells_serialized_args__isset;

class ClientService_get_cells_serialized_args {
 public:

  ClientService_get_cells_serialized_args(const ClientService_get_cells_serialized_args&);
  ClientService_get_cells_serialized_args& operator=(const ClientService_get_cells_serialized_args&);
  ClientService_get_cells_serialized_args() : ns(0), name() {
  }

  virtual ~ClientService_get_cells_serialized_args() throw();
  Namespace ns;
  std::string name;
  ScanSpec scan_spec;

  _ClientService_get_cells_serialized_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_name(const std::string& val);

  void __set_scan_spec(const ScanSpec& val);

  bool operator == (const ClientService_get_cells_serialized_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(scan_spec == rhs.scan_spec))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_cells_serialized_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_cells_serialized_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_get_cells_serialized_pargs {
 public:


  virtual ~ClientService_get_cells_serialized_pargs() throw();
  const Namespace* ns;
  const std::string* name;
  const ScanSpec* scan_spec;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_cells_serialized_result__isset {
  _ClientService_get_cells_serialized_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_cells_serialized_result__isset;

class ClientService_get_cells_serialized_result {
 public:

  ClientService_get_cells_serialized_result(const ClientService_get_cells_serialized_result&);
  ClientService_get_cells_serialized_result& operator=(const ClientService_get_cells_serialized_result&);
  ClientService_get_cells_serialized_result() : success() {
  }

  virtual ~ClientService_get_cells_serialized_result() throw();
  CellsSerialized success;
  ClientException e;

  _ClientService_get_cells_serialized_result__isset __isset;

  void __set_success(const CellsSerialized& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_get_cells_serialized_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_cells_serialized_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_cells_serialized_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_cells_serialized_presult__isset {
  _ClientService_get_cells_serialized_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_cells_serialized_presult__isset;

class ClientService_get_cells_serialized_presult {
 public:


  virtual ~ClientService_get_cells_serialized_presult() throw();
  CellsSerialized* success;
  ClientException e;

  _ClientService_get_cells_serialized_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_shared_mutator_refresh_args__isset {
  _ClientService_shared_mutator_refresh_args__isset() : ns(false), table_name(false), mutate_spec(false) {}
  bool ns :1;
  bool table_name :1;
  bool mutate_spec :1;
} _ClientService_shared_mutator_refresh_args__isset;

class ClientService_shared_mutator_refresh_args {
 public:

  ClientService_shared_mutator_refresh_args(const ClientService_shared_mutator_refresh_args&);
  ClientService_shared_mutator_refresh_args& operator=(const ClientService_shared_mutator_refresh_args&);
  ClientService_shared_mutator_refresh_args() : ns(0), table_name() {
  }

  virtual ~ClientService_shared_mutator_refresh_args() throw();
  Namespace ns;
  std::string table_name;
  MutateSpec mutate_spec;

  _ClientService_shared_mutator_refresh_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_mutate_spec(const MutateSpec& val);

  bool operator == (const ClientService_shared_mutator_refresh_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(mutate_spec == rhs.mutate_spec))
      return false;
    return true;
  }
  bool operator != (const ClientService_shared_mutator_refresh_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_shared_mutator_refresh_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_shared_mutator_refresh_pargs {
 public:


  virtual ~ClientService_shared_mutator_refresh_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const MutateSpec* mutate_spec;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_shared_mutator_refresh_result__isset {
  _ClientService_shared_mutator_refresh_result__isset() : e(false) {}
  bool e :1;
} _ClientService_shared_mutator_refresh_result__isset;

class ClientService_shared_mutator_refresh_result {
 public:

  ClientService_shared_mutator_refresh_result(const ClientService_shared_mutator_refresh_result&);
  ClientService_shared_mutator_refresh_result& operator=(const ClientService_shared_mutator_refresh_result&);
  ClientService_shared_mutator_refresh_result() {
  }

  virtual ~ClientService_shared_mutator_refresh_result() throw();
  ClientException e;

  _ClientService_shared_mutator_refresh_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_shared_mutator_refresh_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_shared_mutator_refresh_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_shared_mutator_refresh_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_shared_mutator_refresh_presult__isset {
  _ClientService_shared_mutator_refresh_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_shared_mutator_refresh_presult__isset;

class ClientService_shared_mutator_refresh_presult {
 public:


  virtual ~ClientService_shared_mutator_refresh_presult() throw();
  ClientException e;

  _ClientService_shared_mutator_refresh_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_refresh_shared_mutator_args__isset {
  _ClientService_refresh_shared_mutator_args__isset() : ns(false), table_name(false), mutate_spec(false) {}
  bool ns :1;
  bool table_name :1;
  bool mutate_spec :1;
} _ClientService_refresh_shared_mutator_args__isset;

class ClientService_refresh_shared_mutator_args {
 public:

  ClientService_refresh_shared_mutator_args(const ClientService_refresh_shared_mutator_args&);
  ClientService_refresh_shared_mutator_args& operator=(const ClientService_refresh_shared_mutator_args&);
  ClientService_refresh_shared_mutator_args() : ns(0), table_name() {
  }

  virtual ~ClientService_refresh_shared_mutator_args() throw();
  Namespace ns;
  std::string table_name;
  MutateSpec mutate_spec;

  _ClientService_refresh_shared_mutator_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_mutate_spec(const MutateSpec& val);

  bool operator == (const ClientService_refresh_shared_mutator_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(mutate_spec == rhs.mutate_spec))
      return false;
    return true;
  }
  bool operator != (const ClientService_refresh_shared_mutator_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_refresh_shared_mutator_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_refresh_shared_mutator_pargs {
 public:


  virtual ~ClientService_refresh_shared_mutator_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const MutateSpec* mutate_spec;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_refresh_shared_mutator_result__isset {
  _ClientService_refresh_shared_mutator_result__isset() : e(false) {}
  bool e :1;
} _ClientService_refresh_shared_mutator_result__isset;

class ClientService_refresh_shared_mutator_result {
 public:

  ClientService_refresh_shared_mutator_result(const ClientService_refresh_shared_mutator_result&);
  ClientService_refresh_shared_mutator_result& operator=(const ClientService_refresh_shared_mutator_result&);
  ClientService_refresh_shared_mutator_result() {
  }

  virtual ~ClientService_refresh_shared_mutator_result() throw();
  ClientException e;

  _ClientService_refresh_shared_mutator_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_refresh_shared_mutator_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_refresh_shared_mutator_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_refresh_shared_mutator_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_refresh_shared_mutator_presult__isset {
  _ClientService_refresh_shared_mutator_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_refresh_shared_mutator_presult__isset;

class ClientService_refresh_shared_mutator_presult {
 public:


  virtual ~ClientService_refresh_shared_mutator_presult() throw();
  ClientException e;

  _ClientService_refresh_shared_mutator_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_shared_mutator_set_cells_args__isset {
  _ClientService_shared_mutator_set_cells_args__isset() : ns(false), table_name(false), mutate_spec(false), cells(false) {}
  bool ns :1;
  bool table_name :1;
  bool mutate_spec :1;
  bool cells :1;
} _ClientService_shared_mutator_set_cells_args__isset;

class ClientService_shared_mutator_set_cells_args {
 public:

  ClientService_shared_mutator_set_cells_args(const ClientService_shared_mutator_set_cells_args&);
  ClientService_shared_mutator_set_cells_args& operator=(const ClientService_shared_mutator_set_cells_args&);
  ClientService_shared_mutator_set_cells_args() : ns(0), table_name() {
  }

  virtual ~ClientService_shared_mutator_set_cells_args() throw();
  Namespace ns;
  std::string table_name;
  MutateSpec mutate_spec;
  std::vector<Cell>  cells;

  _ClientService_shared_mutator_set_cells_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_mutate_spec(const MutateSpec& val);

  void __set_cells(const std::vector<Cell> & val);

  bool operator == (const ClientService_shared_mutator_set_cells_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(mutate_spec == rhs.mutate_spec))
      return false;
    if (!(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const ClientService_shared_mutator_set_cells_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_shared_mutator_set_cells_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_shared_mutator_set_cells_pargs {
 public:


  virtual ~ClientService_shared_mutator_set_cells_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const MutateSpec* mutate_spec;
  const std::vector<Cell> * cells;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_shared_mutator_set_cells_result__isset {
  _ClientService_shared_mutator_set_cells_result__isset() : e(false) {}
  bool e :1;
} _ClientService_shared_mutator_set_cells_result__isset;

class ClientService_shared_mutator_set_cells_result {
 public:

  ClientService_shared_mutator_set_cells_result(const ClientService_shared_mutator_set_cells_result&);
  ClientService_shared_mutator_set_cells_result& operator=(const ClientService_shared_mutator_set_cells_result&);
  ClientService_shared_mutator_set_cells_result() {
  }

  virtual ~ClientService_shared_mutator_set_cells_result() throw();
  ClientException e;

  _ClientService_shared_mutator_set_cells_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_shared_mutator_set_cells_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_shared_mutator_set_cells_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_shared_mutator_set_cells_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_shared_mutator_set_cells_presult__isset {
  _ClientService_shared_mutator_set_cells_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_shared_mutator_set_cells_presult__isset;

class ClientService_shared_mutator_set_cells_presult {
 public:


  virtual ~ClientService_shared_mutator_set_cells_presult() throw();
  ClientException e;

  _ClientService_shared_mutator_set_cells_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_offer_cells_args__isset {
  _ClientService_offer_cells_args__isset() : ns(false), table_name(false), mutate_spec(false), cells(false) {}
  bool ns :1;
  bool table_name :1;
  bool mutate_spec :1;
  bool cells :1;
} _ClientService_offer_cells_args__isset;

class ClientService_offer_cells_args {
 public:

  ClientService_offer_cells_args(const ClientService_offer_cells_args&);
  ClientService_offer_cells_args& operator=(const ClientService_offer_cells_args&);
  ClientService_offer_cells_args() : ns(0), table_name() {
  }

  virtual ~ClientService_offer_cells_args() throw();
  Namespace ns;
  std::string table_name;
  MutateSpec mutate_spec;
  std::vector<Cell>  cells;

  _ClientService_offer_cells_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_mutate_spec(const MutateSpec& val);

  void __set_cells(const std::vector<Cell> & val);

  bool operator == (const ClientService_offer_cells_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(mutate_spec == rhs.mutate_spec))
      return false;
    if (!(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const ClientService_offer_cells_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_offer_cells_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_offer_cells_pargs {
 public:


  virtual ~ClientService_offer_cells_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const MutateSpec* mutate_spec;
  const std::vector<Cell> * cells;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_offer_cells_result__isset {
  _ClientService_offer_cells_result__isset() : e(false) {}
  bool e :1;
} _ClientService_offer_cells_result__isset;

class ClientService_offer_cells_result {
 public:

  ClientService_offer_cells_result(const ClientService_offer_cells_result&);
  ClientService_offer_cells_result& operator=(const ClientService_offer_cells_result&);
  ClientService_offer_cells_result() {
  }

  virtual ~ClientService_offer_cells_result() throw();
  ClientException e;

  _ClientService_offer_cells_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_offer_cells_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_offer_cells_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_offer_cells_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_offer_cells_presult__isset {
  _ClientService_offer_cells_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_offer_cells_presult__isset;

class ClientService_offer_cells_presult {
 public:


  virtual ~ClientService_offer_cells_presult() throw();
  ClientException e;

  _ClientService_offer_cells_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_shared_mutator_set_cells_as_arrays_args__isset {
  _ClientService_shared_mutator_set_cells_as_arrays_args__isset() : ns(false), table_name(false), mutate_spec(false), cells(false) {}
  bool ns :1;
  bool table_name :1;
  bool mutate_spec :1;
  bool cells :1;
} _ClientService_shared_mutator_set_cells_as_arrays_args__isset;

class ClientService_shared_mutator_set_cells_as_arrays_args {
 public:

  ClientService_shared_mutator_set_cells_as_arrays_args(const ClientService_shared_mutator_set_cells_as_arrays_args&);
  ClientService_shared_mutator_set_cells_as_arrays_args& operator=(const ClientService_shared_mutator_set_cells_as_arrays_args&);
  ClientService_shared_mutator_set_cells_as_arrays_args() : ns(0), table_name() {
  }

  virtual ~ClientService_shared_mutator_set_cells_as_arrays_args() throw();
  Namespace ns;
  std::string table_name;
  MutateSpec mutate_spec;
  std::vector<CellAsArray>  cells;

  _ClientService_shared_mutator_set_cells_as_arrays_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_mutate_spec(const MutateSpec& val);

  void __set_cells(const std::vector<CellAsArray> & val);

  bool operator == (const ClientService_shared_mutator_set_cells_as_arrays_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(mutate_spec == rhs.mutate_spec))
      return false;
    if (!(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const ClientService_shared_mutator_set_cells_as_arrays_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_shared_mutator_set_cells_as_arrays_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_shared_mutator_set_cells_as_arrays_pargs {
 public:


  virtual ~ClientService_shared_mutator_set_cells_as_arrays_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const MutateSpec* mutate_spec;
  const std::vector<CellAsArray> * cells;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_shared_mutator_set_cells_as_arrays_result__isset {
  _ClientService_shared_mutator_set_cells_as_arrays_result__isset() : e(false) {}
  bool e :1;
} _ClientService_shared_mutator_set_cells_as_arrays_result__isset;

class ClientService_shared_mutator_set_cells_as_arrays_result {
 public:

  ClientService_shared_mutator_set_cells_as_arrays_result(const ClientService_shared_mutator_set_cells_as_arrays_result&);
  ClientService_shared_mutator_set_cells_as_arrays_result& operator=(const ClientService_shared_mutator_set_cells_as_arrays_result&);
  ClientService_shared_mutator_set_cells_as_arrays_result() {
  }

  virtual ~ClientService_shared_mutator_set_cells_as_arrays_result() throw();
  ClientException e;

  _ClientService_shared_mutator_set_cells_as_arrays_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_shared_mutator_set_cells_as_arrays_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_shared_mutator_set_cells_as_arrays_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_shared_mutator_set_cells_as_arrays_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_shared_mutator_set_cells_as_arrays_presult__isset {
  _ClientService_shared_mutator_set_cells_as_arrays_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_shared_mutator_set_cells_as_arrays_presult__isset;

class ClientService_shared_mutator_set_cells_as_arrays_presult {
 public:


  virtual ~ClientService_shared_mutator_set_cells_as_arrays_presult() throw();
  ClientException e;

  _ClientService_shared_mutator_set_cells_as_arrays_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_offer_cells_as_arrays_args__isset {
  _ClientService_offer_cells_as_arrays_args__isset() : ns(false), table_name(false), mutate_spec(false), cells(false) {}
  bool ns :1;
  bool table_name :1;
  bool mutate_spec :1;
  bool cells :1;
} _ClientService_offer_cells_as_arrays_args__isset;

class ClientService_offer_cells_as_arrays_args {
 public:

  ClientService_offer_cells_as_arrays_args(const ClientService_offer_cells_as_arrays_args&);
  ClientService_offer_cells_as_arrays_args& operator=(const ClientService_offer_cells_as_arrays_args&);
  ClientService_offer_cells_as_arrays_args() : ns(0), table_name() {
  }

  virtual ~ClientService_offer_cells_as_arrays_args() throw();
  Namespace ns;
  std::string table_name;
  MutateSpec mutate_spec;
  std::vector<CellAsArray>  cells;

  _ClientService_offer_cells_as_arrays_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_mutate_spec(const MutateSpec& val);

  void __set_cells(const std::vector<CellAsArray> & val);

  bool operator == (const ClientService_offer_cells_as_arrays_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(mutate_spec == rhs.mutate_spec))
      return false;
    if (!(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const ClientService_offer_cells_as_arrays_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_offer_cells_as_arrays_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_offer_cells_as_arrays_pargs {
 public:


  virtual ~ClientService_offer_cells_as_arrays_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const MutateSpec* mutate_spec;
  const std::vector<CellAsArray> * cells;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_offer_cells_as_arrays_result__isset {
  _ClientService_offer_cells_as_arrays_result__isset() : e(false) {}
  bool e :1;
} _ClientService_offer_cells_as_arrays_result__isset;

class ClientService_offer_cells_as_arrays_result {
 public:

  ClientService_offer_cells_as_arrays_result(const ClientService_offer_cells_as_arrays_result&);
  ClientService_offer_cells_as_arrays_result& operator=(const ClientService_offer_cells_as_arrays_result&);
  ClientService_offer_cells_as_arrays_result() {
  }

  virtual ~ClientService_offer_cells_as_arrays_result() throw();
  ClientException e;

  _ClientService_offer_cells_as_arrays_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_offer_cells_as_arrays_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_offer_cells_as_arrays_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_offer_cells_as_arrays_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_offer_cells_as_arrays_presult__isset {
  _ClientService_offer_cells_as_arrays_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_offer_cells_as_arrays_presult__isset;

class ClientService_offer_cells_as_arrays_presult {
 public:


  virtual ~ClientService_offer_cells_as_arrays_presult() throw();
  ClientException e;

  _ClientService_offer_cells_as_arrays_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_shared_mutator_set_cell_args__isset {
  _ClientService_shared_mutator_set_cell_args__isset() : ns(false), table_name(false), mutate_spec(false), cell(false) {}
  bool ns :1;
  bool table_name :1;
  bool mutate_spec :1;
  bool cell :1;
} _ClientService_shared_mutator_set_cell_args__isset;

class ClientService_shared_mutator_set_cell_args {
 public:

  ClientService_shared_mutator_set_cell_args(const ClientService_shared_mutator_set_cell_args&);
  ClientService_shared_mutator_set_cell_args& operator=(const ClientService_shared_mutator_set_cell_args&);
  ClientService_shared_mutator_set_cell_args() : ns(0), table_name() {
  }

  virtual ~ClientService_shared_mutator_set_cell_args() throw();
  Namespace ns;
  std::string table_name;
  MutateSpec mutate_spec;
  Cell cell;

  _ClientService_shared_mutator_set_cell_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_mutate_spec(const MutateSpec& val);

  void __set_cell(const Cell& val);

  bool operator == (const ClientService_shared_mutator_set_cell_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(mutate_spec == rhs.mutate_spec))
      return false;
    if (!(cell == rhs.cell))
      return false;
    return true;
  }
  bool operator != (const ClientService_shared_mutator_set_cell_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_shared_mutator_set_cell_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_shared_mutator_set_cell_pargs {
 public:


  virtual ~ClientService_shared_mutator_set_cell_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const MutateSpec* mutate_spec;
  const Cell* cell;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_shared_mutator_set_cell_result__isset {
  _ClientService_shared_mutator_set_cell_result__isset() : e(false) {}
  bool e :1;
} _ClientService_shared_mutator_set_cell_result__isset;

class ClientService_shared_mutator_set_cell_result {
 public:

  ClientService_shared_mutator_set_cell_result(const ClientService_shared_mutator_set_cell_result&);
  ClientService_shared_mutator_set_cell_result& operator=(const ClientService_shared_mutator_set_cell_result&);
  ClientService_shared_mutator_set_cell_result() {
  }

  virtual ~ClientService_shared_mutator_set_cell_result() throw();
  ClientException e;

  _ClientService_shared_mutator_set_cell_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_shared_mutator_set_cell_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_shared_mutator_set_cell_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_shared_mutator_set_cell_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_shared_mutator_set_cell_presult__isset {
  _ClientService_shared_mutator_set_cell_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_shared_mutator_set_cell_presult__isset;

class ClientService_shared_mutator_set_cell_presult {
 public:


  virtual ~ClientService_shared_mutator_set_cell_presult() throw();
  ClientException e;

  _ClientService_shared_mutator_set_cell_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_offer_cell_args__isset {
  _ClientService_offer_cell_args__isset() : ns(false), table_name(false), mutate_spec(false), cell(false) {}
  bool ns :1;
  bool table_name :1;
  bool mutate_spec :1;
  bool cell :1;
} _ClientService_offer_cell_args__isset;

class ClientService_offer_cell_args {
 public:

  ClientService_offer_cell_args(const ClientService_offer_cell_args&);
  ClientService_offer_cell_args& operator=(const ClientService_offer_cell_args&);
  ClientService_offer_cell_args() : ns(0), table_name() {
  }

  virtual ~ClientService_offer_cell_args() throw();
  Namespace ns;
  std::string table_name;
  MutateSpec mutate_spec;
  Cell cell;

  _ClientService_offer_cell_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_mutate_spec(const MutateSpec& val);

  void __set_cell(const Cell& val);

  bool operator == (const ClientService_offer_cell_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(mutate_spec == rhs.mutate_spec))
      return false;
    if (!(cell == rhs.cell))
      return false;
    return true;
  }
  bool operator != (const ClientService_offer_cell_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_offer_cell_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_offer_cell_pargs {
 public:


  virtual ~ClientService_offer_cell_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const MutateSpec* mutate_spec;
  const Cell* cell;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_offer_cell_result__isset {
  _ClientService_offer_cell_result__isset() : e(false) {}
  bool e :1;
} _ClientService_offer_cell_result__isset;

class ClientService_offer_cell_result {
 public:

  ClientService_offer_cell_result(const ClientService_offer_cell_result&);
  ClientService_offer_cell_result& operator=(const ClientService_offer_cell_result&);
  ClientService_offer_cell_result() {
  }

  virtual ~ClientService_offer_cell_result() throw();
  ClientException e;

  _ClientService_offer_cell_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_offer_cell_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_offer_cell_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_offer_cell_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_offer_cell_presult__isset {
  _ClientService_offer_cell_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_offer_cell_presult__isset;

class ClientService_offer_cell_presult {
 public:


  virtual ~ClientService_offer_cell_presult() throw();
  ClientException e;

  _ClientService_offer_cell_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_shared_mutator_set_cell_as_array_args__isset {
  _ClientService_shared_mutator_set_cell_as_array_args__isset() : ns(false), table_name(false), mutate_spec(false), cell(false) {}
  bool ns :1;
  bool table_name :1;
  bool mutate_spec :1;
  bool cell :1;
} _ClientService_shared_mutator_set_cell_as_array_args__isset;

class ClientService_shared_mutator_set_cell_as_array_args {
 public:

  ClientService_shared_mutator_set_cell_as_array_args(const ClientService_shared_mutator_set_cell_as_array_args&);
  ClientService_shared_mutator_set_cell_as_array_args& operator=(const ClientService_shared_mutator_set_cell_as_array_args&);
  ClientService_shared_mutator_set_cell_as_array_args() : ns(0), table_name() {
  }

  virtual ~ClientService_shared_mutator_set_cell_as_array_args() throw();
  Namespace ns;
  std::string table_name;
  MutateSpec mutate_spec;
  CellAsArray cell;

  _ClientService_shared_mutator_set_cell_as_array_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_mutate_spec(const MutateSpec& val);

  void __set_cell(const CellAsArray& val);

  bool operator == (const ClientService_shared_mutator_set_cell_as_array_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(mutate_spec == rhs.mutate_spec))
      return false;
    if (!(cell == rhs.cell))
      return false;
    return true;
  }
  bool operator != (const ClientService_shared_mutator_set_cell_as_array_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_shared_mutator_set_cell_as_array_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_shared_mutator_set_cell_as_array_pargs {
 public:


  virtual ~ClientService_shared_mutator_set_cell_as_array_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const MutateSpec* mutate_spec;
  const CellAsArray* cell;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_shared_mutator_set_cell_as_array_result__isset {
  _ClientService_shared_mutator_set_cell_as_array_result__isset() : e(false) {}
  bool e :1;
} _ClientService_shared_mutator_set_cell_as_array_result__isset;

class ClientService_shared_mutator_set_cell_as_array_result {
 public:

  ClientService_shared_mutator_set_cell_as_array_result(const ClientService_shared_mutator_set_cell_as_array_result&);
  ClientService_shared_mutator_set_cell_as_array_result& operator=(const ClientService_shared_mutator_set_cell_as_array_result&);
  ClientService_shared_mutator_set_cell_as_array_result() {
  }

  virtual ~ClientService_shared_mutator_set_cell_as_array_result() throw();
  ClientException e;

  _ClientService_shared_mutator_set_cell_as_array_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_shared_mutator_set_cell_as_array_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_shared_mutator_set_cell_as_array_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_shared_mutator_set_cell_as_array_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_shared_mutator_set_cell_as_array_presult__isset {
  _ClientService_shared_mutator_set_cell_as_array_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_shared_mutator_set_cell_as_array_presult__isset;

class ClientService_shared_mutator_set_cell_as_array_presult {
 public:


  virtual ~ClientService_shared_mutator_set_cell_as_array_presult() throw();
  ClientException e;

  _ClientService_shared_mutator_set_cell_as_array_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_offer_cell_as_array_args__isset {
  _ClientService_offer_cell_as_array_args__isset() : ns(false), table_name(false), mutate_spec(false), cell(false) {}
  bool ns :1;
  bool table_name :1;
  bool mutate_spec :1;
  bool cell :1;
} _ClientService_offer_cell_as_array_args__isset;

class ClientService_offer_cell_as_array_args {
 public:

  ClientService_offer_cell_as_array_args(const ClientService_offer_cell_as_array_args&);
  ClientService_offer_cell_as_array_args& operator=(const ClientService_offer_cell_as_array_args&);
  ClientService_offer_cell_as_array_args() : ns(0), table_name() {
  }

  virtual ~ClientService_offer_cell_as_array_args() throw();
  Namespace ns;
  std::string table_name;
  MutateSpec mutate_spec;
  CellAsArray cell;

  _ClientService_offer_cell_as_array_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_mutate_spec(const MutateSpec& val);

  void __set_cell(const CellAsArray& val);

  bool operator == (const ClientService_offer_cell_as_array_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(mutate_spec == rhs.mutate_spec))
      return false;
    if (!(cell == rhs.cell))
      return false;
    return true;
  }
  bool operator != (const ClientService_offer_cell_as_array_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_offer_cell_as_array_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_offer_cell_as_array_pargs {
 public:


  virtual ~ClientService_offer_cell_as_array_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const MutateSpec* mutate_spec;
  const CellAsArray* cell;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_offer_cell_as_array_result__isset {
  _ClientService_offer_cell_as_array_result__isset() : e(false) {}
  bool e :1;
} _ClientService_offer_cell_as_array_result__isset;

class ClientService_offer_cell_as_array_result {
 public:

  ClientService_offer_cell_as_array_result(const ClientService_offer_cell_as_array_result&);
  ClientService_offer_cell_as_array_result& operator=(const ClientService_offer_cell_as_array_result&);
  ClientService_offer_cell_as_array_result() {
  }

  virtual ~ClientService_offer_cell_as_array_result() throw();
  ClientException e;

  _ClientService_offer_cell_as_array_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_offer_cell_as_array_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_offer_cell_as_array_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_offer_cell_as_array_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_offer_cell_as_array_presult__isset {
  _ClientService_offer_cell_as_array_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_offer_cell_as_array_presult__isset;

class ClientService_offer_cell_as_array_presult {
 public:


  virtual ~ClientService_offer_cell_as_array_presult() throw();
  ClientException e;

  _ClientService_offer_cell_as_array_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_mutator_open_args__isset {
  _ClientService_mutator_open_args__isset() : ns(false), table_name(false), flags(true), flush_interval(true) {}
  bool ns :1;
  bool table_name :1;
  bool flags :1;
  bool flush_interval :1;
} _ClientService_mutator_open_args__isset;

class ClientService_mutator_open_args {
 public:

  ClientService_mutator_open_args(const ClientService_mutator_open_args&);
  ClientService_mutator_open_args& operator=(const ClientService_mutator_open_args&);
  ClientService_mutator_open_args() : ns(0), table_name(), flags(0), flush_interval(0) {
  }

  virtual ~ClientService_mutator_open_args() throw();
  Namespace ns;
  std::string table_name;
  int32_t flags;
  int32_t flush_interval;

  _ClientService_mutator_open_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_flags(const int32_t val);

  void __set_flush_interval(const int32_t val);

  bool operator == (const ClientService_mutator_open_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(flags == rhs.flags))
      return false;
    if (!(flush_interval == rhs.flush_interval))
      return false;
    return true;
  }
  bool operator != (const ClientService_mutator_open_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_mutator_open_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_mutator_open_pargs {
 public:


  virtual ~ClientService_mutator_open_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const int32_t* flags;
  const int32_t* flush_interval;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_mutator_open_result__isset {
  _ClientService_mutator_open_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_mutator_open_result__isset;

class ClientService_mutator_open_result {
 public:

  ClientService_mutator_open_result(const ClientService_mutator_open_result&);
  ClientService_mutator_open_result& operator=(const ClientService_mutator_open_result&);
  ClientService_mutator_open_result() : success(0) {
  }

  virtual ~ClientService_mutator_open_result() throw();
  Mutator success;
  ClientException e;

  _ClientService_mutator_open_result__isset __isset;

  void __set_success(const Mutator val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_mutator_open_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_mutator_open_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_mutator_open_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_mutator_open_presult__isset {
  _ClientService_mutator_open_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_mutator_open_presult__isset;

class ClientService_mutator_open_presult {
 public:


  virtual ~ClientService_mutator_open_presult() throw();
  Mutator* success;
  ClientException e;

  _ClientService_mutator_open_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_open_mutator_args__isset {
  _ClientService_open_mutator_args__isset() : ns(false), table_name(false), flags(true), flush_interval(true) {}
  bool ns :1;
  bool table_name :1;
  bool flags :1;
  bool flush_interval :1;
} _ClientService_open_mutator_args__isset;

class ClientService_open_mutator_args {
 public:

  ClientService_open_mutator_args(const ClientService_open_mutator_args&);
  ClientService_open_mutator_args& operator=(const ClientService_open_mutator_args&);
  ClientService_open_mutator_args() : ns(0), table_name(), flags(0), flush_interval(0) {
  }

  virtual ~ClientService_open_mutator_args() throw();
  Namespace ns;
  std::string table_name;
  int32_t flags;
  int32_t flush_interval;

  _ClientService_open_mutator_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_flags(const int32_t val);

  void __set_flush_interval(const int32_t val);

  bool operator == (const ClientService_open_mutator_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(flags == rhs.flags))
      return false;
    if (!(flush_interval == rhs.flush_interval))
      return false;
    return true;
  }
  bool operator != (const ClientService_open_mutator_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_open_mutator_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_open_mutator_pargs {
 public:


  virtual ~ClientService_open_mutator_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const int32_t* flags;
  const int32_t* flush_interval;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_open_mutator_result__isset {
  _ClientService_open_mutator_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_open_mutator_result__isset;

class ClientService_open_mutator_result {
 public:

  ClientService_open_mutator_result(const ClientService_open_mutator_result&);
  ClientService_open_mutator_result& operator=(const ClientService_open_mutator_result&);
  ClientService_open_mutator_result() : success(0) {
  }

  virtual ~ClientService_open_mutator_result() throw();
  Mutator success;
  ClientException e;

  _ClientService_open_mutator_result__isset __isset;

  void __set_success(const Mutator val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_open_mutator_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_open_mutator_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_open_mutator_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_open_mutator_presult__isset {
  _ClientService_open_mutator_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_open_mutator_presult__isset;

class ClientService_open_mutator_presult {
 public:


  virtual ~ClientService_open_mutator_presult() throw();
  Mutator* success;
  ClientException e;

  _ClientService_open_mutator_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_async_mutator_open_args__isset {
  _ClientService_async_mutator_open_args__isset() : ns(false), table_name(false), future(false), flags(true) {}
  bool ns :1;
  bool table_name :1;
  bool future :1;
  bool flags :1;
} _ClientService_async_mutator_open_args__isset;

class ClientService_async_mutator_open_args {
 public:

  ClientService_async_mutator_open_args(const ClientService_async_mutator_open_args&);
  ClientService_async_mutator_open_args& operator=(const ClientService_async_mutator_open_args&);
  ClientService_async_mutator_open_args() : ns(0), table_name(), future(0), flags(0) {
  }

  virtual ~ClientService_async_mutator_open_args() throw();
  Namespace ns;
  std::string table_name;
  Future future;
  int32_t flags;

  _ClientService_async_mutator_open_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_future(const Future val);

  void __set_flags(const int32_t val);

  bool operator == (const ClientService_async_mutator_open_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(future == rhs.future))
      return false;
    if (!(flags == rhs.flags))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_mutator_open_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_mutator_open_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_async_mutator_open_pargs {
 public:


  virtual ~ClientService_async_mutator_open_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const Future* future;
  const int32_t* flags;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_mutator_open_result__isset {
  _ClientService_async_mutator_open_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_async_mutator_open_result__isset;

class ClientService_async_mutator_open_result {
 public:

  ClientService_async_mutator_open_result(const ClientService_async_mutator_open_result&);
  ClientService_async_mutator_open_result& operator=(const ClientService_async_mutator_open_result&);
  ClientService_async_mutator_open_result() : success(0) {
  }

  virtual ~ClientService_async_mutator_open_result() throw();
  MutatorAsync success;
  ClientException e;

  _ClientService_async_mutator_open_result__isset __isset;

  void __set_success(const MutatorAsync val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_async_mutator_open_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_mutator_open_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_mutator_open_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_mutator_open_presult__isset {
  _ClientService_async_mutator_open_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_async_mutator_open_presult__isset;

class ClientService_async_mutator_open_presult {
 public:


  virtual ~ClientService_async_mutator_open_presult() throw();
  MutatorAsync* success;
  ClientException e;

  _ClientService_async_mutator_open_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_open_mutator_async_args__isset {
  _ClientService_open_mutator_async_args__isset() : ns(false), table_name(false), future(false), flags(true) {}
  bool ns :1;
  bool table_name :1;
  bool future :1;
  bool flags :1;
} _ClientService_open_mutator_async_args__isset;

class ClientService_open_mutator_async_args {
 public:

  ClientService_open_mutator_async_args(const ClientService_open_mutator_async_args&);
  ClientService_open_mutator_async_args& operator=(const ClientService_open_mutator_async_args&);
  ClientService_open_mutator_async_args() : ns(0), table_name(), future(0), flags(0) {
  }

  virtual ~ClientService_open_mutator_async_args() throw();
  Namespace ns;
  std::string table_name;
  Future future;
  int32_t flags;

  _ClientService_open_mutator_async_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_future(const Future val);

  void __set_flags(const int32_t val);

  bool operator == (const ClientService_open_mutator_async_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(future == rhs.future))
      return false;
    if (!(flags == rhs.flags))
      return false;
    return true;
  }
  bool operator != (const ClientService_open_mutator_async_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_open_mutator_async_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_open_mutator_async_pargs {
 public:


  virtual ~ClientService_open_mutator_async_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const Future* future;
  const int32_t* flags;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_open_mutator_async_result__isset {
  _ClientService_open_mutator_async_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_open_mutator_async_result__isset;

class ClientService_open_mutator_async_result {
 public:

  ClientService_open_mutator_async_result(const ClientService_open_mutator_async_result&);
  ClientService_open_mutator_async_result& operator=(const ClientService_open_mutator_async_result&);
  ClientService_open_mutator_async_result() : success(0) {
  }

  virtual ~ClientService_open_mutator_async_result() throw();
  MutatorAsync success;
  ClientException e;

  _ClientService_open_mutator_async_result__isset __isset;

  void __set_success(const MutatorAsync val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_open_mutator_async_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_open_mutator_async_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_open_mutator_async_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_open_mutator_async_presult__isset {
  _ClientService_open_mutator_async_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_open_mutator_async_presult__isset;

class ClientService_open_mutator_async_presult {
 public:


  virtual ~ClientService_open_mutator_async_presult() throw();
  MutatorAsync* success;
  ClientException e;

  _ClientService_open_mutator_async_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_mutator_close_args__isset {
  _ClientService_mutator_close_args__isset() : mutator(false) {}
  bool mutator :1;
} _ClientService_mutator_close_args__isset;

class ClientService_mutator_close_args {
 public:

  ClientService_mutator_close_args(const ClientService_mutator_close_args&);
  ClientService_mutator_close_args& operator=(const ClientService_mutator_close_args&);
  ClientService_mutator_close_args() : mutator(0) {
  }

  virtual ~ClientService_mutator_close_args() throw();
  Mutator mutator;

  _ClientService_mutator_close_args__isset __isset;

  void __set_mutator(const Mutator val);

  bool operator == (const ClientService_mutator_close_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    return true;
  }
  bool operator != (const ClientService_mutator_close_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_mutator_close_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_mutator_close_pargs {
 public:


  virtual ~ClientService_mutator_close_pargs() throw();
  const Mutator* mutator;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_mutator_close_result__isset {
  _ClientService_mutator_close_result__isset() : e(false) {}
  bool e :1;
} _ClientService_mutator_close_result__isset;

class ClientService_mutator_close_result {
 public:

  ClientService_mutator_close_result(const ClientService_mutator_close_result&);
  ClientService_mutator_close_result& operator=(const ClientService_mutator_close_result&);
  ClientService_mutator_close_result() {
  }

  virtual ~ClientService_mutator_close_result() throw();
  ClientException e;

  _ClientService_mutator_close_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_mutator_close_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_mutator_close_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_mutator_close_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_mutator_close_presult__isset {
  _ClientService_mutator_close_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_mutator_close_presult__isset;

class ClientService_mutator_close_presult {
 public:


  virtual ~ClientService_mutator_close_presult() throw();
  ClientException e;

  _ClientService_mutator_close_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_close_mutator_args__isset {
  _ClientService_close_mutator_args__isset() : mutator(false) {}
  bool mutator :1;
} _ClientService_close_mutator_args__isset;

class ClientService_close_mutator_args {
 public:

  ClientService_close_mutator_args(const ClientService_close_mutator_args&);
  ClientService_close_mutator_args& operator=(const ClientService_close_mutator_args&);
  ClientService_close_mutator_args() : mutator(0) {
  }

  virtual ~ClientService_close_mutator_args() throw();
  Mutator mutator;

  _ClientService_close_mutator_args__isset __isset;

  void __set_mutator(const Mutator val);

  bool operator == (const ClientService_close_mutator_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    return true;
  }
  bool operator != (const ClientService_close_mutator_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_close_mutator_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_close_mutator_pargs {
 public:


  virtual ~ClientService_close_mutator_pargs() throw();
  const Mutator* mutator;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_close_mutator_result__isset {
  _ClientService_close_mutator_result__isset() : e(false) {}
  bool e :1;
} _ClientService_close_mutator_result__isset;

class ClientService_close_mutator_result {
 public:

  ClientService_close_mutator_result(const ClientService_close_mutator_result&);
  ClientService_close_mutator_result& operator=(const ClientService_close_mutator_result&);
  ClientService_close_mutator_result() {
  }

  virtual ~ClientService_close_mutator_result() throw();
  ClientException e;

  _ClientService_close_mutator_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_close_mutator_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_close_mutator_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_close_mutator_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_close_mutator_presult__isset {
  _ClientService_close_mutator_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_close_mutator_presult__isset;

class ClientService_close_mutator_presult {
 public:


  virtual ~ClientService_close_mutator_presult() throw();
  ClientException e;

  _ClientService_close_mutator_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_async_mutator_cancel_args__isset {
  _ClientService_async_mutator_cancel_args__isset() : mutator(false) {}
  bool mutator :1;
} _ClientService_async_mutator_cancel_args__isset;

class ClientService_async_mutator_cancel_args {
 public:

  ClientService_async_mutator_cancel_args(const ClientService_async_mutator_cancel_args&);
  ClientService_async_mutator_cancel_args& operator=(const ClientService_async_mutator_cancel_args&);
  ClientService_async_mutator_cancel_args() : mutator(0) {
  }

  virtual ~ClientService_async_mutator_cancel_args() throw();
  MutatorAsync mutator;

  _ClientService_async_mutator_cancel_args__isset __isset;

  void __set_mutator(const MutatorAsync val);

  bool operator == (const ClientService_async_mutator_cancel_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_mutator_cancel_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_mutator_cancel_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_async_mutator_cancel_pargs {
 public:


  virtual ~ClientService_async_mutator_cancel_pargs() throw();
  const MutatorAsync* mutator;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_mutator_cancel_result__isset {
  _ClientService_async_mutator_cancel_result__isset() : e(false) {}
  bool e :1;
} _ClientService_async_mutator_cancel_result__isset;

class ClientService_async_mutator_cancel_result {
 public:

  ClientService_async_mutator_cancel_result(const ClientService_async_mutator_cancel_result&);
  ClientService_async_mutator_cancel_result& operator=(const ClientService_async_mutator_cancel_result&);
  ClientService_async_mutator_cancel_result() {
  }

  virtual ~ClientService_async_mutator_cancel_result() throw();
  ClientException e;

  _ClientService_async_mutator_cancel_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_async_mutator_cancel_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_mutator_cancel_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_mutator_cancel_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_mutator_cancel_presult__isset {
  _ClientService_async_mutator_cancel_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_async_mutator_cancel_presult__isset;

class ClientService_async_mutator_cancel_presult {
 public:


  virtual ~ClientService_async_mutator_cancel_presult() throw();
  ClientException e;

  _ClientService_async_mutator_cancel_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_cancel_mutator_async_args__isset {
  _ClientService_cancel_mutator_async_args__isset() : mutator(false) {}
  bool mutator :1;
} _ClientService_cancel_mutator_async_args__isset;

class ClientService_cancel_mutator_async_args {
 public:

  ClientService_cancel_mutator_async_args(const ClientService_cancel_mutator_async_args&);
  ClientService_cancel_mutator_async_args& operator=(const ClientService_cancel_mutator_async_args&);
  ClientService_cancel_mutator_async_args() : mutator(0) {
  }

  virtual ~ClientService_cancel_mutator_async_args() throw();
  MutatorAsync mutator;

  _ClientService_cancel_mutator_async_args__isset __isset;

  void __set_mutator(const MutatorAsync val);

  bool operator == (const ClientService_cancel_mutator_async_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    return true;
  }
  bool operator != (const ClientService_cancel_mutator_async_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_cancel_mutator_async_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_cancel_mutator_async_pargs {
 public:


  virtual ~ClientService_cancel_mutator_async_pargs() throw();
  const MutatorAsync* mutator;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_cancel_mutator_async_result__isset {
  _ClientService_cancel_mutator_async_result__isset() : e(false) {}
  bool e :1;
} _ClientService_cancel_mutator_async_result__isset;

class ClientService_cancel_mutator_async_result {
 public:

  ClientService_cancel_mutator_async_result(const ClientService_cancel_mutator_async_result&);
  ClientService_cancel_mutator_async_result& operator=(const ClientService_cancel_mutator_async_result&);
  ClientService_cancel_mutator_async_result() {
  }

  virtual ~ClientService_cancel_mutator_async_result() throw();
  ClientException e;

  _ClientService_cancel_mutator_async_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_cancel_mutator_async_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_cancel_mutator_async_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_cancel_mutator_async_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_cancel_mutator_async_presult__isset {
  _ClientService_cancel_mutator_async_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_cancel_mutator_async_presult__isset;

class ClientService_cancel_mutator_async_presult {
 public:


  virtual ~ClientService_cancel_mutator_async_presult() throw();
  ClientException e;

  _ClientService_cancel_mutator_async_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_async_mutator_close_args__isset {
  _ClientService_async_mutator_close_args__isset() : mutator(false) {}
  bool mutator :1;
} _ClientService_async_mutator_close_args__isset;

class ClientService_async_mutator_close_args {
 public:

  ClientService_async_mutator_close_args(const ClientService_async_mutator_close_args&);
  ClientService_async_mutator_close_args& operator=(const ClientService_async_mutator_close_args&);
  ClientService_async_mutator_close_args() : mutator(0) {
  }

  virtual ~ClientService_async_mutator_close_args() throw();
  MutatorAsync mutator;

  _ClientService_async_mutator_close_args__isset __isset;

  void __set_mutator(const MutatorAsync val);

  bool operator == (const ClientService_async_mutator_close_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_mutator_close_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_mutator_close_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_async_mutator_close_pargs {
 public:


  virtual ~ClientService_async_mutator_close_pargs() throw();
  const MutatorAsync* mutator;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_mutator_close_result__isset {
  _ClientService_async_mutator_close_result__isset() : e(false) {}
  bool e :1;
} _ClientService_async_mutator_close_result__isset;

class ClientService_async_mutator_close_result {
 public:

  ClientService_async_mutator_close_result(const ClientService_async_mutator_close_result&);
  ClientService_async_mutator_close_result& operator=(const ClientService_async_mutator_close_result&);
  ClientService_async_mutator_close_result() {
  }

  virtual ~ClientService_async_mutator_close_result() throw();
  ClientException e;

  _ClientService_async_mutator_close_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_async_mutator_close_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_mutator_close_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_mutator_close_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_mutator_close_presult__isset {
  _ClientService_async_mutator_close_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_async_mutator_close_presult__isset;

class ClientService_async_mutator_close_presult {
 public:


  virtual ~ClientService_async_mutator_close_presult() throw();
  ClientException e;

  _ClientService_async_mutator_close_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_close_mutator_async_args__isset {
  _ClientService_close_mutator_async_args__isset() : mutator(false) {}
  bool mutator :1;
} _ClientService_close_mutator_async_args__isset;

class ClientService_close_mutator_async_args {
 public:

  ClientService_close_mutator_async_args(const ClientService_close_mutator_async_args&);
  ClientService_close_mutator_async_args& operator=(const ClientService_close_mutator_async_args&);
  ClientService_close_mutator_async_args() : mutator(0) {
  }

  virtual ~ClientService_close_mutator_async_args() throw();
  MutatorAsync mutator;

  _ClientService_close_mutator_async_args__isset __isset;

  void __set_mutator(const MutatorAsync val);

  bool operator == (const ClientService_close_mutator_async_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    return true;
  }
  bool operator != (const ClientService_close_mutator_async_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_close_mutator_async_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_close_mutator_async_pargs {
 public:


  virtual ~ClientService_close_mutator_async_pargs() throw();
  const MutatorAsync* mutator;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_close_mutator_async_result__isset {
  _ClientService_close_mutator_async_result__isset() : e(false) {}
  bool e :1;
} _ClientService_close_mutator_async_result__isset;

class ClientService_close_mutator_async_result {
 public:

  ClientService_close_mutator_async_result(const ClientService_close_mutator_async_result&);
  ClientService_close_mutator_async_result& operator=(const ClientService_close_mutator_async_result&);
  ClientService_close_mutator_async_result() {
  }

  virtual ~ClientService_close_mutator_async_result() throw();
  ClientException e;

  _ClientService_close_mutator_async_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_close_mutator_async_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_close_mutator_async_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_close_mutator_async_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_close_mutator_async_presult__isset {
  _ClientService_close_mutator_async_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_close_mutator_async_presult__isset;

class ClientService_close_mutator_async_presult {
 public:


  virtual ~ClientService_close_mutator_async_presult() throw();
  ClientException e;

  _ClientService_close_mutator_async_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_mutator_set_cell_args__isset {
  _ClientService_mutator_set_cell_args__isset() : mutator(false), cell(false) {}
  bool mutator :1;
  bool cell :1;
} _ClientService_mutator_set_cell_args__isset;

class ClientService_mutator_set_cell_args {
 public:

  ClientService_mutator_set_cell_args(const ClientService_mutator_set_cell_args&);
  ClientService_mutator_set_cell_args& operator=(const ClientService_mutator_set_cell_args&);
  ClientService_mutator_set_cell_args() : mutator(0) {
  }

  virtual ~ClientService_mutator_set_cell_args() throw();
  Mutator mutator;
  Cell cell;

  _ClientService_mutator_set_cell_args__isset __isset;

  void __set_mutator(const Mutator val);

  void __set_cell(const Cell& val);

  bool operator == (const ClientService_mutator_set_cell_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    if (!(cell == rhs.cell))
      return false;
    return true;
  }
  bool operator != (const ClientService_mutator_set_cell_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_mutator_set_cell_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_mutator_set_cell_pargs {
 public:


  virtual ~ClientService_mutator_set_cell_pargs() throw();
  const Mutator* mutator;
  const Cell* cell;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_mutator_set_cell_result__isset {
  _ClientService_mutator_set_cell_result__isset() : e(false) {}
  bool e :1;
} _ClientService_mutator_set_cell_result__isset;

class ClientService_mutator_set_cell_result {
 public:

  ClientService_mutator_set_cell_result(const ClientService_mutator_set_cell_result&);
  ClientService_mutator_set_cell_result& operator=(const ClientService_mutator_set_cell_result&);
  ClientService_mutator_set_cell_result() {
  }

  virtual ~ClientService_mutator_set_cell_result() throw();
  ClientException e;

  _ClientService_mutator_set_cell_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_mutator_set_cell_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_mutator_set_cell_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_mutator_set_cell_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_mutator_set_cell_presult__isset {
  _ClientService_mutator_set_cell_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_mutator_set_cell_presult__isset;

class ClientService_mutator_set_cell_presult {
 public:


  virtual ~ClientService_mutator_set_cell_presult() throw();
  ClientException e;

  _ClientService_mutator_set_cell_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_set_cell_args__isset {
  _ClientService_set_cell_args__isset() : ns(false), table_name(false), cell(false) {}
  bool ns :1;
  bool table_name :1;
  bool cell :1;
} _ClientService_set_cell_args__isset;

class ClientService_set_cell_args {
 public:

  ClientService_set_cell_args(const ClientService_set_cell_args&);
  ClientService_set_cell_args& operator=(const ClientService_set_cell_args&);
  ClientService_set_cell_args() : ns(0), table_name() {
  }

  virtual ~ClientService_set_cell_args() throw();
  Namespace ns;
  std::string table_name;
  Cell cell;

  _ClientService_set_cell_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_cell(const Cell& val);

  bool operator == (const ClientService_set_cell_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(cell == rhs.cell))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cell_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cell_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_set_cell_pargs {
 public:


  virtual ~ClientService_set_cell_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const Cell* cell;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cell_result__isset {
  _ClientService_set_cell_result__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cell_result__isset;

class ClientService_set_cell_result {
 public:

  ClientService_set_cell_result(const ClientService_set_cell_result&);
  ClientService_set_cell_result& operator=(const ClientService_set_cell_result&);
  ClientService_set_cell_result() {
  }

  virtual ~ClientService_set_cell_result() throw();
  ClientException e;

  _ClientService_set_cell_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_set_cell_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cell_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cell_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cell_presult__isset {
  _ClientService_set_cell_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cell_presult__isset;

class ClientService_set_cell_presult {
 public:


  virtual ~ClientService_set_cell_presult() throw();
  ClientException e;

  _ClientService_set_cell_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_mutator_set_cell_as_array_args__isset {
  _ClientService_mutator_set_cell_as_array_args__isset() : mutator(false), cell(false) {}
  bool mutator :1;
  bool cell :1;
} _ClientService_mutator_set_cell_as_array_args__isset;

class ClientService_mutator_set_cell_as_array_args {
 public:

  ClientService_mutator_set_cell_as_array_args(const ClientService_mutator_set_cell_as_array_args&);
  ClientService_mutator_set_cell_as_array_args& operator=(const ClientService_mutator_set_cell_as_array_args&);
  ClientService_mutator_set_cell_as_array_args() : mutator(0) {
  }

  virtual ~ClientService_mutator_set_cell_as_array_args() throw();
  Mutator mutator;
  CellAsArray cell;

  _ClientService_mutator_set_cell_as_array_args__isset __isset;

  void __set_mutator(const Mutator val);

  void __set_cell(const CellAsArray& val);

  bool operator == (const ClientService_mutator_set_cell_as_array_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    if (!(cell == rhs.cell))
      return false;
    return true;
  }
  bool operator != (const ClientService_mutator_set_cell_as_array_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_mutator_set_cell_as_array_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_mutator_set_cell_as_array_pargs {
 public:


  virtual ~ClientService_mutator_set_cell_as_array_pargs() throw();
  const Mutator* mutator;
  const CellAsArray* cell;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_mutator_set_cell_as_array_result__isset {
  _ClientService_mutator_set_cell_as_array_result__isset() : e(false) {}
  bool e :1;
} _ClientService_mutator_set_cell_as_array_result__isset;

class ClientService_mutator_set_cell_as_array_result {
 public:

  ClientService_mutator_set_cell_as_array_result(const ClientService_mutator_set_cell_as_array_result&);
  ClientService_mutator_set_cell_as_array_result& operator=(const ClientService_mutator_set_cell_as_array_result&);
  ClientService_mutator_set_cell_as_array_result() {
  }

  virtual ~ClientService_mutator_set_cell_as_array_result() throw();
  ClientException e;

  _ClientService_mutator_set_cell_as_array_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_mutator_set_cell_as_array_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_mutator_set_cell_as_array_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_mutator_set_cell_as_array_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_mutator_set_cell_as_array_presult__isset {
  _ClientService_mutator_set_cell_as_array_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_mutator_set_cell_as_array_presult__isset;

class ClientService_mutator_set_cell_as_array_presult {
 public:


  virtual ~ClientService_mutator_set_cell_as_array_presult() throw();
  ClientException e;

  _ClientService_mutator_set_cell_as_array_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_set_cell_as_array_args__isset {
  _ClientService_set_cell_as_array_args__isset() : ns(false), table_name(false), cell(false) {}
  bool ns :1;
  bool table_name :1;
  bool cell :1;
} _ClientService_set_cell_as_array_args__isset;

class ClientService_set_cell_as_array_args {
 public:

  ClientService_set_cell_as_array_args(const ClientService_set_cell_as_array_args&);
  ClientService_set_cell_as_array_args& operator=(const ClientService_set_cell_as_array_args&);
  ClientService_set_cell_as_array_args() : ns(0), table_name() {
  }

  virtual ~ClientService_set_cell_as_array_args() throw();
  Namespace ns;
  std::string table_name;
  CellAsArray cell;

  _ClientService_set_cell_as_array_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_cell(const CellAsArray& val);

  bool operator == (const ClientService_set_cell_as_array_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(cell == rhs.cell))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cell_as_array_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cell_as_array_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_set_cell_as_array_pargs {
 public:


  virtual ~ClientService_set_cell_as_array_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const CellAsArray* cell;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cell_as_array_result__isset {
  _ClientService_set_cell_as_array_result__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cell_as_array_result__isset;

class ClientService_set_cell_as_array_result {
 public:

  ClientService_set_cell_as_array_result(const ClientService_set_cell_as_array_result&);
  ClientService_set_cell_as_array_result& operator=(const ClientService_set_cell_as_array_result&);
  ClientService_set_cell_as_array_result() {
  }

  virtual ~ClientService_set_cell_as_array_result() throw();
  ClientException e;

  _ClientService_set_cell_as_array_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_set_cell_as_array_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cell_as_array_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cell_as_array_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cell_as_array_presult__isset {
  _ClientService_set_cell_as_array_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cell_as_array_presult__isset;

class ClientService_set_cell_as_array_presult {
 public:


  virtual ~ClientService_set_cell_as_array_presult() throw();
  ClientException e;

  _ClientService_set_cell_as_array_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_mutator_set_cells_args__isset {
  _ClientService_mutator_set_cells_args__isset() : mutator(false), cells(false) {}
  bool mutator :1;
  bool cells :1;
} _ClientService_mutator_set_cells_args__isset;

class ClientService_mutator_set_cells_args {
 public:

  ClientService_mutator_set_cells_args(const ClientService_mutator_set_cells_args&);
  ClientService_mutator_set_cells_args& operator=(const ClientService_mutator_set_cells_args&);
  ClientService_mutator_set_cells_args() : mutator(0) {
  }

  virtual ~ClientService_mutator_set_cells_args() throw();
  Mutator mutator;
  std::vector<Cell>  cells;

  _ClientService_mutator_set_cells_args__isset __isset;

  void __set_mutator(const Mutator val);

  void __set_cells(const std::vector<Cell> & val);

  bool operator == (const ClientService_mutator_set_cells_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    if (!(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const ClientService_mutator_set_cells_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_mutator_set_cells_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_mutator_set_cells_pargs {
 public:


  virtual ~ClientService_mutator_set_cells_pargs() throw();
  const Mutator* mutator;
  const std::vector<Cell> * cells;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_mutator_set_cells_result__isset {
  _ClientService_mutator_set_cells_result__isset() : e(false) {}
  bool e :1;
} _ClientService_mutator_set_cells_result__isset;

class ClientService_mutator_set_cells_result {
 public:

  ClientService_mutator_set_cells_result(const ClientService_mutator_set_cells_result&);
  ClientService_mutator_set_cells_result& operator=(const ClientService_mutator_set_cells_result&);
  ClientService_mutator_set_cells_result() {
  }

  virtual ~ClientService_mutator_set_cells_result() throw();
  ClientException e;

  _ClientService_mutator_set_cells_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_mutator_set_cells_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_mutator_set_cells_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_mutator_set_cells_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_mutator_set_cells_presult__isset {
  _ClientService_mutator_set_cells_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_mutator_set_cells_presult__isset;

class ClientService_mutator_set_cells_presult {
 public:


  virtual ~ClientService_mutator_set_cells_presult() throw();
  ClientException e;

  _ClientService_mutator_set_cells_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_set_cells_args__isset {
  _ClientService_set_cells_args__isset() : ns(false), table_name(false), cells(false) {}
  bool ns :1;
  bool table_name :1;
  bool cells :1;
} _ClientService_set_cells_args__isset;

class ClientService_set_cells_args {
 public:

  ClientService_set_cells_args(const ClientService_set_cells_args&);
  ClientService_set_cells_args& operator=(const ClientService_set_cells_args&);
  ClientService_set_cells_args() : ns(0), table_name() {
  }

  virtual ~ClientService_set_cells_args() throw();
  Namespace ns;
  std::string table_name;
  std::vector<Cell>  cells;

  _ClientService_set_cells_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_cells(const std::vector<Cell> & val);

  bool operator == (const ClientService_set_cells_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cells_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cells_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_set_cells_pargs {
 public:


  virtual ~ClientService_set_cells_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const std::vector<Cell> * cells;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cells_result__isset {
  _ClientService_set_cells_result__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cells_result__isset;

class ClientService_set_cells_result {
 public:

  ClientService_set_cells_result(const ClientService_set_cells_result&);
  ClientService_set_cells_result& operator=(const ClientService_set_cells_result&);
  ClientService_set_cells_result() {
  }

  virtual ~ClientService_set_cells_result() throw();
  ClientException e;

  _ClientService_set_cells_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_set_cells_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cells_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cells_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cells_presult__isset {
  _ClientService_set_cells_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cells_presult__isset;

class ClientService_set_cells_presult {
 public:


  virtual ~ClientService_set_cells_presult() throw();
  ClientException e;

  _ClientService_set_cells_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_mutator_set_cells_as_arrays_args__isset {
  _ClientService_mutator_set_cells_as_arrays_args__isset() : mutator(false), cells(false) {}
  bool mutator :1;
  bool cells :1;
} _ClientService_mutator_set_cells_as_arrays_args__isset;

class ClientService_mutator_set_cells_as_arrays_args {
 public:

  ClientService_mutator_set_cells_as_arrays_args(const ClientService_mutator_set_cells_as_arrays_args&);
  ClientService_mutator_set_cells_as_arrays_args& operator=(const ClientService_mutator_set_cells_as_arrays_args&);
  ClientService_mutator_set_cells_as_arrays_args() : mutator(0) {
  }

  virtual ~ClientService_mutator_set_cells_as_arrays_args() throw();
  Mutator mutator;
  std::vector<CellAsArray>  cells;

  _ClientService_mutator_set_cells_as_arrays_args__isset __isset;

  void __set_mutator(const Mutator val);

  void __set_cells(const std::vector<CellAsArray> & val);

  bool operator == (const ClientService_mutator_set_cells_as_arrays_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    if (!(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const ClientService_mutator_set_cells_as_arrays_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_mutator_set_cells_as_arrays_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_mutator_set_cells_as_arrays_pargs {
 public:


  virtual ~ClientService_mutator_set_cells_as_arrays_pargs() throw();
  const Mutator* mutator;
  const std::vector<CellAsArray> * cells;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_mutator_set_cells_as_arrays_result__isset {
  _ClientService_mutator_set_cells_as_arrays_result__isset() : e(false) {}
  bool e :1;
} _ClientService_mutator_set_cells_as_arrays_result__isset;

class ClientService_mutator_set_cells_as_arrays_result {
 public:

  ClientService_mutator_set_cells_as_arrays_result(const ClientService_mutator_set_cells_as_arrays_result&);
  ClientService_mutator_set_cells_as_arrays_result& operator=(const ClientService_mutator_set_cells_as_arrays_result&);
  ClientService_mutator_set_cells_as_arrays_result() {
  }

  virtual ~ClientService_mutator_set_cells_as_arrays_result() throw();
  ClientException e;

  _ClientService_mutator_set_cells_as_arrays_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_mutator_set_cells_as_arrays_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_mutator_set_cells_as_arrays_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_mutator_set_cells_as_arrays_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_mutator_set_cells_as_arrays_presult__isset {
  _ClientService_mutator_set_cells_as_arrays_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_mutator_set_cells_as_arrays_presult__isset;

class ClientService_mutator_set_cells_as_arrays_presult {
 public:


  virtual ~ClientService_mutator_set_cells_as_arrays_presult() throw();
  ClientException e;

  _ClientService_mutator_set_cells_as_arrays_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_set_cells_as_arrays_args__isset {
  _ClientService_set_cells_as_arrays_args__isset() : ns(false), table_name(false), cells(false) {}
  bool ns :1;
  bool table_name :1;
  bool cells :1;
} _ClientService_set_cells_as_arrays_args__isset;

class ClientService_set_cells_as_arrays_args {
 public:

  ClientService_set_cells_as_arrays_args(const ClientService_set_cells_as_arrays_args&);
  ClientService_set_cells_as_arrays_args& operator=(const ClientService_set_cells_as_arrays_args&);
  ClientService_set_cells_as_arrays_args() : ns(0), table_name() {
  }

  virtual ~ClientService_set_cells_as_arrays_args() throw();
  Namespace ns;
  std::string table_name;
  std::vector<CellAsArray>  cells;

  _ClientService_set_cells_as_arrays_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_cells(const std::vector<CellAsArray> & val);

  bool operator == (const ClientService_set_cells_as_arrays_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cells_as_arrays_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cells_as_arrays_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_set_cells_as_arrays_pargs {
 public:


  virtual ~ClientService_set_cells_as_arrays_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const std::vector<CellAsArray> * cells;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cells_as_arrays_result__isset {
  _ClientService_set_cells_as_arrays_result__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cells_as_arrays_result__isset;

class ClientService_set_cells_as_arrays_result {
 public:

  ClientService_set_cells_as_arrays_result(const ClientService_set_cells_as_arrays_result&);
  ClientService_set_cells_as_arrays_result& operator=(const ClientService_set_cells_as_arrays_result&);
  ClientService_set_cells_as_arrays_result() {
  }

  virtual ~ClientService_set_cells_as_arrays_result() throw();
  ClientException e;

  _ClientService_set_cells_as_arrays_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_set_cells_as_arrays_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cells_as_arrays_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cells_as_arrays_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cells_as_arrays_presult__isset {
  _ClientService_set_cells_as_arrays_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cells_as_arrays_presult__isset;

class ClientService_set_cells_as_arrays_presult {
 public:


  virtual ~ClientService_set_cells_as_arrays_presult() throw();
  ClientException e;

  _ClientService_set_cells_as_arrays_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_mutator_set_cells_serialized_args__isset {
  _ClientService_mutator_set_cells_serialized_args__isset() : mutator(false), cells(false), flush(true) {}
  bool mutator :1;
  bool cells :1;
  bool flush :1;
} _ClientService_mutator_set_cells_serialized_args__isset;

class ClientService_mutator_set_cells_serialized_args {
 public:

  ClientService_mutator_set_cells_serialized_args(const ClientService_mutator_set_cells_serialized_args&);
  ClientService_mutator_set_cells_serialized_args& operator=(const ClientService_mutator_set_cells_serialized_args&);
  ClientService_mutator_set_cells_serialized_args() : mutator(0), cells(), flush(false) {
  }

  virtual ~ClientService_mutator_set_cells_serialized_args() throw();
  Mutator mutator;
  CellsSerialized cells;
  bool flush;

  _ClientService_mutator_set_cells_serialized_args__isset __isset;

  void __set_mutator(const Mutator val);

  void __set_cells(const CellsSerialized& val);

  void __set_flush(const bool val);

  bool operator == (const ClientService_mutator_set_cells_serialized_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    if (!(cells == rhs.cells))
      return false;
    if (!(flush == rhs.flush))
      return false;
    return true;
  }
  bool operator != (const ClientService_mutator_set_cells_serialized_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_mutator_set_cells_serialized_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_mutator_set_cells_serialized_pargs {
 public:


  virtual ~ClientService_mutator_set_cells_serialized_pargs() throw();
  const Mutator* mutator;
  const CellsSerialized* cells;
  const bool* flush;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_mutator_set_cells_serialized_result__isset {
  _ClientService_mutator_set_cells_serialized_result__isset() : e(false) {}
  bool e :1;
} _ClientService_mutator_set_cells_serialized_result__isset;

class ClientService_mutator_set_cells_serialized_result {
 public:

  ClientService_mutator_set_cells_serialized_result(const ClientService_mutator_set_cells_serialized_result&);
  ClientService_mutator_set_cells_serialized_result& operator=(const ClientService_mutator_set_cells_serialized_result&);
  ClientService_mutator_set_cells_serialized_result() {
  }

  virtual ~ClientService_mutator_set_cells_serialized_result() throw();
  ClientException e;

  _ClientService_mutator_set_cells_serialized_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_mutator_set_cells_serialized_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_mutator_set_cells_serialized_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_mutator_set_cells_serialized_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_mutator_set_cells_serialized_presult__isset {
  _ClientService_mutator_set_cells_serialized_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_mutator_set_cells_serialized_presult__isset;

class ClientService_mutator_set_cells_serialized_presult {
 public:


  virtual ~ClientService_mutator_set_cells_serialized_presult() throw();
  ClientException e;

  _ClientService_mutator_set_cells_serialized_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_set_cells_serialized_args__isset {
  _ClientService_set_cells_serialized_args__isset() : ns(false), table_name(false), cells(false) {}
  bool ns :1;
  bool table_name :1;
  bool cells :1;
} _ClientService_set_cells_serialized_args__isset;

class ClientService_set_cells_serialized_args {
 public:

  ClientService_set_cells_serialized_args(const ClientService_set_cells_serialized_args&);
  ClientService_set_cells_serialized_args& operator=(const ClientService_set_cells_serialized_args&);
  ClientService_set_cells_serialized_args() : ns(0), table_name(), cells() {
  }

  virtual ~ClientService_set_cells_serialized_args() throw();
  Namespace ns;
  std::string table_name;
  CellsSerialized cells;

  _ClientService_set_cells_serialized_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_cells(const CellsSerialized& val);

  bool operator == (const ClientService_set_cells_serialized_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cells_serialized_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cells_serialized_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_set_cells_serialized_pargs {
 public:


  virtual ~ClientService_set_cells_serialized_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const CellsSerialized* cells;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cells_serialized_result__isset {
  _ClientService_set_cells_serialized_result__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cells_serialized_result__isset;

class ClientService_set_cells_serialized_result {
 public:

  ClientService_set_cells_serialized_result(const ClientService_set_cells_serialized_result&);
  ClientService_set_cells_serialized_result& operator=(const ClientService_set_cells_serialized_result&);
  ClientService_set_cells_serialized_result() {
  }

  virtual ~ClientService_set_cells_serialized_result() throw();
  ClientException e;

  _ClientService_set_cells_serialized_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_set_cells_serialized_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cells_serialized_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cells_serialized_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cells_serialized_presult__isset {
  _ClientService_set_cells_serialized_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cells_serialized_presult__isset;

class ClientService_set_cells_serialized_presult {
 public:


  virtual ~ClientService_set_cells_serialized_presult() throw();
  ClientException e;

  _ClientService_set_cells_serialized_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_mutator_flush_args__isset {
  _ClientService_mutator_flush_args__isset() : mutator(false) {}
  bool mutator :1;
} _ClientService_mutator_flush_args__isset;

class ClientService_mutator_flush_args {
 public:

  ClientService_mutator_flush_args(const ClientService_mutator_flush_args&);
  ClientService_mutator_flush_args& operator=(const ClientService_mutator_flush_args&);
  ClientService_mutator_flush_args() : mutator(0) {
  }

  virtual ~ClientService_mutator_flush_args() throw();
  Mutator mutator;

  _ClientService_mutator_flush_args__isset __isset;

  void __set_mutator(const Mutator val);

  bool operator == (const ClientService_mutator_flush_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    return true;
  }
  bool operator != (const ClientService_mutator_flush_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_mutator_flush_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_mutator_flush_pargs {
 public:


  virtual ~ClientService_mutator_flush_pargs() throw();
  const Mutator* mutator;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_mutator_flush_result__isset {
  _ClientService_mutator_flush_result__isset() : e(false) {}
  bool e :1;
} _ClientService_mutator_flush_result__isset;

class ClientService_mutator_flush_result {
 public:

  ClientService_mutator_flush_result(const ClientService_mutator_flush_result&);
  ClientService_mutator_flush_result& operator=(const ClientService_mutator_flush_result&);
  ClientService_mutator_flush_result() {
  }

  virtual ~ClientService_mutator_flush_result() throw();
  ClientException e;

  _ClientService_mutator_flush_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_mutator_flush_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_mutator_flush_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_mutator_flush_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_mutator_flush_presult__isset {
  _ClientService_mutator_flush_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_mutator_flush_presult__isset;

class ClientService_mutator_flush_presult {
 public:


  virtual ~ClientService_mutator_flush_presult() throw();
  ClientException e;

  _ClientService_mutator_flush_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_flush_mutator_args__isset {
  _ClientService_flush_mutator_args__isset() : mutator(false) {}
  bool mutator :1;
} _ClientService_flush_mutator_args__isset;

class ClientService_flush_mutator_args {
 public:

  ClientService_flush_mutator_args(const ClientService_flush_mutator_args&);
  ClientService_flush_mutator_args& operator=(const ClientService_flush_mutator_args&);
  ClientService_flush_mutator_args() : mutator(0) {
  }

  virtual ~ClientService_flush_mutator_args() throw();
  Mutator mutator;

  _ClientService_flush_mutator_args__isset __isset;

  void __set_mutator(const Mutator val);

  bool operator == (const ClientService_flush_mutator_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    return true;
  }
  bool operator != (const ClientService_flush_mutator_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_flush_mutator_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_flush_mutator_pargs {
 public:


  virtual ~ClientService_flush_mutator_pargs() throw();
  const Mutator* mutator;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_flush_mutator_result__isset {
  _ClientService_flush_mutator_result__isset() : e(false) {}
  bool e :1;
} _ClientService_flush_mutator_result__isset;

class ClientService_flush_mutator_result {
 public:

  ClientService_flush_mutator_result(const ClientService_flush_mutator_result&);
  ClientService_flush_mutator_result& operator=(const ClientService_flush_mutator_result&);
  ClientService_flush_mutator_result() {
  }

  virtual ~ClientService_flush_mutator_result() throw();
  ClientException e;

  _ClientService_flush_mutator_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_flush_mutator_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_flush_mutator_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_flush_mutator_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_flush_mutator_presult__isset {
  _ClientService_flush_mutator_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_flush_mutator_presult__isset;

class ClientService_flush_mutator_presult {
 public:


  virtual ~ClientService_flush_mutator_presult() throw();
  ClientException e;

  _ClientService_flush_mutator_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_async_mutator_set_cell_args__isset {
  _ClientService_async_mutator_set_cell_args__isset() : mutator(false), cell(false) {}
  bool mutator :1;
  bool cell :1;
} _ClientService_async_mutator_set_cell_args__isset;

class ClientService_async_mutator_set_cell_args {
 public:

  ClientService_async_mutator_set_cell_args(const ClientService_async_mutator_set_cell_args&);
  ClientService_async_mutator_set_cell_args& operator=(const ClientService_async_mutator_set_cell_args&);
  ClientService_async_mutator_set_cell_args() : mutator(0) {
  }

  virtual ~ClientService_async_mutator_set_cell_args() throw();
  MutatorAsync mutator;
  Cell cell;

  _ClientService_async_mutator_set_cell_args__isset __isset;

  void __set_mutator(const MutatorAsync val);

  void __set_cell(const Cell& val);

  bool operator == (const ClientService_async_mutator_set_cell_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    if (!(cell == rhs.cell))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_mutator_set_cell_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_mutator_set_cell_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_async_mutator_set_cell_pargs {
 public:


  virtual ~ClientService_async_mutator_set_cell_pargs() throw();
  const MutatorAsync* mutator;
  const Cell* cell;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_mutator_set_cell_result__isset {
  _ClientService_async_mutator_set_cell_result__isset() : e(false) {}
  bool e :1;
} _ClientService_async_mutator_set_cell_result__isset;

class ClientService_async_mutator_set_cell_result {
 public:

  ClientService_async_mutator_set_cell_result(const ClientService_async_mutator_set_cell_result&);
  ClientService_async_mutator_set_cell_result& operator=(const ClientService_async_mutator_set_cell_result&);
  ClientService_async_mutator_set_cell_result() {
  }

  virtual ~ClientService_async_mutator_set_cell_result() throw();
  ClientException e;

  _ClientService_async_mutator_set_cell_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_async_mutator_set_cell_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_mutator_set_cell_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_mutator_set_cell_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_mutator_set_cell_presult__isset {
  _ClientService_async_mutator_set_cell_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_async_mutator_set_cell_presult__isset;

class ClientService_async_mutator_set_cell_presult {
 public:


  virtual ~ClientService_async_mutator_set_cell_presult() throw();
  ClientException e;

  _ClientService_async_mutator_set_cell_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_set_cell_async_args__isset {
  _ClientService_set_cell_async_args__isset() : mutator(false), cell(false) {}
  bool mutator :1;
  bool cell :1;
} _ClientService_set_cell_async_args__isset;

class ClientService_set_cell_async_args {
 public:

  ClientService_set_cell_async_args(const ClientService_set_cell_async_args&);
  ClientService_set_cell_async_args& operator=(const ClientService_set_cell_async_args&);
  ClientService_set_cell_async_args() : mutator(0) {
  }

  virtual ~ClientService_set_cell_async_args() throw();
  MutatorAsync mutator;
  Cell cell;

  _ClientService_set_cell_async_args__isset __isset;

  void __set_mutator(const MutatorAsync val);

  void __set_cell(const Cell& val);

  bool operator == (const ClientService_set_cell_async_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    if (!(cell == rhs.cell))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cell_async_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cell_async_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_set_cell_async_pargs {
 public:


  virtual ~ClientService_set_cell_async_pargs() throw();
  const MutatorAsync* mutator;
  const Cell* cell;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cell_async_result__isset {
  _ClientService_set_cell_async_result__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cell_async_result__isset;

class ClientService_set_cell_async_result {
 public:

  ClientService_set_cell_async_result(const ClientService_set_cell_async_result&);
  ClientService_set_cell_async_result& operator=(const ClientService_set_cell_async_result&);
  ClientService_set_cell_async_result() {
  }

  virtual ~ClientService_set_cell_async_result() throw();
  ClientException e;

  _ClientService_set_cell_async_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_set_cell_async_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cell_async_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cell_async_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cell_async_presult__isset {
  _ClientService_set_cell_async_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cell_async_presult__isset;

class ClientService_set_cell_async_presult {
 public:


  virtual ~ClientService_set_cell_async_presult() throw();
  ClientException e;

  _ClientService_set_cell_async_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_async_mutator_set_cell_as_array_args__isset {
  _ClientService_async_mutator_set_cell_as_array_args__isset() : mutator(false), cell(false) {}
  bool mutator :1;
  bool cell :1;
} _ClientService_async_mutator_set_cell_as_array_args__isset;

class ClientService_async_mutator_set_cell_as_array_args {
 public:

  ClientService_async_mutator_set_cell_as_array_args(const ClientService_async_mutator_set_cell_as_array_args&);
  ClientService_async_mutator_set_cell_as_array_args& operator=(const ClientService_async_mutator_set_cell_as_array_args&);
  ClientService_async_mutator_set_cell_as_array_args() : mutator(0) {
  }

  virtual ~ClientService_async_mutator_set_cell_as_array_args() throw();
  MutatorAsync mutator;
  CellAsArray cell;

  _ClientService_async_mutator_set_cell_as_array_args__isset __isset;

  void __set_mutator(const MutatorAsync val);

  void __set_cell(const CellAsArray& val);

  bool operator == (const ClientService_async_mutator_set_cell_as_array_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    if (!(cell == rhs.cell))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_mutator_set_cell_as_array_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_mutator_set_cell_as_array_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_async_mutator_set_cell_as_array_pargs {
 public:


  virtual ~ClientService_async_mutator_set_cell_as_array_pargs() throw();
  const MutatorAsync* mutator;
  const CellAsArray* cell;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_mutator_set_cell_as_array_result__isset {
  _ClientService_async_mutator_set_cell_as_array_result__isset() : e(false) {}
  bool e :1;
} _ClientService_async_mutator_set_cell_as_array_result__isset;

class ClientService_async_mutator_set_cell_as_array_result {
 public:

  ClientService_async_mutator_set_cell_as_array_result(const ClientService_async_mutator_set_cell_as_array_result&);
  ClientService_async_mutator_set_cell_as_array_result& operator=(const ClientService_async_mutator_set_cell_as_array_result&);
  ClientService_async_mutator_set_cell_as_array_result() {
  }

  virtual ~ClientService_async_mutator_set_cell_as_array_result() throw();
  ClientException e;

  _ClientService_async_mutator_set_cell_as_array_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_async_mutator_set_cell_as_array_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_mutator_set_cell_as_array_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_mutator_set_cell_as_array_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_mutator_set_cell_as_array_presult__isset {
  _ClientService_async_mutator_set_cell_as_array_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_async_mutator_set_cell_as_array_presult__isset;

class ClientService_async_mutator_set_cell_as_array_presult {
 public:


  virtual ~ClientService_async_mutator_set_cell_as_array_presult() throw();
  ClientException e;

  _ClientService_async_mutator_set_cell_as_array_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_set_cell_as_array_async_args__isset {
  _ClientService_set_cell_as_array_async_args__isset() : mutator(false), cell(false) {}
  bool mutator :1;
  bool cell :1;
} _ClientService_set_cell_as_array_async_args__isset;

class ClientService_set_cell_as_array_async_args {
 public:

  ClientService_set_cell_as_array_async_args(const ClientService_set_cell_as_array_async_args&);
  ClientService_set_cell_as_array_async_args& operator=(const ClientService_set_cell_as_array_async_args&);
  ClientService_set_cell_as_array_async_args() : mutator(0) {
  }

  virtual ~ClientService_set_cell_as_array_async_args() throw();
  MutatorAsync mutator;
  CellAsArray cell;

  _ClientService_set_cell_as_array_async_args__isset __isset;

  void __set_mutator(const MutatorAsync val);

  void __set_cell(const CellAsArray& val);

  bool operator == (const ClientService_set_cell_as_array_async_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    if (!(cell == rhs.cell))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cell_as_array_async_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cell_as_array_async_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_set_cell_as_array_async_pargs {
 public:


  virtual ~ClientService_set_cell_as_array_async_pargs() throw();
  const MutatorAsync* mutator;
  const CellAsArray* cell;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cell_as_array_async_result__isset {
  _ClientService_set_cell_as_array_async_result__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cell_as_array_async_result__isset;

class ClientService_set_cell_as_array_async_result {
 public:

  ClientService_set_cell_as_array_async_result(const ClientService_set_cell_as_array_async_result&);
  ClientService_set_cell_as_array_async_result& operator=(const ClientService_set_cell_as_array_async_result&);
  ClientService_set_cell_as_array_async_result() {
  }

  virtual ~ClientService_set_cell_as_array_async_result() throw();
  ClientException e;

  _ClientService_set_cell_as_array_async_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_set_cell_as_array_async_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cell_as_array_async_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cell_as_array_async_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cell_as_array_async_presult__isset {
  _ClientService_set_cell_as_array_async_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cell_as_array_async_presult__isset;

class ClientService_set_cell_as_array_async_presult {
 public:


  virtual ~ClientService_set_cell_as_array_async_presult() throw();
  ClientException e;

  _ClientService_set_cell_as_array_async_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_async_mutator_set_cells_args__isset {
  _ClientService_async_mutator_set_cells_args__isset() : mutator(false), cells(false) {}
  bool mutator :1;
  bool cells :1;
} _ClientService_async_mutator_set_cells_args__isset;

class ClientService_async_mutator_set_cells_args {
 public:

  ClientService_async_mutator_set_cells_args(const ClientService_async_mutator_set_cells_args&);
  ClientService_async_mutator_set_cells_args& operator=(const ClientService_async_mutator_set_cells_args&);
  ClientService_async_mutator_set_cells_args() : mutator(0) {
  }

  virtual ~ClientService_async_mutator_set_cells_args() throw();
  MutatorAsync mutator;
  std::vector<Cell>  cells;

  _ClientService_async_mutator_set_cells_args__isset __isset;

  void __set_mutator(const MutatorAsync val);

  void __set_cells(const std::vector<Cell> & val);

  bool operator == (const ClientService_async_mutator_set_cells_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    if (!(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_mutator_set_cells_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_mutator_set_cells_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_async_mutator_set_cells_pargs {
 public:


  virtual ~ClientService_async_mutator_set_cells_pargs() throw();
  const MutatorAsync* mutator;
  const std::vector<Cell> * cells;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_mutator_set_cells_result__isset {
  _ClientService_async_mutator_set_cells_result__isset() : e(false) {}
  bool e :1;
} _ClientService_async_mutator_set_cells_result__isset;

class ClientService_async_mutator_set_cells_result {
 public:

  ClientService_async_mutator_set_cells_result(const ClientService_async_mutator_set_cells_result&);
  ClientService_async_mutator_set_cells_result& operator=(const ClientService_async_mutator_set_cells_result&);
  ClientService_async_mutator_set_cells_result() {
  }

  virtual ~ClientService_async_mutator_set_cells_result() throw();
  ClientException e;

  _ClientService_async_mutator_set_cells_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_async_mutator_set_cells_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_mutator_set_cells_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_mutator_set_cells_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_mutator_set_cells_presult__isset {
  _ClientService_async_mutator_set_cells_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_async_mutator_set_cells_presult__isset;

class ClientService_async_mutator_set_cells_presult {
 public:


  virtual ~ClientService_async_mutator_set_cells_presult() throw();
  ClientException e;

  _ClientService_async_mutator_set_cells_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_set_cells_async_args__isset {
  _ClientService_set_cells_async_args__isset() : mutator(false), cells(false) {}
  bool mutator :1;
  bool cells :1;
} _ClientService_set_cells_async_args__isset;

class ClientService_set_cells_async_args {
 public:

  ClientService_set_cells_async_args(const ClientService_set_cells_async_args&);
  ClientService_set_cells_async_args& operator=(const ClientService_set_cells_async_args&);
  ClientService_set_cells_async_args() : mutator(0) {
  }

  virtual ~ClientService_set_cells_async_args() throw();
  MutatorAsync mutator;
  std::vector<Cell>  cells;

  _ClientService_set_cells_async_args__isset __isset;

  void __set_mutator(const MutatorAsync val);

  void __set_cells(const std::vector<Cell> & val);

  bool operator == (const ClientService_set_cells_async_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    if (!(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cells_async_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cells_async_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_set_cells_async_pargs {
 public:


  virtual ~ClientService_set_cells_async_pargs() throw();
  const MutatorAsync* mutator;
  const std::vector<Cell> * cells;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cells_async_result__isset {
  _ClientService_set_cells_async_result__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cells_async_result__isset;

class ClientService_set_cells_async_result {
 public:

  ClientService_set_cells_async_result(const ClientService_set_cells_async_result&);
  ClientService_set_cells_async_result& operator=(const ClientService_set_cells_async_result&);
  ClientService_set_cells_async_result() {
  }

  virtual ~ClientService_set_cells_async_result() throw();
  ClientException e;

  _ClientService_set_cells_async_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_set_cells_async_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cells_async_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cells_async_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cells_async_presult__isset {
  _ClientService_set_cells_async_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cells_async_presult__isset;

class ClientService_set_cells_async_presult {
 public:


  virtual ~ClientService_set_cells_async_presult() throw();
  ClientException e;

  _ClientService_set_cells_async_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_async_mutator_set_cells_as_arrays_args__isset {
  _ClientService_async_mutator_set_cells_as_arrays_args__isset() : mutator(false), cells(false) {}
  bool mutator :1;
  bool cells :1;
} _ClientService_async_mutator_set_cells_as_arrays_args__isset;

class ClientService_async_mutator_set_cells_as_arrays_args {
 public:

  ClientService_async_mutator_set_cells_as_arrays_args(const ClientService_async_mutator_set_cells_as_arrays_args&);
  ClientService_async_mutator_set_cells_as_arrays_args& operator=(const ClientService_async_mutator_set_cells_as_arrays_args&);
  ClientService_async_mutator_set_cells_as_arrays_args() : mutator(0) {
  }

  virtual ~ClientService_async_mutator_set_cells_as_arrays_args() throw();
  MutatorAsync mutator;
  std::vector<CellAsArray>  cells;

  _ClientService_async_mutator_set_cells_as_arrays_args__isset __isset;

  void __set_mutator(const MutatorAsync val);

  void __set_cells(const std::vector<CellAsArray> & val);

  bool operator == (const ClientService_async_mutator_set_cells_as_arrays_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    if (!(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_mutator_set_cells_as_arrays_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_mutator_set_cells_as_arrays_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_async_mutator_set_cells_as_arrays_pargs {
 public:


  virtual ~ClientService_async_mutator_set_cells_as_arrays_pargs() throw();
  const MutatorAsync* mutator;
  const std::vector<CellAsArray> * cells;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_mutator_set_cells_as_arrays_result__isset {
  _ClientService_async_mutator_set_cells_as_arrays_result__isset() : e(false) {}
  bool e :1;
} _ClientService_async_mutator_set_cells_as_arrays_result__isset;

class ClientService_async_mutator_set_cells_as_arrays_result {
 public:

  ClientService_async_mutator_set_cells_as_arrays_result(const ClientService_async_mutator_set_cells_as_arrays_result&);
  ClientService_async_mutator_set_cells_as_arrays_result& operator=(const ClientService_async_mutator_set_cells_as_arrays_result&);
  ClientService_async_mutator_set_cells_as_arrays_result() {
  }

  virtual ~ClientService_async_mutator_set_cells_as_arrays_result() throw();
  ClientException e;

  _ClientService_async_mutator_set_cells_as_arrays_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_async_mutator_set_cells_as_arrays_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_mutator_set_cells_as_arrays_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_mutator_set_cells_as_arrays_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_mutator_set_cells_as_arrays_presult__isset {
  _ClientService_async_mutator_set_cells_as_arrays_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_async_mutator_set_cells_as_arrays_presult__isset;

class ClientService_async_mutator_set_cells_as_arrays_presult {
 public:


  virtual ~ClientService_async_mutator_set_cells_as_arrays_presult() throw();
  ClientException e;

  _ClientService_async_mutator_set_cells_as_arrays_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_set_cells_as_arrays_async_args__isset {
  _ClientService_set_cells_as_arrays_async_args__isset() : mutator(false), cells(false) {}
  bool mutator :1;
  bool cells :1;
} _ClientService_set_cells_as_arrays_async_args__isset;

class ClientService_set_cells_as_arrays_async_args {
 public:

  ClientService_set_cells_as_arrays_async_args(const ClientService_set_cells_as_arrays_async_args&);
  ClientService_set_cells_as_arrays_async_args& operator=(const ClientService_set_cells_as_arrays_async_args&);
  ClientService_set_cells_as_arrays_async_args() : mutator(0) {
  }

  virtual ~ClientService_set_cells_as_arrays_async_args() throw();
  MutatorAsync mutator;
  std::vector<CellAsArray>  cells;

  _ClientService_set_cells_as_arrays_async_args__isset __isset;

  void __set_mutator(const MutatorAsync val);

  void __set_cells(const std::vector<CellAsArray> & val);

  bool operator == (const ClientService_set_cells_as_arrays_async_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    if (!(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cells_as_arrays_async_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cells_as_arrays_async_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_set_cells_as_arrays_async_pargs {
 public:


  virtual ~ClientService_set_cells_as_arrays_async_pargs() throw();
  const MutatorAsync* mutator;
  const std::vector<CellAsArray> * cells;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cells_as_arrays_async_result__isset {
  _ClientService_set_cells_as_arrays_async_result__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cells_as_arrays_async_result__isset;

class ClientService_set_cells_as_arrays_async_result {
 public:

  ClientService_set_cells_as_arrays_async_result(const ClientService_set_cells_as_arrays_async_result&);
  ClientService_set_cells_as_arrays_async_result& operator=(const ClientService_set_cells_as_arrays_async_result&);
  ClientService_set_cells_as_arrays_async_result() {
  }

  virtual ~ClientService_set_cells_as_arrays_async_result() throw();
  ClientException e;

  _ClientService_set_cells_as_arrays_async_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_set_cells_as_arrays_async_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cells_as_arrays_async_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cells_as_arrays_async_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cells_as_arrays_async_presult__isset {
  _ClientService_set_cells_as_arrays_async_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cells_as_arrays_async_presult__isset;

class ClientService_set_cells_as_arrays_async_presult {
 public:


  virtual ~ClientService_set_cells_as_arrays_async_presult() throw();
  ClientException e;

  _ClientService_set_cells_as_arrays_async_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_async_mutator_set_cells_serialized_args__isset {
  _ClientService_async_mutator_set_cells_serialized_args__isset() : mutator(false), cells(false), flush(true) {}
  bool mutator :1;
  bool cells :1;
  bool flush :1;
} _ClientService_async_mutator_set_cells_serialized_args__isset;

class ClientService_async_mutator_set_cells_serialized_args {
 public:

  ClientService_async_mutator_set_cells_serialized_args(const ClientService_async_mutator_set_cells_serialized_args&);
  ClientService_async_mutator_set_cells_serialized_args& operator=(const ClientService_async_mutator_set_cells_serialized_args&);
  ClientService_async_mutator_set_cells_serialized_args() : mutator(0), cells(), flush(false) {
  }

  virtual ~ClientService_async_mutator_set_cells_serialized_args() throw();
  MutatorAsync mutator;
  CellsSerialized cells;
  bool flush;

  _ClientService_async_mutator_set_cells_serialized_args__isset __isset;

  void __set_mutator(const MutatorAsync val);

  void __set_cells(const CellsSerialized& val);

  void __set_flush(const bool val);

  bool operator == (const ClientService_async_mutator_set_cells_serialized_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    if (!(cells == rhs.cells))
      return false;
    if (!(flush == rhs.flush))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_mutator_set_cells_serialized_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_mutator_set_cells_serialized_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_async_mutator_set_cells_serialized_pargs {
 public:


  virtual ~ClientService_async_mutator_set_cells_serialized_pargs() throw();
  const MutatorAsync* mutator;
  const CellsSerialized* cells;
  const bool* flush;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_mutator_set_cells_serialized_result__isset {
  _ClientService_async_mutator_set_cells_serialized_result__isset() : e(false) {}
  bool e :1;
} _ClientService_async_mutator_set_cells_serialized_result__isset;

class ClientService_async_mutator_set_cells_serialized_result {
 public:

  ClientService_async_mutator_set_cells_serialized_result(const ClientService_async_mutator_set_cells_serialized_result&);
  ClientService_async_mutator_set_cells_serialized_result& operator=(const ClientService_async_mutator_set_cells_serialized_result&);
  ClientService_async_mutator_set_cells_serialized_result() {
  }

  virtual ~ClientService_async_mutator_set_cells_serialized_result() throw();
  ClientException e;

  _ClientService_async_mutator_set_cells_serialized_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_async_mutator_set_cells_serialized_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_mutator_set_cells_serialized_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_mutator_set_cells_serialized_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_mutator_set_cells_serialized_presult__isset {
  _ClientService_async_mutator_set_cells_serialized_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_async_mutator_set_cells_serialized_presult__isset;

class ClientService_async_mutator_set_cells_serialized_presult {
 public:


  virtual ~ClientService_async_mutator_set_cells_serialized_presult() throw();
  ClientException e;

  _ClientService_async_mutator_set_cells_serialized_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_set_cells_serialized_async_args__isset {
  _ClientService_set_cells_serialized_async_args__isset() : mutator(false), cells(false), flush(true) {}
  bool mutator :1;
  bool cells :1;
  bool flush :1;
} _ClientService_set_cells_serialized_async_args__isset;

class ClientService_set_cells_serialized_async_args {
 public:

  ClientService_set_cells_serialized_async_args(const ClientService_set_cells_serialized_async_args&);
  ClientService_set_cells_serialized_async_args& operator=(const ClientService_set_cells_serialized_async_args&);
  ClientService_set_cells_serialized_async_args() : mutator(0), cells(), flush(false) {
  }

  virtual ~ClientService_set_cells_serialized_async_args() throw();
  MutatorAsync mutator;
  CellsSerialized cells;
  bool flush;

  _ClientService_set_cells_serialized_async_args__isset __isset;

  void __set_mutator(const MutatorAsync val);

  void __set_cells(const CellsSerialized& val);

  void __set_flush(const bool val);

  bool operator == (const ClientService_set_cells_serialized_async_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    if (!(cells == rhs.cells))
      return false;
    if (!(flush == rhs.flush))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cells_serialized_async_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cells_serialized_async_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_set_cells_serialized_async_pargs {
 public:


  virtual ~ClientService_set_cells_serialized_async_pargs() throw();
  const MutatorAsync* mutator;
  const CellsSerialized* cells;
  const bool* flush;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cells_serialized_async_result__isset {
  _ClientService_set_cells_serialized_async_result__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cells_serialized_async_result__isset;

class ClientService_set_cells_serialized_async_result {
 public:

  ClientService_set_cells_serialized_async_result(const ClientService_set_cells_serialized_async_result&);
  ClientService_set_cells_serialized_async_result& operator=(const ClientService_set_cells_serialized_async_result&);
  ClientService_set_cells_serialized_async_result() {
  }

  virtual ~ClientService_set_cells_serialized_async_result() throw();
  ClientException e;

  _ClientService_set_cells_serialized_async_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_set_cells_serialized_async_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_set_cells_serialized_async_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_set_cells_serialized_async_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_set_cells_serialized_async_presult__isset {
  _ClientService_set_cells_serialized_async_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_set_cells_serialized_async_presult__isset;

class ClientService_set_cells_serialized_async_presult {
 public:


  virtual ~ClientService_set_cells_serialized_async_presult() throw();
  ClientException e;

  _ClientService_set_cells_serialized_async_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_async_mutator_flush_args__isset {
  _ClientService_async_mutator_flush_args__isset() : mutator(false) {}
  bool mutator :1;
} _ClientService_async_mutator_flush_args__isset;

class ClientService_async_mutator_flush_args {
 public:

  ClientService_async_mutator_flush_args(const ClientService_async_mutator_flush_args&);
  ClientService_async_mutator_flush_args& operator=(const ClientService_async_mutator_flush_args&);
  ClientService_async_mutator_flush_args() : mutator(0) {
  }

  virtual ~ClientService_async_mutator_flush_args() throw();
  MutatorAsync mutator;

  _ClientService_async_mutator_flush_args__isset __isset;

  void __set_mutator(const MutatorAsync val);

  bool operator == (const ClientService_async_mutator_flush_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_mutator_flush_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_mutator_flush_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_async_mutator_flush_pargs {
 public:


  virtual ~ClientService_async_mutator_flush_pargs() throw();
  const MutatorAsync* mutator;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_mutator_flush_result__isset {
  _ClientService_async_mutator_flush_result__isset() : e(false) {}
  bool e :1;
} _ClientService_async_mutator_flush_result__isset;

class ClientService_async_mutator_flush_result {
 public:

  ClientService_async_mutator_flush_result(const ClientService_async_mutator_flush_result&);
  ClientService_async_mutator_flush_result& operator=(const ClientService_async_mutator_flush_result&);
  ClientService_async_mutator_flush_result() {
  }

  virtual ~ClientService_async_mutator_flush_result() throw();
  ClientException e;

  _ClientService_async_mutator_flush_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_async_mutator_flush_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_async_mutator_flush_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_async_mutator_flush_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_async_mutator_flush_presult__isset {
  _ClientService_async_mutator_flush_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_async_mutator_flush_presult__isset;

class ClientService_async_mutator_flush_presult {
 public:


  virtual ~ClientService_async_mutator_flush_presult() throw();
  ClientException e;

  _ClientService_async_mutator_flush_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_flush_mutator_async_args__isset {
  _ClientService_flush_mutator_async_args__isset() : mutator(false) {}
  bool mutator :1;
} _ClientService_flush_mutator_async_args__isset;

class ClientService_flush_mutator_async_args {
 public:

  ClientService_flush_mutator_async_args(const ClientService_flush_mutator_async_args&);
  ClientService_flush_mutator_async_args& operator=(const ClientService_flush_mutator_async_args&);
  ClientService_flush_mutator_async_args() : mutator(0) {
  }

  virtual ~ClientService_flush_mutator_async_args() throw();
  MutatorAsync mutator;

  _ClientService_flush_mutator_async_args__isset __isset;

  void __set_mutator(const MutatorAsync val);

  bool operator == (const ClientService_flush_mutator_async_args & rhs) const
  {
    if (!(mutator == rhs.mutator))
      return false;
    return true;
  }
  bool operator != (const ClientService_flush_mutator_async_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_flush_mutator_async_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_flush_mutator_async_pargs {
 public:


  virtual ~ClientService_flush_mutator_async_pargs() throw();
  const MutatorAsync* mutator;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_flush_mutator_async_result__isset {
  _ClientService_flush_mutator_async_result__isset() : e(false) {}
  bool e :1;
} _ClientService_flush_mutator_async_result__isset;

class ClientService_flush_mutator_async_result {
 public:

  ClientService_flush_mutator_async_result(const ClientService_flush_mutator_async_result&);
  ClientService_flush_mutator_async_result& operator=(const ClientService_flush_mutator_async_result&);
  ClientService_flush_mutator_async_result() {
  }

  virtual ~ClientService_flush_mutator_async_result() throw();
  ClientException e;

  _ClientService_flush_mutator_async_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_flush_mutator_async_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_flush_mutator_async_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_flush_mutator_async_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_flush_mutator_async_presult__isset {
  _ClientService_flush_mutator_async_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_flush_mutator_async_presult__isset;

class ClientService_flush_mutator_async_presult {
 public:


  virtual ~ClientService_flush_mutator_async_presult() throw();
  ClientException e;

  _ClientService_flush_mutator_async_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_namespace_exists_args__isset {
  _ClientService_namespace_exists_args__isset() : ns(false) {}
  bool ns :1;
} _ClientService_namespace_exists_args__isset;

class ClientService_namespace_exists_args {
 public:

  ClientService_namespace_exists_args(const ClientService_namespace_exists_args&);
  ClientService_namespace_exists_args& operator=(const ClientService_namespace_exists_args&);
  ClientService_namespace_exists_args() : ns() {
  }

  virtual ~ClientService_namespace_exists_args() throw();
  std::string ns;

  _ClientService_namespace_exists_args__isset __isset;

  void __set_ns(const std::string& val);

  bool operator == (const ClientService_namespace_exists_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const ClientService_namespace_exists_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_namespace_exists_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_namespace_exists_pargs {
 public:


  virtual ~ClientService_namespace_exists_pargs() throw();
  const std::string* ns;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_namespace_exists_result__isset {
  _ClientService_namespace_exists_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_namespace_exists_result__isset;

class ClientService_namespace_exists_result {
 public:

  ClientService_namespace_exists_result(const ClientService_namespace_exists_result&);
  ClientService_namespace_exists_result& operator=(const ClientService_namespace_exists_result&);
  ClientService_namespace_exists_result() : success(0) {
  }

  virtual ~ClientService_namespace_exists_result() throw();
  bool success;
  ClientException e;

  _ClientService_namespace_exists_result__isset __isset;

  void __set_success(const bool val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_namespace_exists_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_namespace_exists_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_namespace_exists_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_namespace_exists_presult__isset {
  _ClientService_namespace_exists_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_namespace_exists_presult__isset;

class ClientService_namespace_exists_presult {
 public:


  virtual ~ClientService_namespace_exists_presult() throw();
  bool* success;
  ClientException e;

  _ClientService_namespace_exists_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_exists_namespace_args__isset {
  _ClientService_exists_namespace_args__isset() : ns(false) {}
  bool ns :1;
} _ClientService_exists_namespace_args__isset;

class ClientService_exists_namespace_args {
 public:

  ClientService_exists_namespace_args(const ClientService_exists_namespace_args&);
  ClientService_exists_namespace_args& operator=(const ClientService_exists_namespace_args&);
  ClientService_exists_namespace_args() : ns() {
  }

  virtual ~ClientService_exists_namespace_args() throw();
  std::string ns;

  _ClientService_exists_namespace_args__isset __isset;

  void __set_ns(const std::string& val);

  bool operator == (const ClientService_exists_namespace_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const ClientService_exists_namespace_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_exists_namespace_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_exists_namespace_pargs {
 public:


  virtual ~ClientService_exists_namespace_pargs() throw();
  const std::string* ns;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_exists_namespace_result__isset {
  _ClientService_exists_namespace_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_exists_namespace_result__isset;

class ClientService_exists_namespace_result {
 public:

  ClientService_exists_namespace_result(const ClientService_exists_namespace_result&);
  ClientService_exists_namespace_result& operator=(const ClientService_exists_namespace_result&);
  ClientService_exists_namespace_result() : success(0) {
  }

  virtual ~ClientService_exists_namespace_result() throw();
  bool success;
  ClientException e;

  _ClientService_exists_namespace_result__isset __isset;

  void __set_success(const bool val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_exists_namespace_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_exists_namespace_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_exists_namespace_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_exists_namespace_presult__isset {
  _ClientService_exists_namespace_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_exists_namespace_presult__isset;

class ClientService_exists_namespace_presult {
 public:


  virtual ~ClientService_exists_namespace_presult() throw();
  bool* success;
  ClientException e;

  _ClientService_exists_namespace_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_exists_table_args__isset {
  _ClientService_exists_table_args__isset() : ns(false), name(false) {}
  bool ns :1;
  bool name :1;
} _ClientService_exists_table_args__isset;

class ClientService_exists_table_args {
 public:

  ClientService_exists_table_args(const ClientService_exists_table_args&);
  ClientService_exists_table_args& operator=(const ClientService_exists_table_args&);
  ClientService_exists_table_args() : ns(0), name() {
  }

  virtual ~ClientService_exists_table_args() throw();
  Namespace ns;
  std::string name;

  _ClientService_exists_table_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_name(const std::string& val);

  bool operator == (const ClientService_exists_table_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const ClientService_exists_table_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_exists_table_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_exists_table_pargs {
 public:


  virtual ~ClientService_exists_table_pargs() throw();
  const Namespace* ns;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_exists_table_result__isset {
  _ClientService_exists_table_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_exists_table_result__isset;

class ClientService_exists_table_result {
 public:

  ClientService_exists_table_result(const ClientService_exists_table_result&);
  ClientService_exists_table_result& operator=(const ClientService_exists_table_result&);
  ClientService_exists_table_result() : success(0) {
  }

  virtual ~ClientService_exists_table_result() throw();
  bool success;
  ClientException e;

  _ClientService_exists_table_result__isset __isset;

  void __set_success(const bool val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_exists_table_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_exists_table_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_exists_table_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_exists_table_presult__isset {
  _ClientService_exists_table_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_exists_table_presult__isset;

class ClientService_exists_table_presult {
 public:


  virtual ~ClientService_exists_table_presult() throw();
  bool* success;
  ClientException e;

  _ClientService_exists_table_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_table_exists_args__isset {
  _ClientService_table_exists_args__isset() : ns(false), name(false) {}
  bool ns :1;
  bool name :1;
} _ClientService_table_exists_args__isset;

class ClientService_table_exists_args {
 public:

  ClientService_table_exists_args(const ClientService_table_exists_args&);
  ClientService_table_exists_args& operator=(const ClientService_table_exists_args&);
  ClientService_table_exists_args() : ns(0), name() {
  }

  virtual ~ClientService_table_exists_args() throw();
  Namespace ns;
  std::string name;

  _ClientService_table_exists_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_name(const std::string& val);

  bool operator == (const ClientService_table_exists_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_exists_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_exists_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_table_exists_pargs {
 public:


  virtual ~ClientService_table_exists_pargs() throw();
  const Namespace* ns;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_exists_result__isset {
  _ClientService_table_exists_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_table_exists_result__isset;

class ClientService_table_exists_result {
 public:

  ClientService_table_exists_result(const ClientService_table_exists_result&);
  ClientService_table_exists_result& operator=(const ClientService_table_exists_result&);
  ClientService_table_exists_result() : success(0) {
  }

  virtual ~ClientService_table_exists_result() throw();
  bool success;
  ClientException e;

  _ClientService_table_exists_result__isset __isset;

  void __set_success(const bool val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_table_exists_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_exists_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_exists_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_exists_presult__isset {
  _ClientService_table_exists_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_table_exists_presult__isset;

class ClientService_table_exists_presult {
 public:


  virtual ~ClientService_table_exists_presult() throw();
  bool* success;
  ClientException e;

  _ClientService_table_exists_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_table_get_id_args__isset {
  _ClientService_table_get_id_args__isset() : ns(false), table_name(false) {}
  bool ns :1;
  bool table_name :1;
} _ClientService_table_get_id_args__isset;

class ClientService_table_get_id_args {
 public:

  ClientService_table_get_id_args(const ClientService_table_get_id_args&);
  ClientService_table_get_id_args& operator=(const ClientService_table_get_id_args&);
  ClientService_table_get_id_args() : ns(0), table_name() {
  }

  virtual ~ClientService_table_get_id_args() throw();
  Namespace ns;
  std::string table_name;

  _ClientService_table_get_id_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  bool operator == (const ClientService_table_get_id_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_get_id_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_get_id_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_table_get_id_pargs {
 public:


  virtual ~ClientService_table_get_id_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_get_id_result__isset {
  _ClientService_table_get_id_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_table_get_id_result__isset;

class ClientService_table_get_id_result {
 public:

  ClientService_table_get_id_result(const ClientService_table_get_id_result&);
  ClientService_table_get_id_result& operator=(const ClientService_table_get_id_result&);
  ClientService_table_get_id_result() : success() {
  }

  virtual ~ClientService_table_get_id_result() throw();
  std::string success;
  ClientException e;

  _ClientService_table_get_id_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_table_get_id_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_get_id_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_get_id_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_get_id_presult__isset {
  _ClientService_table_get_id_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_table_get_id_presult__isset;

class ClientService_table_get_id_presult {
 public:


  virtual ~ClientService_table_get_id_presult() throw();
  std::string* success;
  ClientException e;

  _ClientService_table_get_id_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_get_table_id_args__isset {
  _ClientService_get_table_id_args__isset() : ns(false), table_name(false) {}
  bool ns :1;
  bool table_name :1;
} _ClientService_get_table_id_args__isset;

class ClientService_get_table_id_args {
 public:

  ClientService_get_table_id_args(const ClientService_get_table_id_args&);
  ClientService_get_table_id_args& operator=(const ClientService_get_table_id_args&);
  ClientService_get_table_id_args() : ns(0), table_name() {
  }

  virtual ~ClientService_get_table_id_args() throw();
  Namespace ns;
  std::string table_name;

  _ClientService_get_table_id_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  bool operator == (const ClientService_get_table_id_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_table_id_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_table_id_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_get_table_id_pargs {
 public:


  virtual ~ClientService_get_table_id_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_table_id_result__isset {
  _ClientService_get_table_id_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_table_id_result__isset;

class ClientService_get_table_id_result {
 public:

  ClientService_get_table_id_result(const ClientService_get_table_id_result&);
  ClientService_get_table_id_result& operator=(const ClientService_get_table_id_result&);
  ClientService_get_table_id_result() : success() {
  }

  virtual ~ClientService_get_table_id_result() throw();
  std::string success;
  ClientException e;

  _ClientService_get_table_id_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_get_table_id_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_table_id_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_table_id_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_table_id_presult__isset {
  _ClientService_get_table_id_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_table_id_presult__isset;

class ClientService_get_table_id_presult {
 public:


  virtual ~ClientService_get_table_id_presult() throw();
  std::string* success;
  ClientException e;

  _ClientService_get_table_id_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_table_get_schema_str_args__isset {
  _ClientService_table_get_schema_str_args__isset() : ns(false), table_name(false) {}
  bool ns :1;
  bool table_name :1;
} _ClientService_table_get_schema_str_args__isset;

class ClientService_table_get_schema_str_args {
 public:

  ClientService_table_get_schema_str_args(const ClientService_table_get_schema_str_args&);
  ClientService_table_get_schema_str_args& operator=(const ClientService_table_get_schema_str_args&);
  ClientService_table_get_schema_str_args() : ns(0), table_name() {
  }

  virtual ~ClientService_table_get_schema_str_args() throw();
  Namespace ns;
  std::string table_name;

  _ClientService_table_get_schema_str_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  bool operator == (const ClientService_table_get_schema_str_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_get_schema_str_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_get_schema_str_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_table_get_schema_str_pargs {
 public:


  virtual ~ClientService_table_get_schema_str_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_get_schema_str_result__isset {
  _ClientService_table_get_schema_str_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_table_get_schema_str_result__isset;

class ClientService_table_get_schema_str_result {
 public:

  ClientService_table_get_schema_str_result(const ClientService_table_get_schema_str_result&);
  ClientService_table_get_schema_str_result& operator=(const ClientService_table_get_schema_str_result&);
  ClientService_table_get_schema_str_result() : success() {
  }

  virtual ~ClientService_table_get_schema_str_result() throw();
  std::string success;
  ClientException e;

  _ClientService_table_get_schema_str_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_table_get_schema_str_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_get_schema_str_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_get_schema_str_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_get_schema_str_presult__isset {
  _ClientService_table_get_schema_str_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_table_get_schema_str_presult__isset;

class ClientService_table_get_schema_str_presult {
 public:


  virtual ~ClientService_table_get_schema_str_presult() throw();
  std::string* success;
  ClientException e;

  _ClientService_table_get_schema_str_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_get_schema_str_args__isset {
  _ClientService_get_schema_str_args__isset() : ns(false), table_name(false) {}
  bool ns :1;
  bool table_name :1;
} _ClientService_get_schema_str_args__isset;

class ClientService_get_schema_str_args {
 public:

  ClientService_get_schema_str_args(const ClientService_get_schema_str_args&);
  ClientService_get_schema_str_args& operator=(const ClientService_get_schema_str_args&);
  ClientService_get_schema_str_args() : ns(0), table_name() {
  }

  virtual ~ClientService_get_schema_str_args() throw();
  Namespace ns;
  std::string table_name;

  _ClientService_get_schema_str_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  bool operator == (const ClientService_get_schema_str_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_schema_str_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_schema_str_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_get_schema_str_pargs {
 public:


  virtual ~ClientService_get_schema_str_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_schema_str_result__isset {
  _ClientService_get_schema_str_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_schema_str_result__isset;

class ClientService_get_schema_str_result {
 public:

  ClientService_get_schema_str_result(const ClientService_get_schema_str_result&);
  ClientService_get_schema_str_result& operator=(const ClientService_get_schema_str_result&);
  ClientService_get_schema_str_result() : success() {
  }

  virtual ~ClientService_get_schema_str_result() throw();
  std::string success;
  ClientException e;

  _ClientService_get_schema_str_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_get_schema_str_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_schema_str_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_schema_str_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_schema_str_presult__isset {
  _ClientService_get_schema_str_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_schema_str_presult__isset;

class ClientService_get_schema_str_presult {
 public:


  virtual ~ClientService_get_schema_str_presult() throw();
  std::string* success;
  ClientException e;

  _ClientService_get_schema_str_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_table_get_schema_str_with_ids_args__isset {
  _ClientService_table_get_schema_str_with_ids_args__isset() : ns(false), table_name(false) {}
  bool ns :1;
  bool table_name :1;
} _ClientService_table_get_schema_str_with_ids_args__isset;

class ClientService_table_get_schema_str_with_ids_args {
 public:

  ClientService_table_get_schema_str_with_ids_args(const ClientService_table_get_schema_str_with_ids_args&);
  ClientService_table_get_schema_str_with_ids_args& operator=(const ClientService_table_get_schema_str_with_ids_args&);
  ClientService_table_get_schema_str_with_ids_args() : ns(0), table_name() {
  }

  virtual ~ClientService_table_get_schema_str_with_ids_args() throw();
  Namespace ns;
  std::string table_name;

  _ClientService_table_get_schema_str_with_ids_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  bool operator == (const ClientService_table_get_schema_str_with_ids_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_get_schema_str_with_ids_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_get_schema_str_with_ids_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_table_get_schema_str_with_ids_pargs {
 public:


  virtual ~ClientService_table_get_schema_str_with_ids_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_get_schema_str_with_ids_result__isset {
  _ClientService_table_get_schema_str_with_ids_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_table_get_schema_str_with_ids_result__isset;

class ClientService_table_get_schema_str_with_ids_result {
 public:

  ClientService_table_get_schema_str_with_ids_result(const ClientService_table_get_schema_str_with_ids_result&);
  ClientService_table_get_schema_str_with_ids_result& operator=(const ClientService_table_get_schema_str_with_ids_result&);
  ClientService_table_get_schema_str_with_ids_result() : success() {
  }

  virtual ~ClientService_table_get_schema_str_with_ids_result() throw();
  std::string success;
  ClientException e;

  _ClientService_table_get_schema_str_with_ids_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_table_get_schema_str_with_ids_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_get_schema_str_with_ids_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_get_schema_str_with_ids_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_get_schema_str_with_ids_presult__isset {
  _ClientService_table_get_schema_str_with_ids_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_table_get_schema_str_with_ids_presult__isset;

class ClientService_table_get_schema_str_with_ids_presult {
 public:


  virtual ~ClientService_table_get_schema_str_with_ids_presult() throw();
  std::string* success;
  ClientException e;

  _ClientService_table_get_schema_str_with_ids_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_get_schema_str_with_ids_args__isset {
  _ClientService_get_schema_str_with_ids_args__isset() : ns(false), table_name(false) {}
  bool ns :1;
  bool table_name :1;
} _ClientService_get_schema_str_with_ids_args__isset;

class ClientService_get_schema_str_with_ids_args {
 public:

  ClientService_get_schema_str_with_ids_args(const ClientService_get_schema_str_with_ids_args&);
  ClientService_get_schema_str_with_ids_args& operator=(const ClientService_get_schema_str_with_ids_args&);
  ClientService_get_schema_str_with_ids_args() : ns(0), table_name() {
  }

  virtual ~ClientService_get_schema_str_with_ids_args() throw();
  Namespace ns;
  std::string table_name;

  _ClientService_get_schema_str_with_ids_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  bool operator == (const ClientService_get_schema_str_with_ids_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_schema_str_with_ids_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_schema_str_with_ids_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_get_schema_str_with_ids_pargs {
 public:


  virtual ~ClientService_get_schema_str_with_ids_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_schema_str_with_ids_result__isset {
  _ClientService_get_schema_str_with_ids_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_schema_str_with_ids_result__isset;

class ClientService_get_schema_str_with_ids_result {
 public:

  ClientService_get_schema_str_with_ids_result(const ClientService_get_schema_str_with_ids_result&);
  ClientService_get_schema_str_with_ids_result& operator=(const ClientService_get_schema_str_with_ids_result&);
  ClientService_get_schema_str_with_ids_result() : success() {
  }

  virtual ~ClientService_get_schema_str_with_ids_result() throw();
  std::string success;
  ClientException e;

  _ClientService_get_schema_str_with_ids_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_get_schema_str_with_ids_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_schema_str_with_ids_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_schema_str_with_ids_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_schema_str_with_ids_presult__isset {
  _ClientService_get_schema_str_with_ids_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_schema_str_with_ids_presult__isset;

class ClientService_get_schema_str_with_ids_presult {
 public:


  virtual ~ClientService_get_schema_str_with_ids_presult() throw();
  std::string* success;
  ClientException e;

  _ClientService_get_schema_str_with_ids_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_table_get_schema_args__isset {
  _ClientService_table_get_schema_args__isset() : ns(false), table_name(false) {}
  bool ns :1;
  bool table_name :1;
} _ClientService_table_get_schema_args__isset;

class ClientService_table_get_schema_args {
 public:

  ClientService_table_get_schema_args(const ClientService_table_get_schema_args&);
  ClientService_table_get_schema_args& operator=(const ClientService_table_get_schema_args&);
  ClientService_table_get_schema_args() : ns(0), table_name() {
  }

  virtual ~ClientService_table_get_schema_args() throw();
  Namespace ns;
  std::string table_name;

  _ClientService_table_get_schema_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  bool operator == (const ClientService_table_get_schema_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_get_schema_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_get_schema_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_table_get_schema_pargs {
 public:


  virtual ~ClientService_table_get_schema_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_get_schema_result__isset {
  _ClientService_table_get_schema_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_table_get_schema_result__isset;

class ClientService_table_get_schema_result {
 public:

  ClientService_table_get_schema_result(const ClientService_table_get_schema_result&);
  ClientService_table_get_schema_result& operator=(const ClientService_table_get_schema_result&);
  ClientService_table_get_schema_result() {
  }

  virtual ~ClientService_table_get_schema_result() throw();
  Schema success;
  ClientException e;

  _ClientService_table_get_schema_result__isset __isset;

  void __set_success(const Schema& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_table_get_schema_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_get_schema_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_get_schema_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_get_schema_presult__isset {
  _ClientService_table_get_schema_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_table_get_schema_presult__isset;

class ClientService_table_get_schema_presult {
 public:


  virtual ~ClientService_table_get_schema_presult() throw();
  Schema* success;
  ClientException e;

  _ClientService_table_get_schema_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_get_schema_args__isset {
  _ClientService_get_schema_args__isset() : ns(false), table_name(false) {}
  bool ns :1;
  bool table_name :1;
} _ClientService_get_schema_args__isset;

class ClientService_get_schema_args {
 public:

  ClientService_get_schema_args(const ClientService_get_schema_args&);
  ClientService_get_schema_args& operator=(const ClientService_get_schema_args&);
  ClientService_get_schema_args() : ns(0), table_name() {
  }

  virtual ~ClientService_get_schema_args() throw();
  Namespace ns;
  std::string table_name;

  _ClientService_get_schema_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  bool operator == (const ClientService_get_schema_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_schema_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_schema_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_get_schema_pargs {
 public:


  virtual ~ClientService_get_schema_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_schema_result__isset {
  _ClientService_get_schema_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_schema_result__isset;

class ClientService_get_schema_result {
 public:

  ClientService_get_schema_result(const ClientService_get_schema_result&);
  ClientService_get_schema_result& operator=(const ClientService_get_schema_result&);
  ClientService_get_schema_result() {
  }

  virtual ~ClientService_get_schema_result() throw();
  Schema success;
  ClientException e;

  _ClientService_get_schema_result__isset __isset;

  void __set_success(const Schema& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_get_schema_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_schema_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_schema_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_schema_presult__isset {
  _ClientService_get_schema_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_schema_presult__isset;

class ClientService_get_schema_presult {
 public:


  virtual ~ClientService_get_schema_presult() throw();
  Schema* success;
  ClientException e;

  _ClientService_get_schema_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_get_tables_args__isset {
  _ClientService_get_tables_args__isset() : ns(false) {}
  bool ns :1;
} _ClientService_get_tables_args__isset;

class ClientService_get_tables_args {
 public:

  ClientService_get_tables_args(const ClientService_get_tables_args&);
  ClientService_get_tables_args& operator=(const ClientService_get_tables_args&);
  ClientService_get_tables_args() : ns(0) {
  }

  virtual ~ClientService_get_tables_args() throw();
  Namespace ns;

  _ClientService_get_tables_args__isset __isset;

  void __set_ns(const Namespace val);

  bool operator == (const ClientService_get_tables_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_tables_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_tables_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_get_tables_pargs {
 public:


  virtual ~ClientService_get_tables_pargs() throw();
  const Namespace* ns;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_tables_result__isset {
  _ClientService_get_tables_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_tables_result__isset;

class ClientService_get_tables_result {
 public:

  ClientService_get_tables_result(const ClientService_get_tables_result&);
  ClientService_get_tables_result& operator=(const ClientService_get_tables_result&);
  ClientService_get_tables_result() {
  }

  virtual ~ClientService_get_tables_result() throw();
  std::vector<std::string>  success;
  ClientException e;

  _ClientService_get_tables_result__isset __isset;

  void __set_success(const std::vector<std::string> & val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_get_tables_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_tables_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_tables_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_tables_presult__isset {
  _ClientService_get_tables_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_tables_presult__isset;

class ClientService_get_tables_presult {
 public:


  virtual ~ClientService_get_tables_presult() throw();
  std::vector<std::string> * success;
  ClientException e;

  _ClientService_get_tables_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_namespace_get_listing_args__isset {
  _ClientService_namespace_get_listing_args__isset() : ns(false) {}
  bool ns :1;
} _ClientService_namespace_get_listing_args__isset;

class ClientService_namespace_get_listing_args {
 public:

  ClientService_namespace_get_listing_args(const ClientService_namespace_get_listing_args&);
  ClientService_namespace_get_listing_args& operator=(const ClientService_namespace_get_listing_args&);
  ClientService_namespace_get_listing_args() : ns(0) {
  }

  virtual ~ClientService_namespace_get_listing_args() throw();
  Namespace ns;

  _ClientService_namespace_get_listing_args__isset __isset;

  void __set_ns(const Namespace val);

  bool operator == (const ClientService_namespace_get_listing_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const ClientService_namespace_get_listing_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_namespace_get_listing_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_namespace_get_listing_pargs {
 public:


  virtual ~ClientService_namespace_get_listing_pargs() throw();
  const Namespace* ns;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_namespace_get_listing_result__isset {
  _ClientService_namespace_get_listing_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_namespace_get_listing_result__isset;

class ClientService_namespace_get_listing_result {
 public:

  ClientService_namespace_get_listing_result(const ClientService_namespace_get_listing_result&);
  ClientService_namespace_get_listing_result& operator=(const ClientService_namespace_get_listing_result&);
  ClientService_namespace_get_listing_result() {
  }

  virtual ~ClientService_namespace_get_listing_result() throw();
  std::vector<NamespaceListing>  success;
  ClientException e;

  _ClientService_namespace_get_listing_result__isset __isset;

  void __set_success(const std::vector<NamespaceListing> & val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_namespace_get_listing_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_namespace_get_listing_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_namespace_get_listing_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_namespace_get_listing_presult__isset {
  _ClientService_namespace_get_listing_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_namespace_get_listing_presult__isset;

class ClientService_namespace_get_listing_presult {
 public:


  virtual ~ClientService_namespace_get_listing_presult() throw();
  std::vector<NamespaceListing> * success;
  ClientException e;

  _ClientService_namespace_get_listing_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_get_listing_args__isset {
  _ClientService_get_listing_args__isset() : ns(false) {}
  bool ns :1;
} _ClientService_get_listing_args__isset;

class ClientService_get_listing_args {
 public:

  ClientService_get_listing_args(const ClientService_get_listing_args&);
  ClientService_get_listing_args& operator=(const ClientService_get_listing_args&);
  ClientService_get_listing_args() : ns(0) {
  }

  virtual ~ClientService_get_listing_args() throw();
  Namespace ns;

  _ClientService_get_listing_args__isset __isset;

  void __set_ns(const Namespace val);

  bool operator == (const ClientService_get_listing_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_listing_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_listing_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_get_listing_pargs {
 public:


  virtual ~ClientService_get_listing_pargs() throw();
  const Namespace* ns;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_listing_result__isset {
  _ClientService_get_listing_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_listing_result__isset;

class ClientService_get_listing_result {
 public:

  ClientService_get_listing_result(const ClientService_get_listing_result&);
  ClientService_get_listing_result& operator=(const ClientService_get_listing_result&);
  ClientService_get_listing_result() {
  }

  virtual ~ClientService_get_listing_result() throw();
  std::vector<NamespaceListing>  success;
  ClientException e;

  _ClientService_get_listing_result__isset __isset;

  void __set_success(const std::vector<NamespaceListing> & val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_get_listing_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_listing_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_listing_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_listing_presult__isset {
  _ClientService_get_listing_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_listing_presult__isset;

class ClientService_get_listing_presult {
 public:


  virtual ~ClientService_get_listing_presult() throw();
  std::vector<NamespaceListing> * success;
  ClientException e;

  _ClientService_get_listing_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_table_get_splits_args__isset {
  _ClientService_table_get_splits_args__isset() : ns(false), table_name(false) {}
  bool ns :1;
  bool table_name :1;
} _ClientService_table_get_splits_args__isset;

class ClientService_table_get_splits_args {
 public:

  ClientService_table_get_splits_args(const ClientService_table_get_splits_args&);
  ClientService_table_get_splits_args& operator=(const ClientService_table_get_splits_args&);
  ClientService_table_get_splits_args() : ns(0), table_name() {
  }

  virtual ~ClientService_table_get_splits_args() throw();
  Namespace ns;
  std::string table_name;

  _ClientService_table_get_splits_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  bool operator == (const ClientService_table_get_splits_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_get_splits_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_get_splits_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_table_get_splits_pargs {
 public:


  virtual ~ClientService_table_get_splits_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_get_splits_result__isset {
  _ClientService_table_get_splits_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_table_get_splits_result__isset;

class ClientService_table_get_splits_result {
 public:

  ClientService_table_get_splits_result(const ClientService_table_get_splits_result&);
  ClientService_table_get_splits_result& operator=(const ClientService_table_get_splits_result&);
  ClientService_table_get_splits_result() {
  }

  virtual ~ClientService_table_get_splits_result() throw();
  std::vector<TableSplit>  success;
  ClientException e;

  _ClientService_table_get_splits_result__isset __isset;

  void __set_success(const std::vector<TableSplit> & val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_table_get_splits_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_get_splits_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_get_splits_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_get_splits_presult__isset {
  _ClientService_table_get_splits_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_table_get_splits_presult__isset;

class ClientService_table_get_splits_presult {
 public:


  virtual ~ClientService_table_get_splits_presult() throw();
  std::vector<TableSplit> * success;
  ClientException e;

  _ClientService_table_get_splits_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_get_table_splits_args__isset {
  _ClientService_get_table_splits_args__isset() : ns(false), table_name(false) {}
  bool ns :1;
  bool table_name :1;
} _ClientService_get_table_splits_args__isset;

class ClientService_get_table_splits_args {
 public:

  ClientService_get_table_splits_args(const ClientService_get_table_splits_args&);
  ClientService_get_table_splits_args& operator=(const ClientService_get_table_splits_args&);
  ClientService_get_table_splits_args() : ns(0), table_name() {
  }

  virtual ~ClientService_get_table_splits_args() throw();
  Namespace ns;
  std::string table_name;

  _ClientService_get_table_splits_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  bool operator == (const ClientService_get_table_splits_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_table_splits_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_table_splits_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_get_table_splits_pargs {
 public:


  virtual ~ClientService_get_table_splits_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_table_splits_result__isset {
  _ClientService_get_table_splits_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_table_splits_result__isset;

class ClientService_get_table_splits_result {
 public:

  ClientService_get_table_splits_result(const ClientService_get_table_splits_result&);
  ClientService_get_table_splits_result& operator=(const ClientService_get_table_splits_result&);
  ClientService_get_table_splits_result() {
  }

  virtual ~ClientService_get_table_splits_result() throw();
  std::vector<TableSplit>  success;
  ClientException e;

  _ClientService_get_table_splits_result__isset __isset;

  void __set_success(const std::vector<TableSplit> & val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_get_table_splits_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_get_table_splits_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_get_table_splits_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_get_table_splits_presult__isset {
  _ClientService_get_table_splits_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_get_table_splits_presult__isset;

class ClientService_get_table_splits_presult {
 public:


  virtual ~ClientService_get_table_splits_presult() throw();
  std::vector<TableSplit> * success;
  ClientException e;

  _ClientService_get_table_splits_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_namespace_drop_args__isset {
  _ClientService_namespace_drop_args__isset() : ns(false), if_exists(true) {}
  bool ns :1;
  bool if_exists :1;
} _ClientService_namespace_drop_args__isset;

class ClientService_namespace_drop_args {
 public:

  ClientService_namespace_drop_args(const ClientService_namespace_drop_args&);
  ClientService_namespace_drop_args& operator=(const ClientService_namespace_drop_args&);
  ClientService_namespace_drop_args() : ns(), if_exists(true) {
  }

  virtual ~ClientService_namespace_drop_args() throw();
  std::string ns;
  bool if_exists;

  _ClientService_namespace_drop_args__isset __isset;

  void __set_ns(const std::string& val);

  void __set_if_exists(const bool val);

  bool operator == (const ClientService_namespace_drop_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(if_exists == rhs.if_exists))
      return false;
    return true;
  }
  bool operator != (const ClientService_namespace_drop_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_namespace_drop_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_namespace_drop_pargs {
 public:


  virtual ~ClientService_namespace_drop_pargs() throw();
  const std::string* ns;
  const bool* if_exists;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_namespace_drop_result__isset {
  _ClientService_namespace_drop_result__isset() : e(false) {}
  bool e :1;
} _ClientService_namespace_drop_result__isset;

class ClientService_namespace_drop_result {
 public:

  ClientService_namespace_drop_result(const ClientService_namespace_drop_result&);
  ClientService_namespace_drop_result& operator=(const ClientService_namespace_drop_result&);
  ClientService_namespace_drop_result() {
  }

  virtual ~ClientService_namespace_drop_result() throw();
  ClientException e;

  _ClientService_namespace_drop_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_namespace_drop_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_namespace_drop_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_namespace_drop_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_namespace_drop_presult__isset {
  _ClientService_namespace_drop_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_namespace_drop_presult__isset;

class ClientService_namespace_drop_presult {
 public:


  virtual ~ClientService_namespace_drop_presult() throw();
  ClientException e;

  _ClientService_namespace_drop_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_drop_namespace_args__isset {
  _ClientService_drop_namespace_args__isset() : ns(false), if_exists(true) {}
  bool ns :1;
  bool if_exists :1;
} _ClientService_drop_namespace_args__isset;

class ClientService_drop_namespace_args {
 public:

  ClientService_drop_namespace_args(const ClientService_drop_namespace_args&);
  ClientService_drop_namespace_args& operator=(const ClientService_drop_namespace_args&);
  ClientService_drop_namespace_args() : ns(), if_exists(true) {
  }

  virtual ~ClientService_drop_namespace_args() throw();
  std::string ns;
  bool if_exists;

  _ClientService_drop_namespace_args__isset __isset;

  void __set_ns(const std::string& val);

  void __set_if_exists(const bool val);

  bool operator == (const ClientService_drop_namespace_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(if_exists == rhs.if_exists))
      return false;
    return true;
  }
  bool operator != (const ClientService_drop_namespace_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_drop_namespace_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_drop_namespace_pargs {
 public:


  virtual ~ClientService_drop_namespace_pargs() throw();
  const std::string* ns;
  const bool* if_exists;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_drop_namespace_result__isset {
  _ClientService_drop_namespace_result__isset() : e(false) {}
  bool e :1;
} _ClientService_drop_namespace_result__isset;

class ClientService_drop_namespace_result {
 public:

  ClientService_drop_namespace_result(const ClientService_drop_namespace_result&);
  ClientService_drop_namespace_result& operator=(const ClientService_drop_namespace_result&);
  ClientService_drop_namespace_result() {
  }

  virtual ~ClientService_drop_namespace_result() throw();
  ClientException e;

  _ClientService_drop_namespace_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_drop_namespace_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_drop_namespace_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_drop_namespace_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_drop_namespace_presult__isset {
  _ClientService_drop_namespace_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_drop_namespace_presult__isset;

class ClientService_drop_namespace_presult {
 public:


  virtual ~ClientService_drop_namespace_presult() throw();
  ClientException e;

  _ClientService_drop_namespace_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_rename_table_args__isset {
  _ClientService_rename_table_args__isset() : ns(false), name(false), new_name(false) {}
  bool ns :1;
  bool name :1;
  bool new_name :1;
} _ClientService_rename_table_args__isset;

class ClientService_rename_table_args {
 public:

  ClientService_rename_table_args(const ClientService_rename_table_args&);
  ClientService_rename_table_args& operator=(const ClientService_rename_table_args&);
  ClientService_rename_table_args() : ns(0), name(), new_name() {
  }

  virtual ~ClientService_rename_table_args() throw();
  Namespace ns;
  std::string name;
  std::string new_name;

  _ClientService_rename_table_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_name(const std::string& val);

  void __set_new_name(const std::string& val);

  bool operator == (const ClientService_rename_table_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(new_name == rhs.new_name))
      return false;
    return true;
  }
  bool operator != (const ClientService_rename_table_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_rename_table_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_rename_table_pargs {
 public:


  virtual ~ClientService_rename_table_pargs() throw();
  const Namespace* ns;
  const std::string* name;
  const std::string* new_name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_rename_table_result__isset {
  _ClientService_rename_table_result__isset() : e(false) {}
  bool e :1;
} _ClientService_rename_table_result__isset;

class ClientService_rename_table_result {
 public:

  ClientService_rename_table_result(const ClientService_rename_table_result&);
  ClientService_rename_table_result& operator=(const ClientService_rename_table_result&);
  ClientService_rename_table_result() {
  }

  virtual ~ClientService_rename_table_result() throw();
  ClientException e;

  _ClientService_rename_table_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_rename_table_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_rename_table_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_rename_table_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_rename_table_presult__isset {
  _ClientService_rename_table_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_rename_table_presult__isset;

class ClientService_rename_table_presult {
 public:


  virtual ~ClientService_rename_table_presult() throw();
  ClientException e;

  _ClientService_rename_table_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_table_rename_args__isset {
  _ClientService_table_rename_args__isset() : ns(false), name(false), new_name(false) {}
  bool ns :1;
  bool name :1;
  bool new_name :1;
} _ClientService_table_rename_args__isset;

class ClientService_table_rename_args {
 public:

  ClientService_table_rename_args(const ClientService_table_rename_args&);
  ClientService_table_rename_args& operator=(const ClientService_table_rename_args&);
  ClientService_table_rename_args() : ns(0), name(), new_name() {
  }

  virtual ~ClientService_table_rename_args() throw();
  Namespace ns;
  std::string name;
  std::string new_name;

  _ClientService_table_rename_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_name(const std::string& val);

  void __set_new_name(const std::string& val);

  bool operator == (const ClientService_table_rename_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(new_name == rhs.new_name))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_rename_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_rename_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_table_rename_pargs {
 public:


  virtual ~ClientService_table_rename_pargs() throw();
  const Namespace* ns;
  const std::string* name;
  const std::string* new_name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_rename_result__isset {
  _ClientService_table_rename_result__isset() : e(false) {}
  bool e :1;
} _ClientService_table_rename_result__isset;

class ClientService_table_rename_result {
 public:

  ClientService_table_rename_result(const ClientService_table_rename_result&);
  ClientService_table_rename_result& operator=(const ClientService_table_rename_result&);
  ClientService_table_rename_result() {
  }

  virtual ~ClientService_table_rename_result() throw();
  ClientException e;

  _ClientService_table_rename_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_table_rename_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_rename_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_rename_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_rename_presult__isset {
  _ClientService_table_rename_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_table_rename_presult__isset;

class ClientService_table_rename_presult {
 public:


  virtual ~ClientService_table_rename_presult() throw();
  ClientException e;

  _ClientService_table_rename_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_drop_table_args__isset {
  _ClientService_drop_table_args__isset() : ns(false), name(false), if_exists(true) {}
  bool ns :1;
  bool name :1;
  bool if_exists :1;
} _ClientService_drop_table_args__isset;

class ClientService_drop_table_args {
 public:

  ClientService_drop_table_args(const ClientService_drop_table_args&);
  ClientService_drop_table_args& operator=(const ClientService_drop_table_args&);
  ClientService_drop_table_args() : ns(0), name(), if_exists(true) {
  }

  virtual ~ClientService_drop_table_args() throw();
  Namespace ns;
  std::string name;
  bool if_exists;

  _ClientService_drop_table_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_name(const std::string& val);

  void __set_if_exists(const bool val);

  bool operator == (const ClientService_drop_table_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(if_exists == rhs.if_exists))
      return false;
    return true;
  }
  bool operator != (const ClientService_drop_table_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_drop_table_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_drop_table_pargs {
 public:


  virtual ~ClientService_drop_table_pargs() throw();
  const Namespace* ns;
  const std::string* name;
  const bool* if_exists;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_drop_table_result__isset {
  _ClientService_drop_table_result__isset() : e(false) {}
  bool e :1;
} _ClientService_drop_table_result__isset;

class ClientService_drop_table_result {
 public:

  ClientService_drop_table_result(const ClientService_drop_table_result&);
  ClientService_drop_table_result& operator=(const ClientService_drop_table_result&);
  ClientService_drop_table_result() {
  }

  virtual ~ClientService_drop_table_result() throw();
  ClientException e;

  _ClientService_drop_table_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_drop_table_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_drop_table_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_drop_table_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_drop_table_presult__isset {
  _ClientService_drop_table_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_drop_table_presult__isset;

class ClientService_drop_table_presult {
 public:


  virtual ~ClientService_drop_table_presult() throw();
  ClientException e;

  _ClientService_drop_table_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_table_drop_args__isset {
  _ClientService_table_drop_args__isset() : ns(false), name(false), if_exists(true) {}
  bool ns :1;
  bool name :1;
  bool if_exists :1;
} _ClientService_table_drop_args__isset;

class ClientService_table_drop_args {
 public:

  ClientService_table_drop_args(const ClientService_table_drop_args&);
  ClientService_table_drop_args& operator=(const ClientService_table_drop_args&);
  ClientService_table_drop_args() : ns(0), name(), if_exists(true) {
  }

  virtual ~ClientService_table_drop_args() throw();
  Namespace ns;
  std::string name;
  bool if_exists;

  _ClientService_table_drop_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_name(const std::string& val);

  void __set_if_exists(const bool val);

  bool operator == (const ClientService_table_drop_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(if_exists == rhs.if_exists))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_drop_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_drop_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_table_drop_pargs {
 public:


  virtual ~ClientService_table_drop_pargs() throw();
  const Namespace* ns;
  const std::string* name;
  const bool* if_exists;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_drop_result__isset {
  _ClientService_table_drop_result__isset() : e(false) {}
  bool e :1;
} _ClientService_table_drop_result__isset;

class ClientService_table_drop_result {
 public:

  ClientService_table_drop_result(const ClientService_table_drop_result&);
  ClientService_table_drop_result& operator=(const ClientService_table_drop_result&);
  ClientService_table_drop_result() {
  }

  virtual ~ClientService_table_drop_result() throw();
  ClientException e;

  _ClientService_table_drop_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_table_drop_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_table_drop_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_table_drop_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_table_drop_presult__isset {
  _ClientService_table_drop_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_table_drop_presult__isset;

class ClientService_table_drop_presult {
 public:


  virtual ~ClientService_table_drop_presult() throw();
  ClientException e;

  _ClientService_table_drop_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class ClientService_generate_guid_args {
 public:

  ClientService_generate_guid_args(const ClientService_generate_guid_args&);
  ClientService_generate_guid_args& operator=(const ClientService_generate_guid_args&);
  ClientService_generate_guid_args() {
  }

  virtual ~ClientService_generate_guid_args() throw();

  bool operator == (const ClientService_generate_guid_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ClientService_generate_guid_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_generate_guid_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_generate_guid_pargs {
 public:


  virtual ~ClientService_generate_guid_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_generate_guid_result__isset {
  _ClientService_generate_guid_result__isset() : success(false) {}
  bool success :1;
} _ClientService_generate_guid_result__isset;

class ClientService_generate_guid_result {
 public:

  ClientService_generate_guid_result(const ClientService_generate_guid_result&);
  ClientService_generate_guid_result& operator=(const ClientService_generate_guid_result&);
  ClientService_generate_guid_result() : success() {
  }

  virtual ~ClientService_generate_guid_result() throw();
  std::string success;

  _ClientService_generate_guid_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const ClientService_generate_guid_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ClientService_generate_guid_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_generate_guid_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_generate_guid_presult__isset {
  _ClientService_generate_guid_presult__isset() : success(false) {}
  bool success :1;
} _ClientService_generate_guid_presult__isset;

class ClientService_generate_guid_presult {
 public:


  virtual ~ClientService_generate_guid_presult() throw();
  std::string* success;

  _ClientService_generate_guid_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_create_cell_unique_args__isset {
  _ClientService_create_cell_unique_args__isset() : ns(false), table_name(false), key(false), value(false) {}
  bool ns :1;
  bool table_name :1;
  bool key :1;
  bool value :1;
} _ClientService_create_cell_unique_args__isset;

class ClientService_create_cell_unique_args {
 public:

  ClientService_create_cell_unique_args(const ClientService_create_cell_unique_args&);
  ClientService_create_cell_unique_args& operator=(const ClientService_create_cell_unique_args&);
  ClientService_create_cell_unique_args() : ns(0), table_name(), value() {
  }

  virtual ~ClientService_create_cell_unique_args() throw();
  Namespace ns;
  std::string table_name;
  Key key;
  std::string value;

  _ClientService_create_cell_unique_args__isset __isset;

  void __set_ns(const Namespace val);

  void __set_table_name(const std::string& val);

  void __set_key(const Key& val);

  void __set_value(const std::string& val);

  bool operator == (const ClientService_create_cell_unique_args & rhs) const
  {
    if (!(ns == rhs.ns))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(key == rhs.key))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const ClientService_create_cell_unique_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_create_cell_unique_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_create_cell_unique_pargs {
 public:


  virtual ~ClientService_create_cell_unique_pargs() throw();
  const Namespace* ns;
  const std::string* table_name;
  const Key* key;
  const std::string* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_create_cell_unique_result__isset {
  _ClientService_create_cell_unique_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_create_cell_unique_result__isset;

class ClientService_create_cell_unique_result {
 public:

  ClientService_create_cell_unique_result(const ClientService_create_cell_unique_result&);
  ClientService_create_cell_unique_result& operator=(const ClientService_create_cell_unique_result&);
  ClientService_create_cell_unique_result() : success() {
  }

  virtual ~ClientService_create_cell_unique_result() throw();
  std::string success;
  ClientException e;

  _ClientService_create_cell_unique_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_create_cell_unique_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_create_cell_unique_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_create_cell_unique_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_create_cell_unique_presult__isset {
  _ClientService_create_cell_unique_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_create_cell_unique_presult__isset;

class ClientService_create_cell_unique_presult {
 public:


  virtual ~ClientService_create_cell_unique_presult() throw();
  std::string* success;
  ClientException e;

  _ClientService_create_cell_unique_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ClientService_error_get_text_args__isset {
  _ClientService_error_get_text_args__isset() : error_code(false) {}
  bool error_code :1;
} _ClientService_error_get_text_args__isset;

class ClientService_error_get_text_args {
 public:

  ClientService_error_get_text_args(const ClientService_error_get_text_args&);
  ClientService_error_get_text_args& operator=(const ClientService_error_get_text_args&);
  ClientService_error_get_text_args() : error_code(0) {
  }

  virtual ~ClientService_error_get_text_args() throw();
  int32_t error_code;

  _ClientService_error_get_text_args__isset __isset;

  void __set_error_code(const int32_t val);

  bool operator == (const ClientService_error_get_text_args & rhs) const
  {
    if (!(error_code == rhs.error_code))
      return false;
    return true;
  }
  bool operator != (const ClientService_error_get_text_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_error_get_text_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_error_get_text_pargs {
 public:


  virtual ~ClientService_error_get_text_pargs() throw();
  const int32_t* error_code;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_error_get_text_result__isset {
  _ClientService_error_get_text_result__isset() : success(false) {}
  bool success :1;
} _ClientService_error_get_text_result__isset;

class ClientService_error_get_text_result {
 public:

  ClientService_error_get_text_result(const ClientService_error_get_text_result&);
  ClientService_error_get_text_result& operator=(const ClientService_error_get_text_result&);
  ClientService_error_get_text_result() : success() {
  }

  virtual ~ClientService_error_get_text_result() throw();
  std::string success;

  _ClientService_error_get_text_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const ClientService_error_get_text_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ClientService_error_get_text_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_error_get_text_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_error_get_text_presult__isset {
  _ClientService_error_get_text_presult__isset() : success(false) {}
  bool success :1;
} _ClientService_error_get_text_presult__isset;

class ClientService_error_get_text_presult {
 public:


  virtual ~ClientService_error_get_text_presult() throw();
  std::string* success;

  _ClientService_error_get_text_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class ClientService_status_args {
 public:

  ClientService_status_args(const ClientService_status_args&);
  ClientService_status_args& operator=(const ClientService_status_args&);
  ClientService_status_args() {
  }

  virtual ~ClientService_status_args() throw();

  bool operator == (const ClientService_status_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ClientService_status_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_status_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_status_pargs {
 public:


  virtual ~ClientService_status_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_status_result__isset {
  _ClientService_status_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_status_result__isset;

class ClientService_status_result {
 public:

  ClientService_status_result(const ClientService_status_result&);
  ClientService_status_result& operator=(const ClientService_status_result&);
  ClientService_status_result() {
  }

  virtual ~ClientService_status_result() throw();
  Status success;
  ClientException e;

  _ClientService_status_result__isset __isset;

  void __set_success(const Status& val);

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_status_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_status_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_status_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_status_presult__isset {
  _ClientService_status_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _ClientService_status_presult__isset;

class ClientService_status_presult {
 public:


  virtual ~ClientService_status_presult() throw();
  Status* success;
  ClientException e;

  _ClientService_status_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class ClientService_shutdown_args {
 public:

  ClientService_shutdown_args(const ClientService_shutdown_args&);
  ClientService_shutdown_args& operator=(const ClientService_shutdown_args&);
  ClientService_shutdown_args() {
  }

  virtual ~ClientService_shutdown_args() throw();

  bool operator == (const ClientService_shutdown_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ClientService_shutdown_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_shutdown_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ClientService_shutdown_pargs {
 public:


  virtual ~ClientService_shutdown_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_shutdown_result__isset {
  _ClientService_shutdown_result__isset() : e(false) {}
  bool e :1;
} _ClientService_shutdown_result__isset;

class ClientService_shutdown_result {
 public:

  ClientService_shutdown_result(const ClientService_shutdown_result&);
  ClientService_shutdown_result& operator=(const ClientService_shutdown_result&);
  ClientService_shutdown_result() {
  }

  virtual ~ClientService_shutdown_result() throw();
  ClientException e;

  _ClientService_shutdown_result__isset __isset;

  void __set_e(const ClientException& val);

  bool operator == (const ClientService_shutdown_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const ClientService_shutdown_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientService_shutdown_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ClientService_shutdown_presult__isset {
  _ClientService_shutdown_presult__isset() : e(false) {}
  bool e :1;
} _ClientService_shutdown_presult__isset;

class ClientService_shutdown_presult {
 public:


  virtual ~ClientService_shutdown_presult() throw();
  ClientException e;

  _ClientService_shutdown_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class ClientServiceClient : virtual public ClientServiceIf {
 public:
  ClientServiceClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  ClientServiceClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void namespace_create(const std::string& ns);
  void send_namespace_create(const std::string& ns);
  void recv_namespace_create();
  void create_namespace(const std::string& ns);
  void send_create_namespace(const std::string& ns);
  void recv_create_namespace();
  void table_create(const Namespace ns, const std::string& table_name, const Schema& schema);
  void send_table_create(const Namespace ns, const std::string& table_name, const Schema& schema);
  void recv_table_create();
  void table_alter(const Namespace ns, const std::string& table_name, const Schema& schema);
  void send_table_alter(const Namespace ns, const std::string& table_name, const Schema& schema);
  void recv_table_alter();
  void refresh_table(const Namespace ns, const std::string& table_name);
  void send_refresh_table(const Namespace ns, const std::string& table_name);
  void recv_refresh_table();
  Namespace namespace_open(const std::string& ns);
  void send_namespace_open(const std::string& ns);
  Namespace recv_namespace_open();
  Namespace open_namespace(const std::string& ns);
  void send_open_namespace(const std::string& ns);
  Namespace recv_open_namespace();
  void namespace_close(const Namespace ns);
  void send_namespace_close(const Namespace ns);
  void recv_namespace_close();
  void close_namespace(const Namespace ns);
  void send_close_namespace(const Namespace ns);
  void recv_close_namespace();
  Future future_open(const int32_t capacity);
  void send_future_open(const int32_t capacity);
  Future recv_future_open();
  Future open_future(const int32_t capacity);
  void send_open_future(const int32_t capacity);
  Future recv_open_future();
  void future_cancel(const Future ff);
  void send_future_cancel(const Future ff);
  void recv_future_cancel();
  void cancel_future(const Future ff);
  void send_cancel_future(const Future ff);
  void recv_cancel_future();
  void future_get_result(Result& _return, const Future ff, const int32_t timeout_millis);
  void send_future_get_result(const Future ff, const int32_t timeout_millis);
  void recv_future_get_result(Result& _return);
  void get_future_result(Result& _return, const Future ff, const int32_t timeout_millis);
  void send_get_future_result(const Future ff, const int32_t timeout_millis);
  void recv_get_future_result(Result& _return);
  void future_get_result_as_arrays(ResultAsArrays& _return, const Future ff, const int32_t timeout_millis);
  void send_future_get_result_as_arrays(const Future ff, const int32_t timeout_millis);
  void recv_future_get_result_as_arrays(ResultAsArrays& _return);
  void get_future_result_as_arrays(ResultAsArrays& _return, const Future ff, const int32_t timeout_millis);
  void send_get_future_result_as_arrays(const Future ff, const int32_t timeout_millis);
  void recv_get_future_result_as_arrays(ResultAsArrays& _return);
  void future_get_result_serialized(ResultSerialized& _return, const Future ff, const int32_t timeout_millis);
  void send_future_get_result_serialized(const Future ff, const int32_t timeout_millis);
  void recv_future_get_result_serialized(ResultSerialized& _return);
  void get_future_result_serialized(ResultSerialized& _return, const Future ff, const int32_t timeout_millis);
  void send_get_future_result_serialized(const Future ff, const int32_t timeout_millis);
  void recv_get_future_result_serialized(ResultSerialized& _return);
  bool future_is_empty(const Future ff);
  void send_future_is_empty(const Future ff);
  bool recv_future_is_empty();
  bool future_is_full(const Future ff);
  void send_future_is_full(const Future ff);
  bool recv_future_is_full();
  bool future_is_cancelled(const Future ff);
  void send_future_is_cancelled(const Future ff);
  bool recv_future_is_cancelled();
  bool future_has_outstanding(const Future ff);
  void send_future_has_outstanding(const Future ff);
  bool recv_future_has_outstanding();
  void future_close(const Future ff);
  void send_future_close(const Future ff);
  void recv_future_close();
  void close_future(const Future ff);
  void send_close_future(const Future ff);
  void recv_close_future();
  Scanner scanner_open(const Namespace ns, const std::string& table_name, const ScanSpec& scan_spec);
  void send_scanner_open(const Namespace ns, const std::string& table_name, const ScanSpec& scan_spec);
  Scanner recv_scanner_open();
  Scanner open_scanner(const Namespace ns, const std::string& table_name, const ScanSpec& scan_spec);
  void send_open_scanner(const Namespace ns, const std::string& table_name, const ScanSpec& scan_spec);
  Scanner recv_open_scanner();
  ScannerAsync async_scanner_open(const Namespace ns, const std::string& table_name, const Future future, const ScanSpec& scan_spec);
  void send_async_scanner_open(const Namespace ns, const std::string& table_name, const Future future, const ScanSpec& scan_spec);
  ScannerAsync recv_async_scanner_open();
  ScannerAsync open_scanner_async(const Namespace ns, const std::string& table_name, const Future future, const ScanSpec& scan_spec);
  void send_open_scanner_async(const Namespace ns, const std::string& table_name, const Future future, const ScanSpec& scan_spec);
  ScannerAsync recv_open_scanner_async();
  void scanner_close(const Scanner scanner);
  void send_scanner_close(const Scanner scanner);
  void recv_scanner_close();
  void close_scanner(const Scanner scanner);
  void send_close_scanner(const Scanner scanner);
  void recv_close_scanner();
  void async_scanner_cancel(const ScannerAsync scanner);
  void send_async_scanner_cancel(const ScannerAsync scanner);
  void recv_async_scanner_cancel();
  void cancel_scanner_async(const ScannerAsync scanner);
  void send_cancel_scanner_async(const ScannerAsync scanner);
  void recv_cancel_scanner_async();
  void async_scanner_close(const ScannerAsync scanner);
  void send_async_scanner_close(const ScannerAsync scanner);
  void recv_async_scanner_close();
  void close_scanner_async(const ScannerAsync scanner);
  void send_close_scanner_async(const ScannerAsync scanner);
  void recv_close_scanner_async();
  void scanner_get_cells(std::vector<Cell> & _return, const Scanner scanner);
  void send_scanner_get_cells(const Scanner scanner);
  void recv_scanner_get_cells(std::vector<Cell> & _return);
  void next_cells(std::vector<Cell> & _return, const Scanner scanner);
  void send_next_cells(const Scanner scanner);
  void recv_next_cells(std::vector<Cell> & _return);
  void scanner_get_cells_as_arrays(std::vector<CellAsArray> & _return, const Scanner scanner);
  void send_scanner_get_cells_as_arrays(const Scanner scanner);
  void recv_scanner_get_cells_as_arrays(std::vector<CellAsArray> & _return);
  void next_cells_as_arrays(std::vector<CellAsArray> & _return, const Scanner scanner);
  void send_next_cells_as_arrays(const Scanner scanner);
  void recv_next_cells_as_arrays(std::vector<CellAsArray> & _return);
  void scanner_get_cells_serialized(CellsSerialized& _return, const Scanner scanner);
  void send_scanner_get_cells_serialized(const Scanner scanner);
  void recv_scanner_get_cells_serialized(CellsSerialized& _return);
  void next_cells_serialized(CellsSerialized& _return, const Scanner scanner);
  void send_next_cells_serialized(const Scanner scanner);
  void recv_next_cells_serialized(CellsSerialized& _return);
  void scanner_get_row(std::vector<Cell> & _return, const Scanner scanner);
  void send_scanner_get_row(const Scanner scanner);
  void recv_scanner_get_row(std::vector<Cell> & _return);
  void next_row(std::vector<Cell> & _return, const Scanner scanner);
  void send_next_row(const Scanner scanner);
  void recv_next_row(std::vector<Cell> & _return);
  void scanner_get_row_as_arrays(std::vector<CellAsArray> & _return, const Scanner scanner);
  void send_scanner_get_row_as_arrays(const Scanner scanner);
  void recv_scanner_get_row_as_arrays(std::vector<CellAsArray> & _return);
  void next_row_as_arrays(std::vector<CellAsArray> & _return, const Scanner scanner);
  void send_next_row_as_arrays(const Scanner scanner);
  void recv_next_row_as_arrays(std::vector<CellAsArray> & _return);
  void scanner_get_row_serialized(CellsSerialized& _return, const Scanner scanner);
  void send_scanner_get_row_serialized(const Scanner scanner);
  void recv_scanner_get_row_serialized(CellsSerialized& _return);
  void next_row_serialized(CellsSerialized& _return, const Scanner scanner);
  void send_next_row_serialized(const Scanner scanner);
  void recv_next_row_serialized(CellsSerialized& _return);
  void get_row(std::vector<Cell> & _return, const Namespace ns, const std::string& table_name, const std::string& row);
  void send_get_row(const Namespace ns, const std::string& table_name, const std::string& row);
  void recv_get_row(std::vector<Cell> & _return);
  void get_row_as_arrays(std::vector<CellAsArray> & _return, const Namespace ns, const std::string& name, const std::string& row);
  void send_get_row_as_arrays(const Namespace ns, const std::string& name, const std::string& row);
  void recv_get_row_as_arrays(std::vector<CellAsArray> & _return);
  void get_row_serialized(CellsSerialized& _return, const Namespace ns, const std::string& table_name, const std::string& row);
  void send_get_row_serialized(const Namespace ns, const std::string& table_name, const std::string& row);
  void recv_get_row_serialized(CellsSerialized& _return);
  void get_cell(Value& _return, const Namespace ns, const std::string& table_name, const std::string& row, const std::string& column);
  void send_get_cell(const Namespace ns, const std::string& table_name, const std::string& row, const std::string& column);
  void recv_get_cell(Value& _return);
  void get_cells(std::vector<Cell> & _return, const Namespace ns, const std::string& table_name, const ScanSpec& scan_spec);
  void send_get_cells(const Namespace ns, const std::string& table_name, const ScanSpec& scan_spec);
  void recv_get_cells(std::vector<Cell> & _return);
  void get_cells_as_arrays(std::vector<CellAsArray> & _return, const Namespace ns, const std::string& name, const ScanSpec& scan_spec);
  void send_get_cells_as_arrays(const Namespace ns, const std::string& name, const ScanSpec& scan_spec);
  void recv_get_cells_as_arrays(std::vector<CellAsArray> & _return);
  void get_cells_serialized(CellsSerialized& _return, const Namespace ns, const std::string& name, const ScanSpec& scan_spec);
  void send_get_cells_serialized(const Namespace ns, const std::string& name, const ScanSpec& scan_spec);
  void recv_get_cells_serialized(CellsSerialized& _return);
  void shared_mutator_refresh(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec);
  void send_shared_mutator_refresh(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec);
  void recv_shared_mutator_refresh();
  void refresh_shared_mutator(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec);
  void send_refresh_shared_mutator(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec);
  void recv_refresh_shared_mutator();
  void shared_mutator_set_cells(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<Cell> & cells);
  void send_shared_mutator_set_cells(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<Cell> & cells);
  void recv_shared_mutator_set_cells();
  void offer_cells(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<Cell> & cells);
  void send_offer_cells(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<Cell> & cells);
  void recv_offer_cells();
  void shared_mutator_set_cells_as_arrays(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<CellAsArray> & cells);
  void send_shared_mutator_set_cells_as_arrays(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<CellAsArray> & cells);
  void recv_shared_mutator_set_cells_as_arrays();
  void offer_cells_as_arrays(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<CellAsArray> & cells);
  void send_offer_cells_as_arrays(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<CellAsArray> & cells);
  void recv_offer_cells_as_arrays();
  void shared_mutator_set_cell(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const Cell& cell);
  void send_shared_mutator_set_cell(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const Cell& cell);
  void recv_shared_mutator_set_cell();
  void offer_cell(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const Cell& cell);
  void send_offer_cell(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const Cell& cell);
  void recv_offer_cell();
  void shared_mutator_set_cell_as_array(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const CellAsArray& cell);
  void send_shared_mutator_set_cell_as_array(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const CellAsArray& cell);
  void recv_shared_mutator_set_cell_as_array();
  void offer_cell_as_array(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const CellAsArray& cell);
  void send_offer_cell_as_array(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const CellAsArray& cell);
  void recv_offer_cell_as_array();
  Mutator mutator_open(const Namespace ns, const std::string& table_name, const int32_t flags, const int32_t flush_interval);
  void send_mutator_open(const Namespace ns, const std::string& table_name, const int32_t flags, const int32_t flush_interval);
  Mutator recv_mutator_open();
  Mutator open_mutator(const Namespace ns, const std::string& table_name, const int32_t flags, const int32_t flush_interval);
  void send_open_mutator(const Namespace ns, const std::string& table_name, const int32_t flags, const int32_t flush_interval);
  Mutator recv_open_mutator();
  MutatorAsync async_mutator_open(const Namespace ns, const std::string& table_name, const Future future, const int32_t flags);
  void send_async_mutator_open(const Namespace ns, const std::string& table_name, const Future future, const int32_t flags);
  MutatorAsync recv_async_mutator_open();
  MutatorAsync open_mutator_async(const Namespace ns, const std::string& table_name, const Future future, const int32_t flags);
  void send_open_mutator_async(const Namespace ns, const std::string& table_name, const Future future, const int32_t flags);
  MutatorAsync recv_open_mutator_async();
  void mutator_close(const Mutator mutator);
  void send_mutator_close(const Mutator mutator);
  void recv_mutator_close();
  void close_mutator(const Mutator mutator);
  void send_close_mutator(const Mutator mutator);
  void recv_close_mutator();
  void async_mutator_cancel(const MutatorAsync mutator);
  void send_async_mutator_cancel(const MutatorAsync mutator);
  void recv_async_mutator_cancel();
  void cancel_mutator_async(const MutatorAsync mutator);
  void send_cancel_mutator_async(const MutatorAsync mutator);
  void recv_cancel_mutator_async();
  void async_mutator_close(const MutatorAsync mutator);
  void send_async_mutator_close(const MutatorAsync mutator);
  void recv_async_mutator_close();
  void close_mutator_async(const MutatorAsync mutator);
  void send_close_mutator_async(const MutatorAsync mutator);
  void recv_close_mutator_async();
  void mutator_set_cell(const Mutator mutator, const Cell& cell);
  void send_mutator_set_cell(const Mutator mutator, const Cell& cell);
  void recv_mutator_set_cell();
  void set_cell(const Namespace ns, const std::string& table_name, const Cell& cell);
  void send_set_cell(const Namespace ns, const std::string& table_name, const Cell& cell);
  void recv_set_cell();
  void mutator_set_cell_as_array(const Mutator mutator, const CellAsArray& cell);
  void send_mutator_set_cell_as_array(const Mutator mutator, const CellAsArray& cell);
  void recv_mutator_set_cell_as_array();
  void set_cell_as_array(const Namespace ns, const std::string& table_name, const CellAsArray& cell);
  void send_set_cell_as_array(const Namespace ns, const std::string& table_name, const CellAsArray& cell);
  void recv_set_cell_as_array();
  void mutator_set_cells(const Mutator mutator, const std::vector<Cell> & cells);
  void send_mutator_set_cells(const Mutator mutator, const std::vector<Cell> & cells);
  void recv_mutator_set_cells();
  void set_cells(const Namespace ns, const std::string& table_name, const std::vector<Cell> & cells);
  void send_set_cells(const Namespace ns, const std::string& table_name, const std::vector<Cell> & cells);
  void recv_set_cells();
  void mutator_set_cells_as_arrays(const Mutator mutator, const std::vector<CellAsArray> & cells);
  void send_mutator_set_cells_as_arrays(const Mutator mutator, const std::vector<CellAsArray> & cells);
  void recv_mutator_set_cells_as_arrays();
  void set_cells_as_arrays(const Namespace ns, const std::string& table_name, const std::vector<CellAsArray> & cells);
  void send_set_cells_as_arrays(const Namespace ns, const std::string& table_name, const std::vector<CellAsArray> & cells);
  void recv_set_cells_as_arrays();
  void mutator_set_cells_serialized(const Mutator mutator, const CellsSerialized& cells, const bool flush);
  void send_mutator_set_cells_serialized(const Mutator mutator, const CellsSerialized& cells, const bool flush);
  void recv_mutator_set_cells_serialized();
  void set_cells_serialized(const Namespace ns, const std::string& table_name, const CellsSerialized& cells);
  void send_set_cells_serialized(const Namespace ns, const std::string& table_name, const CellsSerialized& cells);
  void recv_set_cells_serialized();
  void mutator_flush(const Mutator mutator);
  void send_mutator_flush(const Mutator mutator);
  void recv_mutator_flush();
  void flush_mutator(const Mutator mutator);
  void send_flush_mutator(const Mutator mutator);
  void recv_flush_mutator();
  void async_mutator_set_cell(const MutatorAsync mutator, const Cell& cell);
  void send_async_mutator_set_cell(const MutatorAsync mutator, const Cell& cell);
  void recv_async_mutator_set_cell();
  void set_cell_async(const MutatorAsync mutator, const Cell& cell);
  void send_set_cell_async(const MutatorAsync mutator, const Cell& cell);
  void recv_set_cell_async();
  void async_mutator_set_cell_as_array(const MutatorAsync mutator, const CellAsArray& cell);
  void send_async_mutator_set_cell_as_array(const MutatorAsync mutator, const CellAsArray& cell);
  void recv_async_mutator_set_cell_as_array();
  void set_cell_as_array_async(const MutatorAsync mutator, const CellAsArray& cell);
  void send_set_cell_as_array_async(const MutatorAsync mutator, const CellAsArray& cell);
  void recv_set_cell_as_array_async();
  void async_mutator_set_cells(const MutatorAsync mutator, const std::vector<Cell> & cells);
  void send_async_mutator_set_cells(const MutatorAsync mutator, const std::vector<Cell> & cells);
  void recv_async_mutator_set_cells();
  void set_cells_async(const MutatorAsync mutator, const std::vector<Cell> & cells);
  void send_set_cells_async(const MutatorAsync mutator, const std::vector<Cell> & cells);
  void recv_set_cells_async();
  void async_mutator_set_cells_as_arrays(const MutatorAsync mutator, const std::vector<CellAsArray> & cells);
  void send_async_mutator_set_cells_as_arrays(const MutatorAsync mutator, const std::vector<CellAsArray> & cells);
  void recv_async_mutator_set_cells_as_arrays();
  void set_cells_as_arrays_async(const MutatorAsync mutator, const std::vector<CellAsArray> & cells);
  void send_set_cells_as_arrays_async(const MutatorAsync mutator, const std::vector<CellAsArray> & cells);
  void recv_set_cells_as_arrays_async();
  void async_mutator_set_cells_serialized(const MutatorAsync mutator, const CellsSerialized& cells, const bool flush);
  void send_async_mutator_set_cells_serialized(const MutatorAsync mutator, const CellsSerialized& cells, const bool flush);
  void recv_async_mutator_set_cells_serialized();
  void set_cells_serialized_async(const MutatorAsync mutator, const CellsSerialized& cells, const bool flush);
  void send_set_cells_serialized_async(const MutatorAsync mutator, const CellsSerialized& cells, const bool flush);
  void recv_set_cells_serialized_async();
  void async_mutator_flush(const MutatorAsync mutator);
  void send_async_mutator_flush(const MutatorAsync mutator);
  void recv_async_mutator_flush();
  void flush_mutator_async(const MutatorAsync mutator);
  void send_flush_mutator_async(const MutatorAsync mutator);
  void recv_flush_mutator_async();
  bool namespace_exists(const std::string& ns);
  void send_namespace_exists(const std::string& ns);
  bool recv_namespace_exists();
  bool exists_namespace(const std::string& ns);
  void send_exists_namespace(const std::string& ns);
  bool recv_exists_namespace();
  bool exists_table(const Namespace ns, const std::string& name);
  void send_exists_table(const Namespace ns, const std::string& name);
  bool recv_exists_table();
  bool table_exists(const Namespace ns, const std::string& name);
  void send_table_exists(const Namespace ns, const std::string& name);
  bool recv_table_exists();
  void table_get_id(std::string& _return, const Namespace ns, const std::string& table_name);
  void send_table_get_id(const Namespace ns, const std::string& table_name);
  void recv_table_get_id(std::string& _return);
  void get_table_id(std::string& _return, const Namespace ns, const std::string& table_name);
  void send_get_table_id(const Namespace ns, const std::string& table_name);
  void recv_get_table_id(std::string& _return);
  void table_get_schema_str(std::string& _return, const Namespace ns, const std::string& table_name);
  void send_table_get_schema_str(const Namespace ns, const std::string& table_name);
  void recv_table_get_schema_str(std::string& _return);
  void get_schema_str(std::string& _return, const Namespace ns, const std::string& table_name);
  void send_get_schema_str(const Namespace ns, const std::string& table_name);
  void recv_get_schema_str(std::string& _return);
  void table_get_schema_str_with_ids(std::string& _return, const Namespace ns, const std::string& table_name);
  void send_table_get_schema_str_with_ids(const Namespace ns, const std::string& table_name);
  void recv_table_get_schema_str_with_ids(std::string& _return);
  void get_schema_str_with_ids(std::string& _return, const Namespace ns, const std::string& table_name);
  void send_get_schema_str_with_ids(const Namespace ns, const std::string& table_name);
  void recv_get_schema_str_with_ids(std::string& _return);
  void table_get_schema(Schema& _return, const Namespace ns, const std::string& table_name);
  void send_table_get_schema(const Namespace ns, const std::string& table_name);
  void recv_table_get_schema(Schema& _return);
  void get_schema(Schema& _return, const Namespace ns, const std::string& table_name);
  void send_get_schema(const Namespace ns, const std::string& table_name);
  void recv_get_schema(Schema& _return);
  void get_tables(std::vector<std::string> & _return, const Namespace ns);
  void send_get_tables(const Namespace ns);
  void recv_get_tables(std::vector<std::string> & _return);
  void namespace_get_listing(std::vector<NamespaceListing> & _return, const Namespace ns);
  void send_namespace_get_listing(const Namespace ns);
  void recv_namespace_get_listing(std::vector<NamespaceListing> & _return);
  void get_listing(std::vector<NamespaceListing> & _return, const Namespace ns);
  void send_get_listing(const Namespace ns);
  void recv_get_listing(std::vector<NamespaceListing> & _return);
  void table_get_splits(std::vector<TableSplit> & _return, const Namespace ns, const std::string& table_name);
  void send_table_get_splits(const Namespace ns, const std::string& table_name);
  void recv_table_get_splits(std::vector<TableSplit> & _return);
  void get_table_splits(std::vector<TableSplit> & _return, const Namespace ns, const std::string& table_name);
  void send_get_table_splits(const Namespace ns, const std::string& table_name);
  void recv_get_table_splits(std::vector<TableSplit> & _return);
  void namespace_drop(const std::string& ns, const bool if_exists);
  void send_namespace_drop(const std::string& ns, const bool if_exists);
  void recv_namespace_drop();
  void drop_namespace(const std::string& ns, const bool if_exists);
  void send_drop_namespace(const std::string& ns, const bool if_exists);
  void recv_drop_namespace();
  void rename_table(const Namespace ns, const std::string& name, const std::string& new_name);
  void send_rename_table(const Namespace ns, const std::string& name, const std::string& new_name);
  void recv_rename_table();
  void table_rename(const Namespace ns, const std::string& name, const std::string& new_name);
  void send_table_rename(const Namespace ns, const std::string& name, const std::string& new_name);
  void recv_table_rename();
  void drop_table(const Namespace ns, const std::string& name, const bool if_exists);
  void send_drop_table(const Namespace ns, const std::string& name, const bool if_exists);
  void recv_drop_table();
  void table_drop(const Namespace ns, const std::string& name, const bool if_exists);
  void send_table_drop(const Namespace ns, const std::string& name, const bool if_exists);
  void recv_table_drop();
  void generate_guid(std::string& _return);
  void send_generate_guid();
  void recv_generate_guid(std::string& _return);
  void create_cell_unique(std::string& _return, const Namespace ns, const std::string& table_name, const Key& key, const std::string& value);
  void send_create_cell_unique(const Namespace ns, const std::string& table_name, const Key& key, const std::string& value);
  void recv_create_cell_unique(std::string& _return);
  void error_get_text(std::string& _return, const int32_t error_code);
  void send_error_get_text(const int32_t error_code);
  void recv_error_get_text(std::string& _return);
  void status(Status& _return);
  void send_status();
  void recv_status(Status& _return);
  void shutdown();
  void send_shutdown();
  void recv_shutdown();
 protected:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class ClientServiceProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::apache::thrift::stdcxx::shared_ptr<ClientServiceIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (ClientServiceProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_namespace_create(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_create_namespace(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_table_create(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_table_alter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_refresh_table(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_namespace_open(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_open_namespace(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_namespace_close(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_close_namespace(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_future_open(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_open_future(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_future_cancel(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_cancel_future(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_future_get_result(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_future_result(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_future_get_result_as_arrays(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_future_result_as_arrays(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_future_get_result_serialized(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_future_result_serialized(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_future_is_empty(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_future_is_full(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_future_is_cancelled(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_future_has_outstanding(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_future_close(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_close_future(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scanner_open(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_open_scanner(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_async_scanner_open(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_open_scanner_async(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scanner_close(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_close_scanner(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_async_scanner_cancel(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_cancel_scanner_async(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_async_scanner_close(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_close_scanner_async(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scanner_get_cells(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_next_cells(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scanner_get_cells_as_arrays(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_next_cells_as_arrays(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scanner_get_cells_serialized(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_next_cells_serialized(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scanner_get_row(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_next_row(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scanner_get_row_as_arrays(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_next_row_as_arrays(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scanner_get_row_serialized(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_next_row_serialized(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_row(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_row_as_arrays(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_row_serialized(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_cell(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_cells(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_cells_as_arrays(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_cells_serialized(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_shared_mutator_refresh(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_refresh_shared_mutator(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_shared_mutator_set_cells(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_offer_cells(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_shared_mutator_set_cells_as_arrays(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_offer_cells_as_arrays(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_shared_mutator_set_cell(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_offer_cell(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_shared_mutator_set_cell_as_array(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_offer_cell_as_array(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutator_open(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_open_mutator(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_async_mutator_open(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_open_mutator_async(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutator_close(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_close_mutator(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_async_mutator_cancel(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_cancel_mutator_async(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_async_mutator_close(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_close_mutator_async(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutator_set_cell(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_set_cell(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutator_set_cell_as_array(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_set_cell_as_array(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutator_set_cells(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_set_cells(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutator_set_cells_as_arrays(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_set_cells_as_arrays(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutator_set_cells_serialized(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_set_cells_serialized(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutator_flush(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_flush_mutator(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_async_mutator_set_cell(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_set_cell_async(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_async_mutator_set_cell_as_array(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_set_cell_as_array_async(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_async_mutator_set_cells(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_set_cells_async(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_async_mutator_set_cells_as_arrays(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_set_cells_as_arrays_async(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_async_mutator_set_cells_serialized(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_set_cells_serialized_async(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_async_mutator_flush(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_flush_mutator_async(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_namespace_exists(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_exists_namespace(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_exists_table(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_table_exists(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_table_get_id(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_table_id(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_table_get_schema_str(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_schema_str(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_table_get_schema_str_with_ids(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_schema_str_with_ids(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_table_get_schema(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_schema(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_tables(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_namespace_get_listing(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_listing(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_table_get_splits(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_table_splits(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_namespace_drop(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_drop_namespace(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_rename_table(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_table_rename(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_drop_table(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_table_drop(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_generate_guid(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_create_cell_unique(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_error_get_text(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_status(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_shutdown(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  ClientServiceProcessor(::apache::thrift::stdcxx::shared_ptr<ClientServiceIf> iface) :
    iface_(iface) {
    processMap_["namespace_create"] = &ClientServiceProcessor::process_namespace_create;
    processMap_["create_namespace"] = &ClientServiceProcessor::process_create_namespace;
    processMap_["table_create"] = &ClientServiceProcessor::process_table_create;
    processMap_["table_alter"] = &ClientServiceProcessor::process_table_alter;
    processMap_["refresh_table"] = &ClientServiceProcessor::process_refresh_table;
    processMap_["namespace_open"] = &ClientServiceProcessor::process_namespace_open;
    processMap_["open_namespace"] = &ClientServiceProcessor::process_open_namespace;
    processMap_["namespace_close"] = &ClientServiceProcessor::process_namespace_close;
    processMap_["close_namespace"] = &ClientServiceProcessor::process_close_namespace;
    processMap_["future_open"] = &ClientServiceProcessor::process_future_open;
    processMap_["open_future"] = &ClientServiceProcessor::process_open_future;
    processMap_["future_cancel"] = &ClientServiceProcessor::process_future_cancel;
    processMap_["cancel_future"] = &ClientServiceProcessor::process_cancel_future;
    processMap_["future_get_result"] = &ClientServiceProcessor::process_future_get_result;
    processMap_["get_future_result"] = &ClientServiceProcessor::process_get_future_result;
    processMap_["future_get_result_as_arrays"] = &ClientServiceProcessor::process_future_get_result_as_arrays;
    processMap_["get_future_result_as_arrays"] = &ClientServiceProcessor::process_get_future_result_as_arrays;
    processMap_["future_get_result_serialized"] = &ClientServiceProcessor::process_future_get_result_serialized;
    processMap_["get_future_result_serialized"] = &ClientServiceProcessor::process_get_future_result_serialized;
    processMap_["future_is_empty"] = &ClientServiceProcessor::process_future_is_empty;
    processMap_["future_is_full"] = &ClientServiceProcessor::process_future_is_full;
    processMap_["future_is_cancelled"] = &ClientServiceProcessor::process_future_is_cancelled;
    processMap_["future_has_outstanding"] = &ClientServiceProcessor::process_future_has_outstanding;
    processMap_["future_close"] = &ClientServiceProcessor::process_future_close;
    processMap_["close_future"] = &ClientServiceProcessor::process_close_future;
    processMap_["scanner_open"] = &ClientServiceProcessor::process_scanner_open;
    processMap_["open_scanner"] = &ClientServiceProcessor::process_open_scanner;
    processMap_["async_scanner_open"] = &ClientServiceProcessor::process_async_scanner_open;
    processMap_["open_scanner_async"] = &ClientServiceProcessor::process_open_scanner_async;
    processMap_["scanner_close"] = &ClientServiceProcessor::process_scanner_close;
    processMap_["close_scanner"] = &ClientServiceProcessor::process_close_scanner;
    processMap_["async_scanner_cancel"] = &ClientServiceProcessor::process_async_scanner_cancel;
    processMap_["cancel_scanner_async"] = &ClientServiceProcessor::process_cancel_scanner_async;
    processMap_["async_scanner_close"] = &ClientServiceProcessor::process_async_scanner_close;
    processMap_["close_scanner_async"] = &ClientServiceProcessor::process_close_scanner_async;
    processMap_["scanner_get_cells"] = &ClientServiceProcessor::process_scanner_get_cells;
    processMap_["next_cells"] = &ClientServiceProcessor::process_next_cells;
    processMap_["scanner_get_cells_as_arrays"] = &ClientServiceProcessor::process_scanner_get_cells_as_arrays;
    processMap_["next_cells_as_arrays"] = &ClientServiceProcessor::process_next_cells_as_arrays;
    processMap_["scanner_get_cells_serialized"] = &ClientServiceProcessor::process_scanner_get_cells_serialized;
    processMap_["next_cells_serialized"] = &ClientServiceProcessor::process_next_cells_serialized;
    processMap_["scanner_get_row"] = &ClientServiceProcessor::process_scanner_get_row;
    processMap_["next_row"] = &ClientServiceProcessor::process_next_row;
    processMap_["scanner_get_row_as_arrays"] = &ClientServiceProcessor::process_scanner_get_row_as_arrays;
    processMap_["next_row_as_arrays"] = &ClientServiceProcessor::process_next_row_as_arrays;
    processMap_["scanner_get_row_serialized"] = &ClientServiceProcessor::process_scanner_get_row_serialized;
    processMap_["next_row_serialized"] = &ClientServiceProcessor::process_next_row_serialized;
    processMap_["get_row"] = &ClientServiceProcessor::process_get_row;
    processMap_["get_row_as_arrays"] = &ClientServiceProcessor::process_get_row_as_arrays;
    processMap_["get_row_serialized"] = &ClientServiceProcessor::process_get_row_serialized;
    processMap_["get_cell"] = &ClientServiceProcessor::process_get_cell;
    processMap_["get_cells"] = &ClientServiceProcessor::process_get_cells;
    processMap_["get_cells_as_arrays"] = &ClientServiceProcessor::process_get_cells_as_arrays;
    processMap_["get_cells_serialized"] = &ClientServiceProcessor::process_get_cells_serialized;
    processMap_["shared_mutator_refresh"] = &ClientServiceProcessor::process_shared_mutator_refresh;
    processMap_["refresh_shared_mutator"] = &ClientServiceProcessor::process_refresh_shared_mutator;
    processMap_["shared_mutator_set_cells"] = &ClientServiceProcessor::process_shared_mutator_set_cells;
    processMap_["offer_cells"] = &ClientServiceProcessor::process_offer_cells;
    processMap_["shared_mutator_set_cells_as_arrays"] = &ClientServiceProcessor::process_shared_mutator_set_cells_as_arrays;
    processMap_["offer_cells_as_arrays"] = &ClientServiceProcessor::process_offer_cells_as_arrays;
    processMap_["shared_mutator_set_cell"] = &ClientServiceProcessor::process_shared_mutator_set_cell;
    processMap_["offer_cell"] = &ClientServiceProcessor::process_offer_cell;
    processMap_["shared_mutator_set_cell_as_array"] = &ClientServiceProcessor::process_shared_mutator_set_cell_as_array;
    processMap_["offer_cell_as_array"] = &ClientServiceProcessor::process_offer_cell_as_array;
    processMap_["mutator_open"] = &ClientServiceProcessor::process_mutator_open;
    processMap_["open_mutator"] = &ClientServiceProcessor::process_open_mutator;
    processMap_["async_mutator_open"] = &ClientServiceProcessor::process_async_mutator_open;
    processMap_["open_mutator_async"] = &ClientServiceProcessor::process_open_mutator_async;
    processMap_["mutator_close"] = &ClientServiceProcessor::process_mutator_close;
    processMap_["close_mutator"] = &ClientServiceProcessor::process_close_mutator;
    processMap_["async_mutator_cancel"] = &ClientServiceProcessor::process_async_mutator_cancel;
    processMap_["cancel_mutator_async"] = &ClientServiceProcessor::process_cancel_mutator_async;
    processMap_["async_mutator_close"] = &ClientServiceProcessor::process_async_mutator_close;
    processMap_["close_mutator_async"] = &ClientServiceProcessor::process_close_mutator_async;
    processMap_["mutator_set_cell"] = &ClientServiceProcessor::process_mutator_set_cell;
    processMap_["set_cell"] = &ClientServiceProcessor::process_set_cell;
    processMap_["mutator_set_cell_as_array"] = &ClientServiceProcessor::process_mutator_set_cell_as_array;
    processMap_["set_cell_as_array"] = &ClientServiceProcessor::process_set_cell_as_array;
    processMap_["mutator_set_cells"] = &ClientServiceProcessor::process_mutator_set_cells;
    processMap_["set_cells"] = &ClientServiceProcessor::process_set_cells;
    processMap_["mutator_set_cells_as_arrays"] = &ClientServiceProcessor::process_mutator_set_cells_as_arrays;
    processMap_["set_cells_as_arrays"] = &ClientServiceProcessor::process_set_cells_as_arrays;
    processMap_["mutator_set_cells_serialized"] = &ClientServiceProcessor::process_mutator_set_cells_serialized;
    processMap_["set_cells_serialized"] = &ClientServiceProcessor::process_set_cells_serialized;
    processMap_["mutator_flush"] = &ClientServiceProcessor::process_mutator_flush;
    processMap_["flush_mutator"] = &ClientServiceProcessor::process_flush_mutator;
    processMap_["async_mutator_set_cell"] = &ClientServiceProcessor::process_async_mutator_set_cell;
    processMap_["set_cell_async"] = &ClientServiceProcessor::process_set_cell_async;
    processMap_["async_mutator_set_cell_as_array"] = &ClientServiceProcessor::process_async_mutator_set_cell_as_array;
    processMap_["set_cell_as_array_async"] = &ClientServiceProcessor::process_set_cell_as_array_async;
    processMap_["async_mutator_set_cells"] = &ClientServiceProcessor::process_async_mutator_set_cells;
    processMap_["set_cells_async"] = &ClientServiceProcessor::process_set_cells_async;
    processMap_["async_mutator_set_cells_as_arrays"] = &ClientServiceProcessor::process_async_mutator_set_cells_as_arrays;
    processMap_["set_cells_as_arrays_async"] = &ClientServiceProcessor::process_set_cells_as_arrays_async;
    processMap_["async_mutator_set_cells_serialized"] = &ClientServiceProcessor::process_async_mutator_set_cells_serialized;
    processMap_["set_cells_serialized_async"] = &ClientServiceProcessor::process_set_cells_serialized_async;
    processMap_["async_mutator_flush"] = &ClientServiceProcessor::process_async_mutator_flush;
    processMap_["flush_mutator_async"] = &ClientServiceProcessor::process_flush_mutator_async;
    processMap_["namespace_exists"] = &ClientServiceProcessor::process_namespace_exists;
    processMap_["exists_namespace"] = &ClientServiceProcessor::process_exists_namespace;
    processMap_["exists_table"] = &ClientServiceProcessor::process_exists_table;
    processMap_["table_exists"] = &ClientServiceProcessor::process_table_exists;
    processMap_["table_get_id"] = &ClientServiceProcessor::process_table_get_id;
    processMap_["get_table_id"] = &ClientServiceProcessor::process_get_table_id;
    processMap_["table_get_schema_str"] = &ClientServiceProcessor::process_table_get_schema_str;
    processMap_["get_schema_str"] = &ClientServiceProcessor::process_get_schema_str;
    processMap_["table_get_schema_str_with_ids"] = &ClientServiceProcessor::process_table_get_schema_str_with_ids;
    processMap_["get_schema_str_with_ids"] = &ClientServiceProcessor::process_get_schema_str_with_ids;
    processMap_["table_get_schema"] = &ClientServiceProcessor::process_table_get_schema;
    processMap_["get_schema"] = &ClientServiceProcessor::process_get_schema;
    processMap_["get_tables"] = &ClientServiceProcessor::process_get_tables;
    processMap_["namespace_get_listing"] = &ClientServiceProcessor::process_namespace_get_listing;
    processMap_["get_listing"] = &ClientServiceProcessor::process_get_listing;
    processMap_["table_get_splits"] = &ClientServiceProcessor::process_table_get_splits;
    processMap_["get_table_splits"] = &ClientServiceProcessor::process_get_table_splits;
    processMap_["namespace_drop"] = &ClientServiceProcessor::process_namespace_drop;
    processMap_["drop_namespace"] = &ClientServiceProcessor::process_drop_namespace;
    processMap_["rename_table"] = &ClientServiceProcessor::process_rename_table;
    processMap_["table_rename"] = &ClientServiceProcessor::process_table_rename;
    processMap_["drop_table"] = &ClientServiceProcessor::process_drop_table;
    processMap_["table_drop"] = &ClientServiceProcessor::process_table_drop;
    processMap_["generate_guid"] = &ClientServiceProcessor::process_generate_guid;
    processMap_["create_cell_unique"] = &ClientServiceProcessor::process_create_cell_unique;
    processMap_["error_get_text"] = &ClientServiceProcessor::process_error_get_text;
    processMap_["status"] = &ClientServiceProcessor::process_status;
    processMap_["shutdown"] = &ClientServiceProcessor::process_shutdown;
  }

  virtual ~ClientServiceProcessor() {}
};

class ClientServiceProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  ClientServiceProcessorFactory(const ::apache::thrift::stdcxx::shared_ptr< ClientServiceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::apache::thrift::stdcxx::shared_ptr< ClientServiceIfFactory > handlerFactory_;
};

class ClientServiceMultiface : virtual public ClientServiceIf {
 public:
  ClientServiceMultiface(std::vector<apache::thrift::stdcxx::shared_ptr<ClientServiceIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~ClientServiceMultiface() {}
 protected:
  std::vector<apache::thrift::stdcxx::shared_ptr<ClientServiceIf> > ifaces_;
  ClientServiceMultiface() {}
  void add(::apache::thrift::stdcxx::shared_ptr<ClientServiceIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void namespace_create(const std::string& ns) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->namespace_create(ns);
    }
    ifaces_[i]->namespace_create(ns);
  }

  void create_namespace(const std::string& ns) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->create_namespace(ns);
    }
    ifaces_[i]->create_namespace(ns);
  }

  void table_create(const Namespace ns, const std::string& table_name, const Schema& schema) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->table_create(ns, table_name, schema);
    }
    ifaces_[i]->table_create(ns, table_name, schema);
  }

  void table_alter(const Namespace ns, const std::string& table_name, const Schema& schema) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->table_alter(ns, table_name, schema);
    }
    ifaces_[i]->table_alter(ns, table_name, schema);
  }

  void refresh_table(const Namespace ns, const std::string& table_name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->refresh_table(ns, table_name);
    }
    ifaces_[i]->refresh_table(ns, table_name);
  }

  Namespace namespace_open(const std::string& ns) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->namespace_open(ns);
    }
    return ifaces_[i]->namespace_open(ns);
  }

  Namespace open_namespace(const std::string& ns) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->open_namespace(ns);
    }
    return ifaces_[i]->open_namespace(ns);
  }

  void namespace_close(const Namespace ns) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->namespace_close(ns);
    }
    ifaces_[i]->namespace_close(ns);
  }

  void close_namespace(const Namespace ns) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->close_namespace(ns);
    }
    ifaces_[i]->close_namespace(ns);
  }

  Future future_open(const int32_t capacity) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->future_open(capacity);
    }
    return ifaces_[i]->future_open(capacity);
  }

  Future open_future(const int32_t capacity) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->open_future(capacity);
    }
    return ifaces_[i]->open_future(capacity);
  }

  void future_cancel(const Future ff) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->future_cancel(ff);
    }
    ifaces_[i]->future_cancel(ff);
  }

  void cancel_future(const Future ff) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->cancel_future(ff);
    }
    ifaces_[i]->cancel_future(ff);
  }

  void future_get_result(Result& _return, const Future ff, const int32_t timeout_millis) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->future_get_result(_return, ff, timeout_millis);
    }
    ifaces_[i]->future_get_result(_return, ff, timeout_millis);
    return;
  }

  void get_future_result(Result& _return, const Future ff, const int32_t timeout_millis) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_future_result(_return, ff, timeout_millis);
    }
    ifaces_[i]->get_future_result(_return, ff, timeout_millis);
    return;
  }

  void future_get_result_as_arrays(ResultAsArrays& _return, const Future ff, const int32_t timeout_millis) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->future_get_result_as_arrays(_return, ff, timeout_millis);
    }
    ifaces_[i]->future_get_result_as_arrays(_return, ff, timeout_millis);
    return;
  }

  void get_future_result_as_arrays(ResultAsArrays& _return, const Future ff, const int32_t timeout_millis) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_future_result_as_arrays(_return, ff, timeout_millis);
    }
    ifaces_[i]->get_future_result_as_arrays(_return, ff, timeout_millis);
    return;
  }

  void future_get_result_serialized(ResultSerialized& _return, const Future ff, const int32_t timeout_millis) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->future_get_result_serialized(_return, ff, timeout_millis);
    }
    ifaces_[i]->future_get_result_serialized(_return, ff, timeout_millis);
    return;
  }

  void get_future_result_serialized(ResultSerialized& _return, const Future ff, const int32_t timeout_millis) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_future_result_serialized(_return, ff, timeout_millis);
    }
    ifaces_[i]->get_future_result_serialized(_return, ff, timeout_millis);
    return;
  }

  bool future_is_empty(const Future ff) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->future_is_empty(ff);
    }
    return ifaces_[i]->future_is_empty(ff);
  }

  bool future_is_full(const Future ff) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->future_is_full(ff);
    }
    return ifaces_[i]->future_is_full(ff);
  }

  bool future_is_cancelled(const Future ff) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->future_is_cancelled(ff);
    }
    return ifaces_[i]->future_is_cancelled(ff);
  }

  bool future_has_outstanding(const Future ff) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->future_has_outstanding(ff);
    }
    return ifaces_[i]->future_has_outstanding(ff);
  }

  void future_close(const Future ff) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->future_close(ff);
    }
    ifaces_[i]->future_close(ff);
  }

  void close_future(const Future ff) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->close_future(ff);
    }
    ifaces_[i]->close_future(ff);
  }

  Scanner scanner_open(const Namespace ns, const std::string& table_name, const ScanSpec& scan_spec) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scanner_open(ns, table_name, scan_spec);
    }
    return ifaces_[i]->scanner_open(ns, table_name, scan_spec);
  }

  Scanner open_scanner(const Namespace ns, const std::string& table_name, const ScanSpec& scan_spec) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->open_scanner(ns, table_name, scan_spec);
    }
    return ifaces_[i]->open_scanner(ns, table_name, scan_spec);
  }

  ScannerAsync async_scanner_open(const Namespace ns, const std::string& table_name, const Future future, const ScanSpec& scan_spec) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->async_scanner_open(ns, table_name, future, scan_spec);
    }
    return ifaces_[i]->async_scanner_open(ns, table_name, future, scan_spec);
  }

  ScannerAsync open_scanner_async(const Namespace ns, const std::string& table_name, const Future future, const ScanSpec& scan_spec) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->open_scanner_async(ns, table_name, future, scan_spec);
    }
    return ifaces_[i]->open_scanner_async(ns, table_name, future, scan_spec);
  }

  void scanner_close(const Scanner scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scanner_close(scanner);
    }
    ifaces_[i]->scanner_close(scanner);
  }

  void close_scanner(const Scanner scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->close_scanner(scanner);
    }
    ifaces_[i]->close_scanner(scanner);
  }

  void async_scanner_cancel(const ScannerAsync scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->async_scanner_cancel(scanner);
    }
    ifaces_[i]->async_scanner_cancel(scanner);
  }

  void cancel_scanner_async(const ScannerAsync scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->cancel_scanner_async(scanner);
    }
    ifaces_[i]->cancel_scanner_async(scanner);
  }

  void async_scanner_close(const ScannerAsync scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->async_scanner_close(scanner);
    }
    ifaces_[i]->async_scanner_close(scanner);
  }

  void close_scanner_async(const ScannerAsync scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->close_scanner_async(scanner);
    }
    ifaces_[i]->close_scanner_async(scanner);
  }

  void scanner_get_cells(std::vector<Cell> & _return, const Scanner scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scanner_get_cells(_return, scanner);
    }
    ifaces_[i]->scanner_get_cells(_return, scanner);
    return;
  }

  void next_cells(std::vector<Cell> & _return, const Scanner scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->next_cells(_return, scanner);
    }
    ifaces_[i]->next_cells(_return, scanner);
    return;
  }

  void scanner_get_cells_as_arrays(std::vector<CellAsArray> & _return, const Scanner scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scanner_get_cells_as_arrays(_return, scanner);
    }
    ifaces_[i]->scanner_get_cells_as_arrays(_return, scanner);
    return;
  }

  void next_cells_as_arrays(std::vector<CellAsArray> & _return, const Scanner scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->next_cells_as_arrays(_return, scanner);
    }
    ifaces_[i]->next_cells_as_arrays(_return, scanner);
    return;
  }

  void scanner_get_cells_serialized(CellsSerialized& _return, const Scanner scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scanner_get_cells_serialized(_return, scanner);
    }
    ifaces_[i]->scanner_get_cells_serialized(_return, scanner);
    return;
  }

  void next_cells_serialized(CellsSerialized& _return, const Scanner scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->next_cells_serialized(_return, scanner);
    }
    ifaces_[i]->next_cells_serialized(_return, scanner);
    return;
  }

  void scanner_get_row(std::vector<Cell> & _return, const Scanner scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scanner_get_row(_return, scanner);
    }
    ifaces_[i]->scanner_get_row(_return, scanner);
    return;
  }

  void next_row(std::vector<Cell> & _return, const Scanner scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->next_row(_return, scanner);
    }
    ifaces_[i]->next_row(_return, scanner);
    return;
  }

  void scanner_get_row_as_arrays(std::vector<CellAsArray> & _return, const Scanner scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scanner_get_row_as_arrays(_return, scanner);
    }
    ifaces_[i]->scanner_get_row_as_arrays(_return, scanner);
    return;
  }

  void next_row_as_arrays(std::vector<CellAsArray> & _return, const Scanner scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->next_row_as_arrays(_return, scanner);
    }
    ifaces_[i]->next_row_as_arrays(_return, scanner);
    return;
  }

  void scanner_get_row_serialized(CellsSerialized& _return, const Scanner scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scanner_get_row_serialized(_return, scanner);
    }
    ifaces_[i]->scanner_get_row_serialized(_return, scanner);
    return;
  }

  void next_row_serialized(CellsSerialized& _return, const Scanner scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->next_row_serialized(_return, scanner);
    }
    ifaces_[i]->next_row_serialized(_return, scanner);
    return;
  }

  void get_row(std::vector<Cell> & _return, const Namespace ns, const std::string& table_name, const std::string& row) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_row(_return, ns, table_name, row);
    }
    ifaces_[i]->get_row(_return, ns, table_name, row);
    return;
  }

  void get_row_as_arrays(std::vector<CellAsArray> & _return, const Namespace ns, const std::string& name, const std::string& row) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_row_as_arrays(_return, ns, name, row);
    }
    ifaces_[i]->get_row_as_arrays(_return, ns, name, row);
    return;
  }

  void get_row_serialized(CellsSerialized& _return, const Namespace ns, const std::string& table_name, const std::string& row) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_row_serialized(_return, ns, table_name, row);
    }
    ifaces_[i]->get_row_serialized(_return, ns, table_name, row);
    return;
  }

  void get_cell(Value& _return, const Namespace ns, const std::string& table_name, const std::string& row, const std::string& column) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_cell(_return, ns, table_name, row, column);
    }
    ifaces_[i]->get_cell(_return, ns, table_name, row, column);
    return;
  }

  void get_cells(std::vector<Cell> & _return, const Namespace ns, const std::string& table_name, const ScanSpec& scan_spec) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_cells(_return, ns, table_name, scan_spec);
    }
    ifaces_[i]->get_cells(_return, ns, table_name, scan_spec);
    return;
  }

  void get_cells_as_arrays(std::vector<CellAsArray> & _return, const Namespace ns, const std::string& name, const ScanSpec& scan_spec) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_cells_as_arrays(_return, ns, name, scan_spec);
    }
    ifaces_[i]->get_cells_as_arrays(_return, ns, name, scan_spec);
    return;
  }

  void get_cells_serialized(CellsSerialized& _return, const Namespace ns, const std::string& name, const ScanSpec& scan_spec) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_cells_serialized(_return, ns, name, scan_spec);
    }
    ifaces_[i]->get_cells_serialized(_return, ns, name, scan_spec);
    return;
  }

  void shared_mutator_refresh(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->shared_mutator_refresh(ns, table_name, mutate_spec);
    }
    ifaces_[i]->shared_mutator_refresh(ns, table_name, mutate_spec);
  }

  void refresh_shared_mutator(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->refresh_shared_mutator(ns, table_name, mutate_spec);
    }
    ifaces_[i]->refresh_shared_mutator(ns, table_name, mutate_spec);
  }

  void shared_mutator_set_cells(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<Cell> & cells) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->shared_mutator_set_cells(ns, table_name, mutate_spec, cells);
    }
    ifaces_[i]->shared_mutator_set_cells(ns, table_name, mutate_spec, cells);
  }

  void offer_cells(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<Cell> & cells) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->offer_cells(ns, table_name, mutate_spec, cells);
    }
    ifaces_[i]->offer_cells(ns, table_name, mutate_spec, cells);
  }

  void shared_mutator_set_cells_as_arrays(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<CellAsArray> & cells) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->shared_mutator_set_cells_as_arrays(ns, table_name, mutate_spec, cells);
    }
    ifaces_[i]->shared_mutator_set_cells_as_arrays(ns, table_name, mutate_spec, cells);
  }

  void offer_cells_as_arrays(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<CellAsArray> & cells) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->offer_cells_as_arrays(ns, table_name, mutate_spec, cells);
    }
    ifaces_[i]->offer_cells_as_arrays(ns, table_name, mutate_spec, cells);
  }

  void shared_mutator_set_cell(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const Cell& cell) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->shared_mutator_set_cell(ns, table_name, mutate_spec, cell);
    }
    ifaces_[i]->shared_mutator_set_cell(ns, table_name, mutate_spec, cell);
  }

  void offer_cell(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const Cell& cell) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->offer_cell(ns, table_name, mutate_spec, cell);
    }
    ifaces_[i]->offer_cell(ns, table_name, mutate_spec, cell);
  }

  void shared_mutator_set_cell_as_array(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const CellAsArray& cell) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->shared_mutator_set_cell_as_array(ns, table_name, mutate_spec, cell);
    }
    ifaces_[i]->shared_mutator_set_cell_as_array(ns, table_name, mutate_spec, cell);
  }

  void offer_cell_as_array(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const CellAsArray& cell) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->offer_cell_as_array(ns, table_name, mutate_spec, cell);
    }
    ifaces_[i]->offer_cell_as_array(ns, table_name, mutate_spec, cell);
  }

  Mutator mutator_open(const Namespace ns, const std::string& table_name, const int32_t flags, const int32_t flush_interval) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mutator_open(ns, table_name, flags, flush_interval);
    }
    return ifaces_[i]->mutator_open(ns, table_name, flags, flush_interval);
  }

  Mutator open_mutator(const Namespace ns, const std::string& table_name, const int32_t flags, const int32_t flush_interval) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->open_mutator(ns, table_name, flags, flush_interval);
    }
    return ifaces_[i]->open_mutator(ns, table_name, flags, flush_interval);
  }

  MutatorAsync async_mutator_open(const Namespace ns, const std::string& table_name, const Future future, const int32_t flags) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->async_mutator_open(ns, table_name, future, flags);
    }
    return ifaces_[i]->async_mutator_open(ns, table_name, future, flags);
  }

  MutatorAsync open_mutator_async(const Namespace ns, const std::string& table_name, const Future future, const int32_t flags) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->open_mutator_async(ns, table_name, future, flags);
    }
    return ifaces_[i]->open_mutator_async(ns, table_name, future, flags);
  }

  void mutator_close(const Mutator mutator) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mutator_close(mutator);
    }
    ifaces_[i]->mutator_close(mutator);
  }

  void close_mutator(const Mutator mutator) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->close_mutator(mutator);
    }
    ifaces_[i]->close_mutator(mutator);
  }

  void async_mutator_cancel(const MutatorAsync mutator) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->async_mutator_cancel(mutator);
    }
    ifaces_[i]->async_mutator_cancel(mutator);
  }

  void cancel_mutator_async(const MutatorAsync mutator) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->cancel_mutator_async(mutator);
    }
    ifaces_[i]->cancel_mutator_async(mutator);
  }

  void async_mutator_close(const MutatorAsync mutator) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->async_mutator_close(mutator);
    }
    ifaces_[i]->async_mutator_close(mutator);
  }

  void close_mutator_async(const MutatorAsync mutator) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->close_mutator_async(mutator);
    }
    ifaces_[i]->close_mutator_async(mutator);
  }

  void mutator_set_cell(const Mutator mutator, const Cell& cell) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mutator_set_cell(mutator, cell);
    }
    ifaces_[i]->mutator_set_cell(mutator, cell);
  }

  void set_cell(const Namespace ns, const std::string& table_name, const Cell& cell) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->set_cell(ns, table_name, cell);
    }
    ifaces_[i]->set_cell(ns, table_name, cell);
  }

  void mutator_set_cell_as_array(const Mutator mutator, const CellAsArray& cell) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mutator_set_cell_as_array(mutator, cell);
    }
    ifaces_[i]->mutator_set_cell_as_array(mutator, cell);
  }

  void set_cell_as_array(const Namespace ns, const std::string& table_name, const CellAsArray& cell) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->set_cell_as_array(ns, table_name, cell);
    }
    ifaces_[i]->set_cell_as_array(ns, table_name, cell);
  }

  void mutator_set_cells(const Mutator mutator, const std::vector<Cell> & cells) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mutator_set_cells(mutator, cells);
    }
    ifaces_[i]->mutator_set_cells(mutator, cells);
  }

  void set_cells(const Namespace ns, const std::string& table_name, const std::vector<Cell> & cells) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->set_cells(ns, table_name, cells);
    }
    ifaces_[i]->set_cells(ns, table_name, cells);
  }

  void mutator_set_cells_as_arrays(const Mutator mutator, const std::vector<CellAsArray> & cells) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mutator_set_cells_as_arrays(mutator, cells);
    }
    ifaces_[i]->mutator_set_cells_as_arrays(mutator, cells);
  }

  void set_cells_as_arrays(const Namespace ns, const std::string& table_name, const std::vector<CellAsArray> & cells) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->set_cells_as_arrays(ns, table_name, cells);
    }
    ifaces_[i]->set_cells_as_arrays(ns, table_name, cells);
  }

  void mutator_set_cells_serialized(const Mutator mutator, const CellsSerialized& cells, const bool flush) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mutator_set_cells_serialized(mutator, cells, flush);
    }
    ifaces_[i]->mutator_set_cells_serialized(mutator, cells, flush);
  }

  void set_cells_serialized(const Namespace ns, const std::string& table_name, const CellsSerialized& cells) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->set_cells_serialized(ns, table_name, cells);
    }
    ifaces_[i]->set_cells_serialized(ns, table_name, cells);
  }

  void mutator_flush(const Mutator mutator) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mutator_flush(mutator);
    }
    ifaces_[i]->mutator_flush(mutator);
  }

  void flush_mutator(const Mutator mutator) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->flush_mutator(mutator);
    }
    ifaces_[i]->flush_mutator(mutator);
  }

  void async_mutator_set_cell(const MutatorAsync mutator, const Cell& cell) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->async_mutator_set_cell(mutator, cell);
    }
    ifaces_[i]->async_mutator_set_cell(mutator, cell);
  }

  void set_cell_async(const MutatorAsync mutator, const Cell& cell) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->set_cell_async(mutator, cell);
    }
    ifaces_[i]->set_cell_async(mutator, cell);
  }

  void async_mutator_set_cell_as_array(const MutatorAsync mutator, const CellAsArray& cell) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->async_mutator_set_cell_as_array(mutator, cell);
    }
    ifaces_[i]->async_mutator_set_cell_as_array(mutator, cell);
  }

  void set_cell_as_array_async(const MutatorAsync mutator, const CellAsArray& cell) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->set_cell_as_array_async(mutator, cell);
    }
    ifaces_[i]->set_cell_as_array_async(mutator, cell);
  }

  void async_mutator_set_cells(const MutatorAsync mutator, const std::vector<Cell> & cells) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->async_mutator_set_cells(mutator, cells);
    }
    ifaces_[i]->async_mutator_set_cells(mutator, cells);
  }

  void set_cells_async(const MutatorAsync mutator, const std::vector<Cell> & cells) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->set_cells_async(mutator, cells);
    }
    ifaces_[i]->set_cells_async(mutator, cells);
  }

  void async_mutator_set_cells_as_arrays(const MutatorAsync mutator, const std::vector<CellAsArray> & cells) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->async_mutator_set_cells_as_arrays(mutator, cells);
    }
    ifaces_[i]->async_mutator_set_cells_as_arrays(mutator, cells);
  }

  void set_cells_as_arrays_async(const MutatorAsync mutator, const std::vector<CellAsArray> & cells) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->set_cells_as_arrays_async(mutator, cells);
    }
    ifaces_[i]->set_cells_as_arrays_async(mutator, cells);
  }

  void async_mutator_set_cells_serialized(const MutatorAsync mutator, const CellsSerialized& cells, const bool flush) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->async_mutator_set_cells_serialized(mutator, cells, flush);
    }
    ifaces_[i]->async_mutator_set_cells_serialized(mutator, cells, flush);
  }

  void set_cells_serialized_async(const MutatorAsync mutator, const CellsSerialized& cells, const bool flush) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->set_cells_serialized_async(mutator, cells, flush);
    }
    ifaces_[i]->set_cells_serialized_async(mutator, cells, flush);
  }

  void async_mutator_flush(const MutatorAsync mutator) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->async_mutator_flush(mutator);
    }
    ifaces_[i]->async_mutator_flush(mutator);
  }

  void flush_mutator_async(const MutatorAsync mutator) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->flush_mutator_async(mutator);
    }
    ifaces_[i]->flush_mutator_async(mutator);
  }

  bool namespace_exists(const std::string& ns) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->namespace_exists(ns);
    }
    return ifaces_[i]->namespace_exists(ns);
  }

  bool exists_namespace(const std::string& ns) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->exists_namespace(ns);
    }
    return ifaces_[i]->exists_namespace(ns);
  }

  bool exists_table(const Namespace ns, const std::string& name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->exists_table(ns, name);
    }
    return ifaces_[i]->exists_table(ns, name);
  }

  bool table_exists(const Namespace ns, const std::string& name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->table_exists(ns, name);
    }
    return ifaces_[i]->table_exists(ns, name);
  }

  void table_get_id(std::string& _return, const Namespace ns, const std::string& table_name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->table_get_id(_return, ns, table_name);
    }
    ifaces_[i]->table_get_id(_return, ns, table_name);
    return;
  }

  void get_table_id(std::string& _return, const Namespace ns, const std::string& table_name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_table_id(_return, ns, table_name);
    }
    ifaces_[i]->get_table_id(_return, ns, table_name);
    return;
  }

  void table_get_schema_str(std::string& _return, const Namespace ns, const std::string& table_name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->table_get_schema_str(_return, ns, table_name);
    }
    ifaces_[i]->table_get_schema_str(_return, ns, table_name);
    return;
  }

  void get_schema_str(std::string& _return, const Namespace ns, const std::string& table_name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_schema_str(_return, ns, table_name);
    }
    ifaces_[i]->get_schema_str(_return, ns, table_name);
    return;
  }

  void table_get_schema_str_with_ids(std::string& _return, const Namespace ns, const std::string& table_name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->table_get_schema_str_with_ids(_return, ns, table_name);
    }
    ifaces_[i]->table_get_schema_str_with_ids(_return, ns, table_name);
    return;
  }

  void get_schema_str_with_ids(std::string& _return, const Namespace ns, const std::string& table_name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_schema_str_with_ids(_return, ns, table_name);
    }
    ifaces_[i]->get_schema_str_with_ids(_return, ns, table_name);
    return;
  }

  void table_get_schema(Schema& _return, const Namespace ns, const std::string& table_name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->table_get_schema(_return, ns, table_name);
    }
    ifaces_[i]->table_get_schema(_return, ns, table_name);
    return;
  }

  void get_schema(Schema& _return, const Namespace ns, const std::string& table_name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_schema(_return, ns, table_name);
    }
    ifaces_[i]->get_schema(_return, ns, table_name);
    return;
  }

  void get_tables(std::vector<std::string> & _return, const Namespace ns) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_tables(_return, ns);
    }
    ifaces_[i]->get_tables(_return, ns);
    return;
  }

  void namespace_get_listing(std::vector<NamespaceListing> & _return, const Namespace ns) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->namespace_get_listing(_return, ns);
    }
    ifaces_[i]->namespace_get_listing(_return, ns);
    return;
  }

  void get_listing(std::vector<NamespaceListing> & _return, const Namespace ns) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_listing(_return, ns);
    }
    ifaces_[i]->get_listing(_return, ns);
    return;
  }

  void table_get_splits(std::vector<TableSplit> & _return, const Namespace ns, const std::string& table_name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->table_get_splits(_return, ns, table_name);
    }
    ifaces_[i]->table_get_splits(_return, ns, table_name);
    return;
  }

  void get_table_splits(std::vector<TableSplit> & _return, const Namespace ns, const std::string& table_name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_table_splits(_return, ns, table_name);
    }
    ifaces_[i]->get_table_splits(_return, ns, table_name);
    return;
  }

  void namespace_drop(const std::string& ns, const bool if_exists) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->namespace_drop(ns, if_exists);
    }
    ifaces_[i]->namespace_drop(ns, if_exists);
  }

  void drop_namespace(const std::string& ns, const bool if_exists) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->drop_namespace(ns, if_exists);
    }
    ifaces_[i]->drop_namespace(ns, if_exists);
  }

  void rename_table(const Namespace ns, const std::string& name, const std::string& new_name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->rename_table(ns, name, new_name);
    }
    ifaces_[i]->rename_table(ns, name, new_name);
  }

  void table_rename(const Namespace ns, const std::string& name, const std::string& new_name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->table_rename(ns, name, new_name);
    }
    ifaces_[i]->table_rename(ns, name, new_name);
  }

  void drop_table(const Namespace ns, const std::string& name, const bool if_exists) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->drop_table(ns, name, if_exists);
    }
    ifaces_[i]->drop_table(ns, name, if_exists);
  }

  void table_drop(const Namespace ns, const std::string& name, const bool if_exists) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->table_drop(ns, name, if_exists);
    }
    ifaces_[i]->table_drop(ns, name, if_exists);
  }

  void generate_guid(std::string& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->generate_guid(_return);
    }
    ifaces_[i]->generate_guid(_return);
    return;
  }

  void create_cell_unique(std::string& _return, const Namespace ns, const std::string& table_name, const Key& key, const std::string& value) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->create_cell_unique(_return, ns, table_name, key, value);
    }
    ifaces_[i]->create_cell_unique(_return, ns, table_name, key, value);
    return;
  }

  void error_get_text(std::string& _return, const int32_t error_code) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->error_get_text(_return, error_code);
    }
    ifaces_[i]->error_get_text(_return, error_code);
    return;
  }

  void status(Status& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->status(_return);
    }
    ifaces_[i]->status(_return);
    return;
  }

  void shutdown() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->shutdown();
    }
    ifaces_[i]->shutdown();
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class ClientServiceConcurrentClient : virtual public ClientServiceIf {
 public:
  ClientServiceConcurrentClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  ClientServiceConcurrentClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void namespace_create(const std::string& ns);
  int32_t send_namespace_create(const std::string& ns);
  void recv_namespace_create(const int32_t seqid);
  void create_namespace(const std::string& ns);
  int32_t send_create_namespace(const std::string& ns);
  void recv_create_namespace(const int32_t seqid);
  void table_create(const Namespace ns, const std::string& table_name, const Schema& schema);
  int32_t send_table_create(const Namespace ns, const std::string& table_name, const Schema& schema);
  void recv_table_create(const int32_t seqid);
  void table_alter(const Namespace ns, const std::string& table_name, const Schema& schema);
  int32_t send_table_alter(const Namespace ns, const std::string& table_name, const Schema& schema);
  void recv_table_alter(const int32_t seqid);
  void refresh_table(const Namespace ns, const std::string& table_name);
  int32_t send_refresh_table(const Namespace ns, const std::string& table_name);
  void recv_refresh_table(const int32_t seqid);
  Namespace namespace_open(const std::string& ns);
  int32_t send_namespace_open(const std::string& ns);
  Namespace recv_namespace_open(const int32_t seqid);
  Namespace open_namespace(const std::string& ns);
  int32_t send_open_namespace(const std::string& ns);
  Namespace recv_open_namespace(const int32_t seqid);
  void namespace_close(const Namespace ns);
  int32_t send_namespace_close(const Namespace ns);
  void recv_namespace_close(const int32_t seqid);
  void close_namespace(const Namespace ns);
  int32_t send_close_namespace(const Namespace ns);
  void recv_close_namespace(const int32_t seqid);
  Future future_open(const int32_t capacity);
  int32_t send_future_open(const int32_t capacity);
  Future recv_future_open(const int32_t seqid);
  Future open_future(const int32_t capacity);
  int32_t send_open_future(const int32_t capacity);
  Future recv_open_future(const int32_t seqid);
  void future_cancel(const Future ff);
  int32_t send_future_cancel(const Future ff);
  void recv_future_cancel(const int32_t seqid);
  void cancel_future(const Future ff);
  int32_t send_cancel_future(const Future ff);
  void recv_cancel_future(const int32_t seqid);
  void future_get_result(Result& _return, const Future ff, const int32_t timeout_millis);
  int32_t send_future_get_result(const Future ff, const int32_t timeout_millis);
  void recv_future_get_result(Result& _return, const int32_t seqid);
  void get_future_result(Result& _return, const Future ff, const int32_t timeout_millis);
  int32_t send_get_future_result(const Future ff, const int32_t timeout_millis);
  void recv_get_future_result(Result& _return, const int32_t seqid);
  void future_get_result_as_arrays(ResultAsArrays& _return, const Future ff, const int32_t timeout_millis);
  int32_t send_future_get_result_as_arrays(const Future ff, const int32_t timeout_millis);
  void recv_future_get_result_as_arrays(ResultAsArrays& _return, const int32_t seqid);
  void get_future_result_as_arrays(ResultAsArrays& _return, const Future ff, const int32_t timeout_millis);
  int32_t send_get_future_result_as_arrays(const Future ff, const int32_t timeout_millis);
  void recv_get_future_result_as_arrays(ResultAsArrays& _return, const int32_t seqid);
  void future_get_result_serialized(ResultSerialized& _return, const Future ff, const int32_t timeout_millis);
  int32_t send_future_get_result_serialized(const Future ff, const int32_t timeout_millis);
  void recv_future_get_result_serialized(ResultSerialized& _return, const int32_t seqid);
  void get_future_result_serialized(ResultSerialized& _return, const Future ff, const int32_t timeout_millis);
  int32_t send_get_future_result_serialized(const Future ff, const int32_t timeout_millis);
  void recv_get_future_result_serialized(ResultSerialized& _return, const int32_t seqid);
  bool future_is_empty(const Future ff);
  int32_t send_future_is_empty(const Future ff);
  bool recv_future_is_empty(const int32_t seqid);
  bool future_is_full(const Future ff);
  int32_t send_future_is_full(const Future ff);
  bool recv_future_is_full(const int32_t seqid);
  bool future_is_cancelled(const Future ff);
  int32_t send_future_is_cancelled(const Future ff);
  bool recv_future_is_cancelled(const int32_t seqid);
  bool future_has_outstanding(const Future ff);
  int32_t send_future_has_outstanding(const Future ff);
  bool recv_future_has_outstanding(const int32_t seqid);
  void future_close(const Future ff);
  int32_t send_future_close(const Future ff);
  void recv_future_close(const int32_t seqid);
  void close_future(const Future ff);
  int32_t send_close_future(const Future ff);
  void recv_close_future(const int32_t seqid);
  Scanner scanner_open(const Namespace ns, const std::string& table_name, const ScanSpec& scan_spec);
  int32_t send_scanner_open(const Namespace ns, const std::string& table_name, const ScanSpec& scan_spec);
  Scanner recv_scanner_open(const int32_t seqid);
  Scanner open_scanner(const Namespace ns, const std::string& table_name, const ScanSpec& scan_spec);
  int32_t send_open_scanner(const Namespace ns, const std::string& table_name, const ScanSpec& scan_spec);
  Scanner recv_open_scanner(const int32_t seqid);
  ScannerAsync async_scanner_open(const Namespace ns, const std::string& table_name, const Future future, const ScanSpec& scan_spec);
  int32_t send_async_scanner_open(const Namespace ns, const std::string& table_name, const Future future, const ScanSpec& scan_spec);
  ScannerAsync recv_async_scanner_open(const int32_t seqid);
  ScannerAsync open_scanner_async(const Namespace ns, const std::string& table_name, const Future future, const ScanSpec& scan_spec);
  int32_t send_open_scanner_async(const Namespace ns, const std::string& table_name, const Future future, const ScanSpec& scan_spec);
  ScannerAsync recv_open_scanner_async(const int32_t seqid);
  void scanner_close(const Scanner scanner);
  int32_t send_scanner_close(const Scanner scanner);
  void recv_scanner_close(const int32_t seqid);
  void close_scanner(const Scanner scanner);
  int32_t send_close_scanner(const Scanner scanner);
  void recv_close_scanner(const int32_t seqid);
  void async_scanner_cancel(const ScannerAsync scanner);
  int32_t send_async_scanner_cancel(const ScannerAsync scanner);
  void recv_async_scanner_cancel(const int32_t seqid);
  void cancel_scanner_async(const ScannerAsync scanner);
  int32_t send_cancel_scanner_async(const ScannerAsync scanner);
  void recv_cancel_scanner_async(const int32_t seqid);
  void async_scanner_close(const ScannerAsync scanner);
  int32_t send_async_scanner_close(const ScannerAsync scanner);
  void recv_async_scanner_close(const int32_t seqid);
  void close_scanner_async(const ScannerAsync scanner);
  int32_t send_close_scanner_async(const ScannerAsync scanner);
  void recv_close_scanner_async(const int32_t seqid);
  void scanner_get_cells(std::vector<Cell> & _return, const Scanner scanner);
  int32_t send_scanner_get_cells(const Scanner scanner);
  void recv_scanner_get_cells(std::vector<Cell> & _return, const int32_t seqid);
  void next_cells(std::vector<Cell> & _return, const Scanner scanner);
  int32_t send_next_cells(const Scanner scanner);
  void recv_next_cells(std::vector<Cell> & _return, const int32_t seqid);
  void scanner_get_cells_as_arrays(std::vector<CellAsArray> & _return, const Scanner scanner);
  int32_t send_scanner_get_cells_as_arrays(const Scanner scanner);
  void recv_scanner_get_cells_as_arrays(std::vector<CellAsArray> & _return, const int32_t seqid);
  void next_cells_as_arrays(std::vector<CellAsArray> & _return, const Scanner scanner);
  int32_t send_next_cells_as_arrays(const Scanner scanner);
  void recv_next_cells_as_arrays(std::vector<CellAsArray> & _return, const int32_t seqid);
  void scanner_get_cells_serialized(CellsSerialized& _return, const Scanner scanner);
  int32_t send_scanner_get_cells_serialized(const Scanner scanner);
  void recv_scanner_get_cells_serialized(CellsSerialized& _return, const int32_t seqid);
  void next_cells_serialized(CellsSerialized& _return, const Scanner scanner);
  int32_t send_next_cells_serialized(const Scanner scanner);
  void recv_next_cells_serialized(CellsSerialized& _return, const int32_t seqid);
  void scanner_get_row(std::vector<Cell> & _return, const Scanner scanner);
  int32_t send_scanner_get_row(const Scanner scanner);
  void recv_scanner_get_row(std::vector<Cell> & _return, const int32_t seqid);
  void next_row(std::vector<Cell> & _return, const Scanner scanner);
  int32_t send_next_row(const Scanner scanner);
  void recv_next_row(std::vector<Cell> & _return, const int32_t seqid);
  void scanner_get_row_as_arrays(std::vector<CellAsArray> & _return, const Scanner scanner);
  int32_t send_scanner_get_row_as_arrays(const Scanner scanner);
  void recv_scanner_get_row_as_arrays(std::vector<CellAsArray> & _return, const int32_t seqid);
  void next_row_as_arrays(std::vector<CellAsArray> & _return, const Scanner scanner);
  int32_t send_next_row_as_arrays(const Scanner scanner);
  void recv_next_row_as_arrays(std::vector<CellAsArray> & _return, const int32_t seqid);
  void scanner_get_row_serialized(CellsSerialized& _return, const Scanner scanner);
  int32_t send_scanner_get_row_serialized(const Scanner scanner);
  void recv_scanner_get_row_serialized(CellsSerialized& _return, const int32_t seqid);
  void next_row_serialized(CellsSerialized& _return, const Scanner scanner);
  int32_t send_next_row_serialized(const Scanner scanner);
  void recv_next_row_serialized(CellsSerialized& _return, const int32_t seqid);
  void get_row(std::vector<Cell> & _return, const Namespace ns, const std::string& table_name, const std::string& row);
  int32_t send_get_row(const Namespace ns, const std::string& table_name, const std::string& row);
  void recv_get_row(std::vector<Cell> & _return, const int32_t seqid);
  void get_row_as_arrays(std::vector<CellAsArray> & _return, const Namespace ns, const std::string& name, const std::string& row);
  int32_t send_get_row_as_arrays(const Namespace ns, const std::string& name, const std::string& row);
  void recv_get_row_as_arrays(std::vector<CellAsArray> & _return, const int32_t seqid);
  void get_row_serialized(CellsSerialized& _return, const Namespace ns, const std::string& table_name, const std::string& row);
  int32_t send_get_row_serialized(const Namespace ns, const std::string& table_name, const std::string& row);
  void recv_get_row_serialized(CellsSerialized& _return, const int32_t seqid);
  void get_cell(Value& _return, const Namespace ns, const std::string& table_name, const std::string& row, const std::string& column);
  int32_t send_get_cell(const Namespace ns, const std::string& table_name, const std::string& row, const std::string& column);
  void recv_get_cell(Value& _return, const int32_t seqid);
  void get_cells(std::vector<Cell> & _return, const Namespace ns, const std::string& table_name, const ScanSpec& scan_spec);
  int32_t send_get_cells(const Namespace ns, const std::string& table_name, const ScanSpec& scan_spec);
  void recv_get_cells(std::vector<Cell> & _return, const int32_t seqid);
  void get_cells_as_arrays(std::vector<CellAsArray> & _return, const Namespace ns, const std::string& name, const ScanSpec& scan_spec);
  int32_t send_get_cells_as_arrays(const Namespace ns, const std::string& name, const ScanSpec& scan_spec);
  void recv_get_cells_as_arrays(std::vector<CellAsArray> & _return, const int32_t seqid);
  void get_cells_serialized(CellsSerialized& _return, const Namespace ns, const std::string& name, const ScanSpec& scan_spec);
  int32_t send_get_cells_serialized(const Namespace ns, const std::string& name, const ScanSpec& scan_spec);
  void recv_get_cells_serialized(CellsSerialized& _return, const int32_t seqid);
  void shared_mutator_refresh(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec);
  int32_t send_shared_mutator_refresh(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec);
  void recv_shared_mutator_refresh(const int32_t seqid);
  void refresh_shared_mutator(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec);
  int32_t send_refresh_shared_mutator(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec);
  void recv_refresh_shared_mutator(const int32_t seqid);
  void shared_mutator_set_cells(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<Cell> & cells);
  int32_t send_shared_mutator_set_cells(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<Cell> & cells);
  void recv_shared_mutator_set_cells(const int32_t seqid);
  void offer_cells(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<Cell> & cells);
  int32_t send_offer_cells(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<Cell> & cells);
  void recv_offer_cells(const int32_t seqid);
  void shared_mutator_set_cells_as_arrays(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<CellAsArray> & cells);
  int32_t send_shared_mutator_set_cells_as_arrays(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<CellAsArray> & cells);
  void recv_shared_mutator_set_cells_as_arrays(const int32_t seqid);
  void offer_cells_as_arrays(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<CellAsArray> & cells);
  int32_t send_offer_cells_as_arrays(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const std::vector<CellAsArray> & cells);
  void recv_offer_cells_as_arrays(const int32_t seqid);
  void shared_mutator_set_cell(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const Cell& cell);
  int32_t send_shared_mutator_set_cell(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const Cell& cell);
  void recv_shared_mutator_set_cell(const int32_t seqid);
  void offer_cell(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const Cell& cell);
  int32_t send_offer_cell(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const Cell& cell);
  void recv_offer_cell(const int32_t seqid);
  void shared_mutator_set_cell_as_array(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const CellAsArray& cell);
  int32_t send_shared_mutator_set_cell_as_array(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const CellAsArray& cell);
  void recv_shared_mutator_set_cell_as_array(const int32_t seqid);
  void offer_cell_as_array(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const CellAsArray& cell);
  int32_t send_offer_cell_as_array(const Namespace ns, const std::string& table_name, const MutateSpec& mutate_spec, const CellAsArray& cell);
  void recv_offer_cell_as_array(const int32_t seqid);
  Mutator mutator_open(const Namespace ns, const std::string& table_name, const int32_t flags, const int32_t flush_interval);
  int32_t send_mutator_open(const Namespace ns, const std::string& table_name, const int32_t flags, const int32_t flush_interval);
  Mutator recv_mutator_open(const int32_t seqid);
  Mutator open_mutator(const Namespace ns, const std::string& table_name, const int32_t flags, const int32_t flush_interval);
  int32_t send_open_mutator(const Namespace ns, const std::string& table_name, const int32_t flags, const int32_t flush_interval);
  Mutator recv_open_mutator(const int32_t seqid);
  MutatorAsync async_mutator_open(const Namespace ns, const std::string& table_name, const Future future, const int32_t flags);
  int32_t send_async_mutator_open(const Namespace ns, const std::string& table_name, const Future future, const int32_t flags);
  MutatorAsync recv_async_mutator_open(const int32_t seqid);
  MutatorAsync open_mutator_async(const Namespace ns, const std::string& table_name, const Future future, const int32_t flags);
  int32_t send_open_mutator_async(const Namespace ns, const std::string& table_name, const Future future, const int32_t flags);
  MutatorAsync recv_open_mutator_async(const int32_t seqid);
  void mutator_close(const Mutator mutator);
  int32_t send_mutator_close(const Mutator mutator);
  void recv_mutator_close(const int32_t seqid);
  void close_mutator(const Mutator mutator);
  int32_t send_close_mutator(const Mutator mutator);
  void recv_close_mutator(const int32_t seqid);
  void async_mutator_cancel(const MutatorAsync mutator);
  int32_t send_async_mutator_cancel(const MutatorAsync mutator);
  void recv_async_mutator_cancel(const int32_t seqid);
  void cancel_mutator_async(const MutatorAsync mutator);
  int32_t send_cancel_mutator_async(const MutatorAsync mutator);
  void recv_cancel_mutator_async(const int32_t seqid);
  void async_mutator_close(const MutatorAsync mutator);
  int32_t send_async_mutator_close(const MutatorAsync mutator);
  void recv_async_mutator_close(const int32_t seqid);
  void close_mutator_async(const MutatorAsync mutator);
  int32_t send_close_mutator_async(const MutatorAsync mutator);
  void recv_close_mutator_async(const int32_t seqid);
  void mutator_set_cell(const Mutator mutator, const Cell& cell);
  int32_t send_mutator_set_cell(const Mutator mutator, const Cell& cell);
  void recv_mutator_set_cell(const int32_t seqid);
  void set_cell(const Namespace ns, const std::string& table_name, const Cell& cell);
  int32_t send_set_cell(const Namespace ns, const std::string& table_name, const Cell& cell);
  void recv_set_cell(const int32_t seqid);
  void mutator_set_cell_as_array(const Mutator mutator, const CellAsArray& cell);
  int32_t send_mutator_set_cell_as_array(const Mutator mutator, const CellAsArray& cell);
  void recv_mutator_set_cell_as_array(const int32_t seqid);
  void set_cell_as_array(const Namespace ns, const std::string& table_name, const CellAsArray& cell);
  int32_t send_set_cell_as_array(const Namespace ns, const std::string& table_name, const CellAsArray& cell);
  void recv_set_cell_as_array(const int32_t seqid);
  void mutator_set_cells(const Mutator mutator, const std::vector<Cell> & cells);
  int32_t send_mutator_set_cells(const Mutator mutator, const std::vector<Cell> & cells);
  void recv_mutator_set_cells(const int32_t seqid);
  void set_cells(const Namespace ns, const std::string& table_name, const std::vector<Cell> & cells);
  int32_t send_set_cells(const Namespace ns, const std::string& table_name, const std::vector<Cell> & cells);
  void recv_set_cells(const int32_t seqid);
  void mutator_set_cells_as_arrays(const Mutator mutator, const std::vector<CellAsArray> & cells);
  int32_t send_mutator_set_cells_as_arrays(const Mutator mutator, const std::vector<CellAsArray> & cells);
  void recv_mutator_set_cells_as_arrays(const int32_t seqid);
  void set_cells_as_arrays(const Namespace ns, const std::string& table_name, const std::vector<CellAsArray> & cells);
  int32_t send_set_cells_as_arrays(const Namespace ns, const std::string& table_name, const std::vector<CellAsArray> & cells);
  void recv_set_cells_as_arrays(const int32_t seqid);
  void mutator_set_cells_serialized(const Mutator mutator, const CellsSerialized& cells, const bool flush);
  int32_t send_mutator_set_cells_serialized(const Mutator mutator, const CellsSerialized& cells, const bool flush);
  void recv_mutator_set_cells_serialized(const int32_t seqid);
  void set_cells_serialized(const Namespace ns, const std::string& table_name, const CellsSerialized& cells);
  int32_t send_set_cells_serialized(const Namespace ns, const std::string& table_name, const CellsSerialized& cells);
  void recv_set_cells_serialized(const int32_t seqid);
  void mutator_flush(const Mutator mutator);
  int32_t send_mutator_flush(const Mutator mutator);
  void recv_mutator_flush(const int32_t seqid);
  void flush_mutator(const Mutator mutator);
  int32_t send_flush_mutator(const Mutator mutator);
  void recv_flush_mutator(const int32_t seqid);
  void async_mutator_set_cell(const MutatorAsync mutator, const Cell& cell);
  int32_t send_async_mutator_set_cell(const MutatorAsync mutator, const Cell& cell);
  void recv_async_mutator_set_cell(const int32_t seqid);
  void set_cell_async(const MutatorAsync mutator, const Cell& cell);
  int32_t send_set_cell_async(const MutatorAsync mutator, const Cell& cell);
  void recv_set_cell_async(const int32_t seqid);
  void async_mutator_set_cell_as_array(const MutatorAsync mutator, const CellAsArray& cell);
  int32_t send_async_mutator_set_cell_as_array(const MutatorAsync mutator, const CellAsArray& cell);
  void recv_async_mutator_set_cell_as_array(const int32_t seqid);
  void set_cell_as_array_async(const MutatorAsync mutator, const CellAsArray& cell);
  int32_t send_set_cell_as_array_async(const MutatorAsync mutator, const CellAsArray& cell);
  void recv_set_cell_as_array_async(const int32_t seqid);
  void async_mutator_set_cells(const MutatorAsync mutator, const std::vector<Cell> & cells);
  int32_t send_async_mutator_set_cells(const MutatorAsync mutator, const std::vector<Cell> & cells);
  void recv_async_mutator_set_cells(const int32_t seqid);
  void set_cells_async(const MutatorAsync mutator, const std::vector<Cell> & cells);
  int32_t send_set_cells_async(const MutatorAsync mutator, const std::vector<Cell> & cells);
  void recv_set_cells_async(const int32_t seqid);
  void async_mutator_set_cells_as_arrays(const MutatorAsync mutator, const std::vector<CellAsArray> & cells);
  int32_t send_async_mutator_set_cells_as_arrays(const MutatorAsync mutator, const std::vector<CellAsArray> & cells);
  void recv_async_mutator_set_cells_as_arrays(const int32_t seqid);
  void set_cells_as_arrays_async(const MutatorAsync mutator, const std::vector<CellAsArray> & cells);
  int32_t send_set_cells_as_arrays_async(const MutatorAsync mutator, const std::vector<CellAsArray> & cells);
  void recv_set_cells_as_arrays_async(const int32_t seqid);
  void async_mutator_set_cells_serialized(const MutatorAsync mutator, const CellsSerialized& cells, const bool flush);
  int32_t send_async_mutator_set_cells_serialized(const MutatorAsync mutator, const CellsSerialized& cells, const bool flush);
  void recv_async_mutator_set_cells_serialized(const int32_t seqid);
  void set_cells_serialized_async(const MutatorAsync mutator, const CellsSerialized& cells, const bool flush);
  int32_t send_set_cells_serialized_async(const MutatorAsync mutator, const CellsSerialized& cells, const bool flush);
  void recv_set_cells_serialized_async(const int32_t seqid);
  void async_mutator_flush(const MutatorAsync mutator);
  int32_t send_async_mutator_flush(const MutatorAsync mutator);
  void recv_async_mutator_flush(const int32_t seqid);
  void flush_mutator_async(const MutatorAsync mutator);
  int32_t send_flush_mutator_async(const MutatorAsync mutator);
  void recv_flush_mutator_async(const int32_t seqid);
  bool namespace_exists(const std::string& ns);
  int32_t send_namespace_exists(const std::string& ns);
  bool recv_namespace_exists(const int32_t seqid);
  bool exists_namespace(const std::string& ns);
  int32_t send_exists_namespace(const std::string& ns);
  bool recv_exists_namespace(const int32_t seqid);
  bool exists_table(const Namespace ns, const std::string& name);
  int32_t send_exists_table(const Namespace ns, const std::string& name);
  bool recv_exists_table(const int32_t seqid);
  bool table_exists(const Namespace ns, const std::string& name);
  int32_t send_table_exists(const Namespace ns, const std::string& name);
  bool recv_table_exists(const int32_t seqid);
  void table_get_id(std::string& _return, const Namespace ns, const std::string& table_name);
  int32_t send_table_get_id(const Namespace ns, const std::string& table_name);
  void recv_table_get_id(std::string& _return, const int32_t seqid);
  void get_table_id(std::string& _return, const Namespace ns, const std::string& table_name);
  int32_t send_get_table_id(const Namespace ns, const std::string& table_name);
  void recv_get_table_id(std::string& _return, const int32_t seqid);
  void table_get_schema_str(std::string& _return, const Namespace ns, const std::string& table_name);
  int32_t send_table_get_schema_str(const Namespace ns, const std::string& table_name);
  void recv_table_get_schema_str(std::string& _return, const int32_t seqid);
  void get_schema_str(std::string& _return, const Namespace ns, const std::string& table_name);
  int32_t send_get_schema_str(const Namespace ns, const std::string& table_name);
  void recv_get_schema_str(std::string& _return, const int32_t seqid);
  void table_get_schema_str_with_ids(std::string& _return, const Namespace ns, const std::string& table_name);
  int32_t send_table_get_schema_str_with_ids(const Namespace ns, const std::string& table_name);
  void recv_table_get_schema_str_with_ids(std::string& _return, const int32_t seqid);
  void get_schema_str_with_ids(std::string& _return, const Namespace ns, const std::string& table_name);
  int32_t send_get_schema_str_with_ids(const Namespace ns, const std::string& table_name);
  void recv_get_schema_str_with_ids(std::string& _return, const int32_t seqid);
  void table_get_schema(Schema& _return, const Namespace ns, const std::string& table_name);
  int32_t send_table_get_schema(const Namespace ns, const std::string& table_name);
  void recv_table_get_schema(Schema& _return, const int32_t seqid);
  void get_schema(Schema& _return, const Namespace ns, const std::string& table_name);
  int32_t send_get_schema(const Namespace ns, const std::string& table_name);
  void recv_get_schema(Schema& _return, const int32_t seqid);
  void get_tables(std::vector<std::string> & _return, const Namespace ns);
  int32_t send_get_tables(const Namespace ns);
  void recv_get_tables(std::vector<std::string> & _return, const int32_t seqid);
  void namespace_get_listing(std::vector<NamespaceListing> & _return, const Namespace ns);
  int32_t send_namespace_get_listing(const Namespace ns);
  void recv_namespace_get_listing(std::vector<NamespaceListing> & _return, const int32_t seqid);
  void get_listing(std::vector<NamespaceListing> & _return, const Namespace ns);
  int32_t send_get_listing(const Namespace ns);
  void recv_get_listing(std::vector<NamespaceListing> & _return, const int32_t seqid);
  void table_get_splits(std::vector<TableSplit> & _return, const Namespace ns, const std::string& table_name);
  int32_t send_table_get_splits(const Namespace ns, const std::string& table_name);
  void recv_table_get_splits(std::vector<TableSplit> & _return, const int32_t seqid);
  void get_table_splits(std::vector<TableSplit> & _return, const Namespace ns, const std::string& table_name);
  int32_t send_get_table_splits(const Namespace ns, const std::string& table_name);
  void recv_get_table_splits(std::vector<TableSplit> & _return, const int32_t seqid);
  void namespace_drop(const std::string& ns, const bool if_exists);
  int32_t send_namespace_drop(const std::string& ns, const bool if_exists);
  void recv_namespace_drop(const int32_t seqid);
  void drop_namespace(const std::string& ns, const bool if_exists);
  int32_t send_drop_namespace(const std::string& ns, const bool if_exists);
  void recv_drop_namespace(const int32_t seqid);
  void rename_table(const Namespace ns, const std::string& name, const std::string& new_name);
  int32_t send_rename_table(const Namespace ns, const std::string& name, const std::string& new_name);
  void recv_rename_table(const int32_t seqid);
  void table_rename(const Namespace ns, const std::string& name, const std::string& new_name);
  int32_t send_table_rename(const Namespace ns, const std::string& name, const std::string& new_name);
  void recv_table_rename(const int32_t seqid);
  void drop_table(const Namespace ns, const std::string& name, const bool if_exists);
  int32_t send_drop_table(const Namespace ns, const std::string& name, const bool if_exists);
  void recv_drop_table(const int32_t seqid);
  void table_drop(const Namespace ns, const std::string& name, const bool if_exists);
  int32_t send_table_drop(const Namespace ns, const std::string& name, const bool if_exists);
  void recv_table_drop(const int32_t seqid);
  void generate_guid(std::string& _return);
  int32_t send_generate_guid();
  void recv_generate_guid(std::string& _return, const int32_t seqid);
  void create_cell_unique(std::string& _return, const Namespace ns, const std::string& table_name, const Key& key, const std::string& value);
  int32_t send_create_cell_unique(const Namespace ns, const std::string& table_name, const Key& key, const std::string& value);
  void recv_create_cell_unique(std::string& _return, const int32_t seqid);
  void error_get_text(std::string& _return, const int32_t error_code);
  int32_t send_error_get_text(const int32_t error_code);
  void recv_error_get_text(std::string& _return, const int32_t seqid);
  void status(Status& _return);
  int32_t send_status();
  void recv_status(Status& _return, const int32_t seqid);
  void shutdown();
  int32_t send_shutdown();
  void recv_shutdown(const int32_t seqid);
 protected:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  ::apache::thrift::async::TConcurrentClientSyncInfo sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif

}} // namespace

#endif
