/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Client_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace Hypertable { namespace ThriftGen {

int _kColumnPredicateOperationValues[] = {
  ColumnPredicateOperation::EXACT_MATCH,
  ColumnPredicateOperation::PREFIX_MATCH,
  ColumnPredicateOperation::REGEX_MATCH,
  ColumnPredicateOperation::VALUE_MATCH,
  ColumnPredicateOperation::QUALIFIER_EXACT_MATCH,
  ColumnPredicateOperation::QUALIFIER_PREFIX_MATCH,
  ColumnPredicateOperation::QUALIFIER_REGEX_MATCH,
  ColumnPredicateOperation::QUALIFIER_MATCH
};
const char* _kColumnPredicateOperationNames[] = {
  "EXACT_MATCH",
  "PREFIX_MATCH",
  "REGEX_MATCH",
  "VALUE_MATCH",
  "QUALIFIER_EXACT_MATCH",
  "QUALIFIER_PREFIX_MATCH",
  "QUALIFIER_REGEX_MATCH",
  "QUALIFIER_MATCH"
};
const std::map<int, const char*> _ColumnPredicateOperation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kColumnPredicateOperationValues, _kColumnPredicateOperationNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ColumnPredicateOperation::type& val) {
  std::map<int, const char*>::const_iterator it = _ColumnPredicateOperation_VALUES_TO_NAMES.find(val);
  if (it != _ColumnPredicateOperation_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kKeyFlagValues[] = {
  KeyFlag::DELETE_ROW,
  KeyFlag::DELETE_CF,
  KeyFlag::DELETE_CELL,
  KeyFlag::DELETE_CELL_VERSION,
  KeyFlag::INSERT
};
const char* _kKeyFlagNames[] = {
  "DELETE_ROW",
  "DELETE_CF",
  "DELETE_CELL",
  "DELETE_CELL_VERSION",
  "INSERT"
};
const std::map<int, const char*> _KeyFlag_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kKeyFlagValues, _kKeyFlagNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const KeyFlag::type& val) {
  std::map<int, const char*>::const_iterator it = _KeyFlag_VALUES_TO_NAMES.find(val);
  if (it != _KeyFlag_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kMutatorFlagValues[] = {
  MutatorFlag::NO_LOG_SYNC,
  MutatorFlag::IGNORE_UNKNOWN_CFS,
  MutatorFlag::NO_LOG
};
const char* _kMutatorFlagNames[] = {
  "NO_LOG_SYNC",
  "IGNORE_UNKNOWN_CFS",
  "NO_LOG"
};
const std::map<int, const char*> _MutatorFlag_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kMutatorFlagValues, _kMutatorFlagNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const MutatorFlag::type& val) {
  std::map<int, const char*>::const_iterator it = _MutatorFlag_VALUES_TO_NAMES.find(val);
  if (it != _MutatorFlag_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kStatusCodeValues[] = {
  StatusCode::OK,
  StatusCode::WARNING,
  StatusCode::CRITICAL,
  StatusCode::UNKNOWN
};
const char* _kStatusCodeNames[] = {
  "OK",
  "WARNING",
  "CRITICAL",
  "UNKNOWN"
};
const std::map<int, const char*> _StatusCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kStatusCodeValues, _kStatusCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const StatusCode::type& val) {
  std::map<int, const char*>::const_iterator it = _StatusCode_VALUES_TO_NAMES.find(val);
  if (it != _StatusCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


RowInterval::~RowInterval() throw() {
}


void RowInterval::__set_start_row(const std::string& val) {
  this->start_row = val;
__isset.start_row = true;
}

void RowInterval::__set_start_inclusive(const bool val) {
  this->start_inclusive = val;
__isset.start_inclusive = true;
}

void RowInterval::__set_end_row(const std::string& val) {
  this->end_row = val;
__isset.end_row = true;
}

void RowInterval::__set_end_inclusive(const bool val) {
  this->end_inclusive = val;
__isset.end_inclusive = true;
}

void RowInterval::__set_start_row_binary(const std::string& val) {
  this->start_row_binary = val;
__isset.start_row_binary = true;
}

void RowInterval::__set_end_row_binary(const std::string& val) {
  this->end_row_binary = val;
__isset.end_row_binary = true;
}
std::ostream& operator<<(std::ostream& out, const RowInterval& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RowInterval::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_row);
          this->__isset.start_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->start_inclusive);
          this->__isset.start_inclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_row);
          this->__isset.end_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->end_inclusive);
          this->__isset.end_inclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->start_row_binary);
          this->__isset.start_row_binary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->end_row_binary);
          this->__isset.end_row_binary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RowInterval::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RowInterval");

  if (this->__isset.start_row) {
    xfer += oprot->writeFieldBegin("start_row", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->start_row);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start_inclusive) {
    xfer += oprot->writeFieldBegin("start_inclusive", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->start_inclusive);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.end_row) {
    xfer += oprot->writeFieldBegin("end_row", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->end_row);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.end_inclusive) {
    xfer += oprot->writeFieldBegin("end_inclusive", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->end_inclusive);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start_row_binary) {
    xfer += oprot->writeFieldBegin("start_row_binary", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->start_row_binary);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.end_row_binary) {
    xfer += oprot->writeFieldBegin("end_row_binary", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeBinary(this->end_row_binary);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RowInterval &a, RowInterval &b) {
  using ::std::swap;
  swap(a.start_row, b.start_row);
  swap(a.start_inclusive, b.start_inclusive);
  swap(a.end_row, b.end_row);
  swap(a.end_inclusive, b.end_inclusive);
  swap(a.start_row_binary, b.start_row_binary);
  swap(a.end_row_binary, b.end_row_binary);
  swap(a.__isset, b.__isset);
}

RowInterval::RowInterval(const RowInterval& other0) {
  start_row = other0.start_row;
  start_inclusive = other0.start_inclusive;
  end_row = other0.end_row;
  end_inclusive = other0.end_inclusive;
  start_row_binary = other0.start_row_binary;
  end_row_binary = other0.end_row_binary;
  __isset = other0.__isset;
}
RowInterval& RowInterval::operator=(const RowInterval& other1) {
  start_row = other1.start_row;
  start_inclusive = other1.start_inclusive;
  end_row = other1.end_row;
  end_inclusive = other1.end_inclusive;
  start_row_binary = other1.start_row_binary;
  end_row_binary = other1.end_row_binary;
  __isset = other1.__isset;
  return *this;
}
void RowInterval::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RowInterval(";
  out << "start_row="; (__isset.start_row ? (out << to_string(start_row)) : (out << "<null>"));
  out << ", " << "start_inclusive="; (__isset.start_inclusive ? (out << to_string(start_inclusive)) : (out << "<null>"));
  out << ", " << "end_row="; (__isset.end_row ? (out << to_string(end_row)) : (out << "<null>"));
  out << ", " << "end_inclusive="; (__isset.end_inclusive ? (out << to_string(end_inclusive)) : (out << "<null>"));
  out << ", " << "start_row_binary="; (__isset.start_row_binary ? (out << to_string(start_row_binary)) : (out << "<null>"));
  out << ", " << "end_row_binary="; (__isset.end_row_binary ? (out << to_string(end_row_binary)) : (out << "<null>"));
  out << ")";
}


CellInterval::~CellInterval() throw() {
}


void CellInterval::__set_start_row(const std::string& val) {
  this->start_row = val;
__isset.start_row = true;
}

void CellInterval::__set_start_column(const std::string& val) {
  this->start_column = val;
__isset.start_column = true;
}

void CellInterval::__set_start_inclusive(const bool val) {
  this->start_inclusive = val;
__isset.start_inclusive = true;
}

void CellInterval::__set_end_row(const std::string& val) {
  this->end_row = val;
__isset.end_row = true;
}

void CellInterval::__set_end_column(const std::string& val) {
  this->end_column = val;
__isset.end_column = true;
}

void CellInterval::__set_end_inclusive(const bool val) {
  this->end_inclusive = val;
__isset.end_inclusive = true;
}
std::ostream& operator<<(std::ostream& out, const CellInterval& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellInterval::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_row);
          this->__isset.start_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_column);
          this->__isset.start_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->start_inclusive);
          this->__isset.start_inclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_row);
          this->__isset.end_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_column);
          this->__isset.end_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->end_inclusive);
          this->__isset.end_inclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellInterval::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellInterval");

  if (this->__isset.start_row) {
    xfer += oprot->writeFieldBegin("start_row", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->start_row);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start_column) {
    xfer += oprot->writeFieldBegin("start_column", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->start_column);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start_inclusive) {
    xfer += oprot->writeFieldBegin("start_inclusive", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->start_inclusive);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.end_row) {
    xfer += oprot->writeFieldBegin("end_row", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->end_row);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.end_column) {
    xfer += oprot->writeFieldBegin("end_column", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->end_column);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.end_inclusive) {
    xfer += oprot->writeFieldBegin("end_inclusive", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->end_inclusive);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellInterval &a, CellInterval &b) {
  using ::std::swap;
  swap(a.start_row, b.start_row);
  swap(a.start_column, b.start_column);
  swap(a.start_inclusive, b.start_inclusive);
  swap(a.end_row, b.end_row);
  swap(a.end_column, b.end_column);
  swap(a.end_inclusive, b.end_inclusive);
  swap(a.__isset, b.__isset);
}

CellInterval::CellInterval(const CellInterval& other2) {
  start_row = other2.start_row;
  start_column = other2.start_column;
  start_inclusive = other2.start_inclusive;
  end_row = other2.end_row;
  end_column = other2.end_column;
  end_inclusive = other2.end_inclusive;
  __isset = other2.__isset;
}
CellInterval& CellInterval::operator=(const CellInterval& other3) {
  start_row = other3.start_row;
  start_column = other3.start_column;
  start_inclusive = other3.start_inclusive;
  end_row = other3.end_row;
  end_column = other3.end_column;
  end_inclusive = other3.end_inclusive;
  __isset = other3.__isset;
  return *this;
}
void CellInterval::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellInterval(";
  out << "start_row="; (__isset.start_row ? (out << to_string(start_row)) : (out << "<null>"));
  out << ", " << "start_column="; (__isset.start_column ? (out << to_string(start_column)) : (out << "<null>"));
  out << ", " << "start_inclusive="; (__isset.start_inclusive ? (out << to_string(start_inclusive)) : (out << "<null>"));
  out << ", " << "end_row="; (__isset.end_row ? (out << to_string(end_row)) : (out << "<null>"));
  out << ", " << "end_column="; (__isset.end_column ? (out << to_string(end_column)) : (out << "<null>"));
  out << ", " << "end_inclusive="; (__isset.end_inclusive ? (out << to_string(end_inclusive)) : (out << "<null>"));
  out << ")";
}


ColumnPredicate::~ColumnPredicate() throw() {
}


void ColumnPredicate::__set_column_family(const std::string& val) {
  this->column_family = val;
__isset.column_family = true;
}

void ColumnPredicate::__set_column_qualifier(const std::string& val) {
  this->column_qualifier = val;
__isset.column_qualifier = true;
}

void ColumnPredicate::__set_operation(const int32_t val) {
  this->operation = val;
}

void ColumnPredicate::__set_value(const std::string& val) {
  this->value = val;
__isset.value = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnPredicate& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnPredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_family);
          this->__isset.column_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_qualifier);
          this->__isset.column_qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->operation);
          this->__isset.operation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnPredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnPredicate");

  if (this->__isset.column_family) {
    xfer += oprot->writeFieldBegin("column_family", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->column_family);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_qualifier) {
    xfer += oprot->writeFieldBegin("column_qualifier", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->column_qualifier);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("operation", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->operation);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnPredicate &a, ColumnPredicate &b) {
  using ::std::swap;
  swap(a.column_family, b.column_family);
  swap(a.column_qualifier, b.column_qualifier);
  swap(a.operation, b.operation);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

ColumnPredicate::ColumnPredicate(const ColumnPredicate& other4) {
  column_family = other4.column_family;
  column_qualifier = other4.column_qualifier;
  operation = other4.operation;
  value = other4.value;
  __isset = other4.__isset;
}
ColumnPredicate& ColumnPredicate::operator=(const ColumnPredicate& other5) {
  column_family = other5.column_family;
  column_qualifier = other5.column_qualifier;
  operation = other5.operation;
  value = other5.value;
  __isset = other5.__isset;
  return *this;
}
void ColumnPredicate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnPredicate(";
  out << "column_family="; (__isset.column_family ? (out << to_string(column_family)) : (out << "<null>"));
  out << ", " << "column_qualifier="; (__isset.column_qualifier ? (out << to_string(column_qualifier)) : (out << "<null>"));
  out << ", " << "operation=" << to_string(operation);
  out << ", " << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ")";
}


ScanSpec::~ScanSpec() throw() {
}


void ScanSpec::__set_row_intervals(const std::vector<RowInterval> & val) {
  this->row_intervals = val;
__isset.row_intervals = true;
}

void ScanSpec::__set_cell_intervals(const std::vector<CellInterval> & val) {
  this->cell_intervals = val;
__isset.cell_intervals = true;
}

void ScanSpec::__set_return_deletes(const bool val) {
  this->return_deletes = val;
__isset.return_deletes = true;
}

void ScanSpec::__set_versions(const int32_t val) {
  this->versions = val;
__isset.versions = true;
}

void ScanSpec::__set_row_limit(const int32_t val) {
  this->row_limit = val;
__isset.row_limit = true;
}

void ScanSpec::__set_start_time(const int64_t val) {
  this->start_time = val;
__isset.start_time = true;
}

void ScanSpec::__set_end_time(const int64_t val) {
  this->end_time = val;
__isset.end_time = true;
}

void ScanSpec::__set_columns(const std::vector<std::string> & val) {
  this->columns = val;
__isset.columns = true;
}

void ScanSpec::__set_keys_only(const bool val) {
  this->keys_only = val;
__isset.keys_only = true;
}

void ScanSpec::__set_cell_limit(const int32_t val) {
  this->cell_limit = val;
__isset.cell_limit = true;
}

void ScanSpec::__set_cell_limit_per_family(const int32_t val) {
  this->cell_limit_per_family = val;
__isset.cell_limit_per_family = true;
}

void ScanSpec::__set_row_regexp(const std::string& val) {
  this->row_regexp = val;
__isset.row_regexp = true;
}

void ScanSpec::__set_value_regexp(const std::string& val) {
  this->value_regexp = val;
__isset.value_regexp = true;
}

void ScanSpec::__set_scan_and_filter_rows(const bool val) {
  this->scan_and_filter_rows = val;
__isset.scan_and_filter_rows = true;
}

void ScanSpec::__set_row_offset(const int32_t val) {
  this->row_offset = val;
__isset.row_offset = true;
}

void ScanSpec::__set_cell_offset(const int32_t val) {
  this->cell_offset = val;
__isset.cell_offset = true;
}

void ScanSpec::__set_column_predicates(const std::vector<ColumnPredicate> & val) {
  this->column_predicates = val;
__isset.column_predicates = true;
}

void ScanSpec::__set_do_not_cache(const bool val) {
  this->do_not_cache = val;
__isset.do_not_cache = true;
}

void ScanSpec::__set_and_column_predicates(const bool val) {
  this->and_column_predicates = val;
__isset.and_column_predicates = true;
}
std::ostream& operator<<(std::ostream& out, const ScanSpec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScanSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_intervals.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->row_intervals.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += this->row_intervals[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cell_intervals.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size11);
            this->cell_intervals.resize(_size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              xfer += this->cell_intervals[_i15].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cell_intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->return_deletes);
          this->__isset.return_deletes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->versions);
          this->__isset.versions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->row_limit);
          this->__isset.row_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_time);
          this->__isset.start_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->end_time);
          this->__isset.end_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->columns.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += iprot->readString(this->columns[_i20]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->keys_only);
          this->__isset.keys_only = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cell_limit);
          this->__isset.cell_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cell_limit_per_family);
          this->__isset.cell_limit_per_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->row_regexp);
          this->__isset.row_regexp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value_regexp);
          this->__isset.value_regexp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->scan_and_filter_rows);
          this->__isset.scan_and_filter_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->row_offset);
          this->__isset.row_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cell_offset);
          this->__isset.cell_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_predicates.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readListBegin(_etype24, _size21);
            this->column_predicates.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              xfer += this->column_predicates[_i25].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_predicates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->do_not_cache);
          this->__isset.do_not_cache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->and_column_predicates);
          this->__isset.and_column_predicates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ScanSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScanSpec");

  if (this->__isset.row_intervals) {
    xfer += oprot->writeFieldBegin("row_intervals", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row_intervals.size()));
      std::vector<RowInterval> ::const_iterator _iter26;
      for (_iter26 = this->row_intervals.begin(); _iter26 != this->row_intervals.end(); ++_iter26)
      {
        xfer += (*_iter26).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_intervals) {
    xfer += oprot->writeFieldBegin("cell_intervals", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cell_intervals.size()));
      std::vector<CellInterval> ::const_iterator _iter27;
      for (_iter27 = this->cell_intervals.begin(); _iter27 != this->cell_intervals.end(); ++_iter27)
      {
        xfer += (*_iter27).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.return_deletes) {
    xfer += oprot->writeFieldBegin("return_deletes", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->return_deletes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.versions) {
    xfer += oprot->writeFieldBegin("versions", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->versions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.row_limit) {
    xfer += oprot->writeFieldBegin("row_limit", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->row_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start_time) {
    xfer += oprot->writeFieldBegin("start_time", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->start_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.end_time) {
    xfer += oprot->writeFieldBegin("end_time", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->end_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columns.size()));
      std::vector<std::string> ::const_iterator _iter28;
      for (_iter28 = this->columns.begin(); _iter28 != this->columns.end(); ++_iter28)
      {
        xfer += oprot->writeString((*_iter28));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.keys_only) {
    xfer += oprot->writeFieldBegin("keys_only", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->keys_only);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_limit_per_family) {
    xfer += oprot->writeFieldBegin("cell_limit_per_family", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->cell_limit_per_family);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.row_regexp) {
    xfer += oprot->writeFieldBegin("row_regexp", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->row_regexp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.value_regexp) {
    xfer += oprot->writeFieldBegin("value_regexp", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->value_regexp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scan_and_filter_rows) {
    xfer += oprot->writeFieldBegin("scan_and_filter_rows", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->scan_and_filter_rows);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_limit) {
    xfer += oprot->writeFieldBegin("cell_limit", ::apache::thrift::protocol::T_I32, 14);
    xfer += oprot->writeI32(this->cell_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.row_offset) {
    xfer += oprot->writeFieldBegin("row_offset", ::apache::thrift::protocol::T_I32, 15);
    xfer += oprot->writeI32(this->row_offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_offset) {
    xfer += oprot->writeFieldBegin("cell_offset", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(this->cell_offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_predicates) {
    xfer += oprot->writeFieldBegin("column_predicates", ::apache::thrift::protocol::T_LIST, 17);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_predicates.size()));
      std::vector<ColumnPredicate> ::const_iterator _iter29;
      for (_iter29 = this->column_predicates.begin(); _iter29 != this->column_predicates.end(); ++_iter29)
      {
        xfer += (*_iter29).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.do_not_cache) {
    xfer += oprot->writeFieldBegin("do_not_cache", ::apache::thrift::protocol::T_BOOL, 18);
    xfer += oprot->writeBool(this->do_not_cache);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.and_column_predicates) {
    xfer += oprot->writeFieldBegin("and_column_predicates", ::apache::thrift::protocol::T_BOOL, 19);
    xfer += oprot->writeBool(this->and_column_predicates);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScanSpec &a, ScanSpec &b) {
  using ::std::swap;
  swap(a.row_intervals, b.row_intervals);
  swap(a.cell_intervals, b.cell_intervals);
  swap(a.return_deletes, b.return_deletes);
  swap(a.versions, b.versions);
  swap(a.row_limit, b.row_limit);
  swap(a.start_time, b.start_time);
  swap(a.end_time, b.end_time);
  swap(a.columns, b.columns);
  swap(a.keys_only, b.keys_only);
  swap(a.cell_limit, b.cell_limit);
  swap(a.cell_limit_per_family, b.cell_limit_per_family);
  swap(a.row_regexp, b.row_regexp);
  swap(a.value_regexp, b.value_regexp);
  swap(a.scan_and_filter_rows, b.scan_and_filter_rows);
  swap(a.row_offset, b.row_offset);
  swap(a.cell_offset, b.cell_offset);
  swap(a.column_predicates, b.column_predicates);
  swap(a.do_not_cache, b.do_not_cache);
  swap(a.and_column_predicates, b.and_column_predicates);
  swap(a.__isset, b.__isset);
}

ScanSpec::ScanSpec(const ScanSpec& other30) {
  row_intervals = other30.row_intervals;
  cell_intervals = other30.cell_intervals;
  return_deletes = other30.return_deletes;
  versions = other30.versions;
  row_limit = other30.row_limit;
  start_time = other30.start_time;
  end_time = other30.end_time;
  columns = other30.columns;
  keys_only = other30.keys_only;
  cell_limit = other30.cell_limit;
  cell_limit_per_family = other30.cell_limit_per_family;
  row_regexp = other30.row_regexp;
  value_regexp = other30.value_regexp;
  scan_and_filter_rows = other30.scan_and_filter_rows;
  row_offset = other30.row_offset;
  cell_offset = other30.cell_offset;
  column_predicates = other30.column_predicates;
  do_not_cache = other30.do_not_cache;
  and_column_predicates = other30.and_column_predicates;
  __isset = other30.__isset;
}
ScanSpec& ScanSpec::operator=(const ScanSpec& other31) {
  row_intervals = other31.row_intervals;
  cell_intervals = other31.cell_intervals;
  return_deletes = other31.return_deletes;
  versions = other31.versions;
  row_limit = other31.row_limit;
  start_time = other31.start_time;
  end_time = other31.end_time;
  columns = other31.columns;
  keys_only = other31.keys_only;
  cell_limit = other31.cell_limit;
  cell_limit_per_family = other31.cell_limit_per_family;
  row_regexp = other31.row_regexp;
  value_regexp = other31.value_regexp;
  scan_and_filter_rows = other31.scan_and_filter_rows;
  row_offset = other31.row_offset;
  cell_offset = other31.cell_offset;
  column_predicates = other31.column_predicates;
  do_not_cache = other31.do_not_cache;
  and_column_predicates = other31.and_column_predicates;
  __isset = other31.__isset;
  return *this;
}
void ScanSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScanSpec(";
  out << "row_intervals="; (__isset.row_intervals ? (out << to_string(row_intervals)) : (out << "<null>"));
  out << ", " << "cell_intervals="; (__isset.cell_intervals ? (out << to_string(cell_intervals)) : (out << "<null>"));
  out << ", " << "return_deletes="; (__isset.return_deletes ? (out << to_string(return_deletes)) : (out << "<null>"));
  out << ", " << "versions="; (__isset.versions ? (out << to_string(versions)) : (out << "<null>"));
  out << ", " << "row_limit="; (__isset.row_limit ? (out << to_string(row_limit)) : (out << "<null>"));
  out << ", " << "start_time="; (__isset.start_time ? (out << to_string(start_time)) : (out << "<null>"));
  out << ", " << "end_time="; (__isset.end_time ? (out << to_string(end_time)) : (out << "<null>"));
  out << ", " << "columns="; (__isset.columns ? (out << to_string(columns)) : (out << "<null>"));
  out << ", " << "keys_only="; (__isset.keys_only ? (out << to_string(keys_only)) : (out << "<null>"));
  out << ", " << "cell_limit="; (__isset.cell_limit ? (out << to_string(cell_limit)) : (out << "<null>"));
  out << ", " << "cell_limit_per_family="; (__isset.cell_limit_per_family ? (out << to_string(cell_limit_per_family)) : (out << "<null>"));
  out << ", " << "row_regexp="; (__isset.row_regexp ? (out << to_string(row_regexp)) : (out << "<null>"));
  out << ", " << "value_regexp="; (__isset.value_regexp ? (out << to_string(value_regexp)) : (out << "<null>"));
  out << ", " << "scan_and_filter_rows="; (__isset.scan_and_filter_rows ? (out << to_string(scan_and_filter_rows)) : (out << "<null>"));
  out << ", " << "row_offset="; (__isset.row_offset ? (out << to_string(row_offset)) : (out << "<null>"));
  out << ", " << "cell_offset="; (__isset.cell_offset ? (out << to_string(cell_offset)) : (out << "<null>"));
  out << ", " << "column_predicates="; (__isset.column_predicates ? (out << to_string(column_predicates)) : (out << "<null>"));
  out << ", " << "do_not_cache="; (__isset.do_not_cache ? (out << to_string(do_not_cache)) : (out << "<null>"));
  out << ", " << "and_column_predicates="; (__isset.and_column_predicates ? (out << to_string(and_column_predicates)) : (out << "<null>"));
  out << ")";
}


Key::~Key() throw() {
}


void Key::__set_row(const std::string& val) {
  this->row = val;
}

void Key::__set_column_family(const std::string& val) {
  this->column_family = val;
}

void Key::__set_column_qualifier(const std::string& val) {
  this->column_qualifier = val;
}

void Key::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void Key::__set_revision(const int64_t val) {
  this->revision = val;
__isset.revision = true;
}

void Key::__set_flag(const KeyFlag::type val) {
  this->flag = val;
}
std::ostream& operator<<(std::ostream& out, const Key& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Key::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->row);
          this->__isset.row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_family);
          this->__isset.column_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_qualifier);
          this->__isset.column_qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          this->__isset.revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast32;
          xfer += iprot->readI32(ecast32);
          this->flag = (KeyFlag::type)ecast32;
          this->__isset.flag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Key::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Key");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_family", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->column_family);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_qualifier", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->column_qualifier);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.revision) {
    xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->revision);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("flag", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->flag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Key &a, Key &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.column_family, b.column_family);
  swap(a.column_qualifier, b.column_qualifier);
  swap(a.timestamp, b.timestamp);
  swap(a.revision, b.revision);
  swap(a.flag, b.flag);
  swap(a.__isset, b.__isset);
}

Key::Key(const Key& other33) {
  row = other33.row;
  column_family = other33.column_family;
  column_qualifier = other33.column_qualifier;
  timestamp = other33.timestamp;
  revision = other33.revision;
  flag = other33.flag;
  __isset = other33.__isset;
}
Key& Key::operator=(const Key& other34) {
  row = other34.row;
  column_family = other34.column_family;
  column_qualifier = other34.column_qualifier;
  timestamp = other34.timestamp;
  revision = other34.revision;
  flag = other34.flag;
  __isset = other34.__isset;
  return *this;
}
void Key::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Key(";
  out << "row=" << to_string(row);
  out << ", " << "column_family=" << to_string(column_family);
  out << ", " << "column_qualifier=" << to_string(column_qualifier);
  out << ", " << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ", " << "revision="; (__isset.revision ? (out << to_string(revision)) : (out << "<null>"));
  out << ", " << "flag=" << to_string(flag);
  out << ")";
}


MutateSpec::~MutateSpec() throw() {
}


void MutateSpec::__set_appname(const std::string& val) {
  this->appname = val;
}

void MutateSpec::__set_flush_interval(const int32_t val) {
  this->flush_interval = val;
}

void MutateSpec::__set_flags(const int32_t val) {
  this->flags = val;
}
std::ostream& operator<<(std::ostream& out, const MutateSpec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MutateSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_appname = false;
  bool isset_flush_interval = false;
  bool isset_flags = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appname);
          isset_appname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->flush_interval);
          isset_flush_interval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->flags);
          isset_flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_appname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_flush_interval)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_flags)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MutateSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MutateSpec");

  xfer += oprot->writeFieldBegin("appname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->appname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flush_interval", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->flush_interval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->flags);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MutateSpec &a, MutateSpec &b) {
  using ::std::swap;
  swap(a.appname, b.appname);
  swap(a.flush_interval, b.flush_interval);
  swap(a.flags, b.flags);
}

MutateSpec::MutateSpec(const MutateSpec& other35) {
  appname = other35.appname;
  flush_interval = other35.flush_interval;
  flags = other35.flags;
}
MutateSpec& MutateSpec::operator=(const MutateSpec& other36) {
  appname = other36.appname;
  flush_interval = other36.flush_interval;
  flags = other36.flags;
  return *this;
}
void MutateSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MutateSpec(";
  out << "appname=" << to_string(appname);
  out << ", " << "flush_interval=" << to_string(flush_interval);
  out << ", " << "flags=" << to_string(flags);
  out << ")";
}


Cell::~Cell() throw() {
}


void Cell::__set_key(const Key& val) {
  this->key = val;
}

void Cell::__set_value(const Value& val) {
  this->value = val;
__isset.value = true;
}
std::ostream& operator<<(std::ostream& out, const Cell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Cell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->key.read(iprot);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Cell");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->key.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cell &a, Cell &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

Cell::Cell(const Cell& other37) {
  key = other37.key;
  value = other37.value;
  __isset = other37.__isset;
}
Cell& Cell::operator=(const Cell& other38) {
  key = other38.key;
  value = other38.value;
  __isset = other38.__isset;
  return *this;
}
void Cell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Cell(";
  out << "key=" << to_string(key);
  out << ", " << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ")";
}


Result::~Result() throw() {
}


void Result::__set_is_empty(const bool val) {
  this->is_empty = val;
}

void Result::__set_id(const int64_t val) {
  this->id = val;
}

void Result::__set_is_scan(const bool val) {
  this->is_scan = val;
}

void Result::__set_is_error(const bool val) {
  this->is_error = val;
}

void Result::__set_error(const int32_t val) {
  this->error = val;
__isset.error = true;
}

void Result::__set_error_msg(const std::string& val) {
  this->error_msg = val;
__isset.error_msg = true;
}

void Result::__set_cells(const std::vector<Cell> & val) {
  this->cells = val;
__isset.cells = true;
}
std::ostream& operator<<(std::ostream& out, const Result& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_empty = false;
  bool isset_id = false;
  bool isset_is_scan = false;
  bool isset_is_error = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_empty);
          isset_is_empty = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_scan);
          isset_is_scan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_error);
          isset_is_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->error);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size39;
            ::apache::thrift::protocol::TType _etype42;
            xfer += iprot->readListBegin(_etype42, _size39);
            this->cells.resize(_size39);
            uint32_t _i43;
            for (_i43 = 0; _i43 < _size39; ++_i43)
            {
              xfer += this->cells[_i43].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_empty)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_scan)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_error)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Result");

  xfer += oprot->writeFieldBegin("is_empty", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_empty);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_scan", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_scan);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_error", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_error);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error_msg) {
    xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->error_msg);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cells) {
    xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
      std::vector<Cell> ::const_iterator _iter44;
      for (_iter44 = this->cells.begin(); _iter44 != this->cells.end(); ++_iter44)
      {
        xfer += (*_iter44).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Result &a, Result &b) {
  using ::std::swap;
  swap(a.is_empty, b.is_empty);
  swap(a.id, b.id);
  swap(a.is_scan, b.is_scan);
  swap(a.is_error, b.is_error);
  swap(a.error, b.error);
  swap(a.error_msg, b.error_msg);
  swap(a.cells, b.cells);
  swap(a.__isset, b.__isset);
}

Result::Result(const Result& other45) {
  is_empty = other45.is_empty;
  id = other45.id;
  is_scan = other45.is_scan;
  is_error = other45.is_error;
  error = other45.error;
  error_msg = other45.error_msg;
  cells = other45.cells;
  __isset = other45.__isset;
}
Result& Result::operator=(const Result& other46) {
  is_empty = other46.is_empty;
  id = other46.id;
  is_scan = other46.is_scan;
  is_error = other46.is_error;
  error = other46.error;
  error_msg = other46.error_msg;
  cells = other46.cells;
  __isset = other46.__isset;
  return *this;
}
void Result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Result(";
  out << "is_empty=" << to_string(is_empty);
  out << ", " << "id=" << to_string(id);
  out << ", " << "is_scan=" << to_string(is_scan);
  out << ", " << "is_error=" << to_string(is_error);
  out << ", " << "error="; (__isset.error ? (out << to_string(error)) : (out << "<null>"));
  out << ", " << "error_msg="; (__isset.error_msg ? (out << to_string(error_msg)) : (out << "<null>"));
  out << ", " << "cells="; (__isset.cells ? (out << to_string(cells)) : (out << "<null>"));
  out << ")";
}


ResultAsArrays::~ResultAsArrays() throw() {
}


void ResultAsArrays::__set_is_empty(const bool val) {
  this->is_empty = val;
}

void ResultAsArrays::__set_id(const int64_t val) {
  this->id = val;
}

void ResultAsArrays::__set_is_scan(const bool val) {
  this->is_scan = val;
}

void ResultAsArrays::__set_is_error(const bool val) {
  this->is_error = val;
}

void ResultAsArrays::__set_error(const int32_t val) {
  this->error = val;
__isset.error = true;
}

void ResultAsArrays::__set_error_msg(const std::string& val) {
  this->error_msg = val;
__isset.error_msg = true;
}

void ResultAsArrays::__set_cells(const std::vector<CellAsArray> & val) {
  this->cells = val;
__isset.cells = true;
}
std::ostream& operator<<(std::ostream& out, const ResultAsArrays& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResultAsArrays::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_empty = false;
  bool isset_id = false;
  bool isset_is_scan = false;
  bool isset_is_error = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_empty);
          isset_is_empty = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_scan);
          isset_is_scan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_error);
          isset_is_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->error);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->cells.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              {
                this->cells[_i51].clear();
                uint32_t _size52;
                ::apache::thrift::protocol::TType _etype55;
                xfer += iprot->readListBegin(_etype55, _size52);
                this->cells[_i51].resize(_size52);
                uint32_t _i56;
                for (_i56 = 0; _i56 < _size52; ++_i56)
                {
                  xfer += iprot->readString(this->cells[_i51][_i56]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_empty)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_scan)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_error)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResultAsArrays::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResultAsArrays");

  xfer += oprot->writeFieldBegin("is_empty", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_empty);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_scan", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_scan);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_error", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_error);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error_msg) {
    xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->error_msg);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cells) {
    xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->cells.size()));
      std::vector<CellAsArray> ::const_iterator _iter57;
      for (_iter57 = this->cells.begin(); _iter57 != this->cells.end(); ++_iter57)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter57).size()));
          std::vector<std::string> ::const_iterator _iter58;
          for (_iter58 = (*_iter57).begin(); _iter58 != (*_iter57).end(); ++_iter58)
          {
            xfer += oprot->writeString((*_iter58));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResultAsArrays &a, ResultAsArrays &b) {
  using ::std::swap;
  swap(a.is_empty, b.is_empty);
  swap(a.id, b.id);
  swap(a.is_scan, b.is_scan);
  swap(a.is_error, b.is_error);
  swap(a.error, b.error);
  swap(a.error_msg, b.error_msg);
  swap(a.cells, b.cells);
  swap(a.__isset, b.__isset);
}

ResultAsArrays::ResultAsArrays(const ResultAsArrays& other59) {
  is_empty = other59.is_empty;
  id = other59.id;
  is_scan = other59.is_scan;
  is_error = other59.is_error;
  error = other59.error;
  error_msg = other59.error_msg;
  cells = other59.cells;
  __isset = other59.__isset;
}
ResultAsArrays& ResultAsArrays::operator=(const ResultAsArrays& other60) {
  is_empty = other60.is_empty;
  id = other60.id;
  is_scan = other60.is_scan;
  is_error = other60.is_error;
  error = other60.error;
  error_msg = other60.error_msg;
  cells = other60.cells;
  __isset = other60.__isset;
  return *this;
}
void ResultAsArrays::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResultAsArrays(";
  out << "is_empty=" << to_string(is_empty);
  out << ", " << "id=" << to_string(id);
  out << ", " << "is_scan=" << to_string(is_scan);
  out << ", " << "is_error=" << to_string(is_error);
  out << ", " << "error="; (__isset.error ? (out << to_string(error)) : (out << "<null>"));
  out << ", " << "error_msg="; (__isset.error_msg ? (out << to_string(error_msg)) : (out << "<null>"));
  out << ", " << "cells="; (__isset.cells ? (out << to_string(cells)) : (out << "<null>"));
  out << ")";
}


ResultSerialized::~ResultSerialized() throw() {
}


void ResultSerialized::__set_is_empty(const bool val) {
  this->is_empty = val;
}

void ResultSerialized::__set_id(const int64_t val) {
  this->id = val;
}

void ResultSerialized::__set_is_scan(const bool val) {
  this->is_scan = val;
}

void ResultSerialized::__set_is_error(const bool val) {
  this->is_error = val;
}

void ResultSerialized::__set_error(const int32_t val) {
  this->error = val;
__isset.error = true;
}

void ResultSerialized::__set_error_msg(const std::string& val) {
  this->error_msg = val;
__isset.error_msg = true;
}

void ResultSerialized::__set_cells(const CellsSerialized& val) {
  this->cells = val;
__isset.cells = true;
}
std::ostream& operator<<(std::ostream& out, const ResultSerialized& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResultSerialized::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_empty = false;
  bool isset_id = false;
  bool isset_is_scan = false;
  bool isset_is_error = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_empty);
          isset_is_empty = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_scan);
          isset_is_scan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_error);
          isset_is_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->error);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->cells);
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_empty)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_scan)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_error)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResultSerialized::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResultSerialized");

  xfer += oprot->writeFieldBegin("is_empty", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_empty);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_scan", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_scan);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_error", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_error);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error_msg) {
    xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->error_msg);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cells) {
    xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeBinary(this->cells);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResultSerialized &a, ResultSerialized &b) {
  using ::std::swap;
  swap(a.is_empty, b.is_empty);
  swap(a.id, b.id);
  swap(a.is_scan, b.is_scan);
  swap(a.is_error, b.is_error);
  swap(a.error, b.error);
  swap(a.error_msg, b.error_msg);
  swap(a.cells, b.cells);
  swap(a.__isset, b.__isset);
}

ResultSerialized::ResultSerialized(const ResultSerialized& other61) {
  is_empty = other61.is_empty;
  id = other61.id;
  is_scan = other61.is_scan;
  is_error = other61.is_error;
  error = other61.error;
  error_msg = other61.error_msg;
  cells = other61.cells;
  __isset = other61.__isset;
}
ResultSerialized& ResultSerialized::operator=(const ResultSerialized& other62) {
  is_empty = other62.is_empty;
  id = other62.id;
  is_scan = other62.is_scan;
  is_error = other62.is_error;
  error = other62.error;
  error_msg = other62.error_msg;
  cells = other62.cells;
  __isset = other62.__isset;
  return *this;
}
void ResultSerialized::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResultSerialized(";
  out << "is_empty=" << to_string(is_empty);
  out << ", " << "id=" << to_string(id);
  out << ", " << "is_scan=" << to_string(is_scan);
  out << ", " << "is_error=" << to_string(is_error);
  out << ", " << "error="; (__isset.error ? (out << to_string(error)) : (out << "<null>"));
  out << ", " << "error_msg="; (__isset.error_msg ? (out << to_string(error_msg)) : (out << "<null>"));
  out << ", " << "cells="; (__isset.cells ? (out << to_string(cells)) : (out << "<null>"));
  out << ")";
}


NamespaceListing::~NamespaceListing() throw() {
}


void NamespaceListing::__set_name(const std::string& val) {
  this->name = val;
}

void NamespaceListing::__set_is_namespace(const bool val) {
  this->is_namespace = val;
}
std::ostream& operator<<(std::ostream& out, const NamespaceListing& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NamespaceListing::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_is_namespace = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_namespace);
          isset_is_namespace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_namespace)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NamespaceListing::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NamespaceListing");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_namespace", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_namespace);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NamespaceListing &a, NamespaceListing &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.is_namespace, b.is_namespace);
}

NamespaceListing::NamespaceListing(const NamespaceListing& other63) {
  name = other63.name;
  is_namespace = other63.is_namespace;
}
NamespaceListing& NamespaceListing::operator=(const NamespaceListing& other64) {
  name = other64.name;
  is_namespace = other64.is_namespace;
  return *this;
}
void NamespaceListing::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NamespaceListing(";
  out << "name=" << to_string(name);
  out << ", " << "is_namespace=" << to_string(is_namespace);
  out << ")";
}


TableSplit::~TableSplit() throw() {
}


void TableSplit::__set_start_row(const std::string& val) {
  this->start_row = val;
__isset.start_row = true;
}

void TableSplit::__set_end_row(const std::string& val) {
  this->end_row = val;
__isset.end_row = true;
}

void TableSplit::__set_location(const std::string& val) {
  this->location = val;
__isset.location = true;
}

void TableSplit::__set_ip_address(const std::string& val) {
  this->ip_address = val;
__isset.ip_address = true;
}

void TableSplit::__set_hostname(const std::string& val) {
  this->hostname = val;
__isset.hostname = true;
}
std::ostream& operator<<(std::ostream& out, const TableSplit& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TableSplit::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->start_row);
          this->__isset.start_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->end_row);
          this->__isset.end_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip_address);
          this->__isset.ip_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          this->__isset.hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TableSplit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TableSplit");

  if (this->__isset.start_row) {
    xfer += oprot->writeFieldBegin("start_row", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->start_row);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.end_row) {
    xfer += oprot->writeFieldBegin("end_row", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->end_row);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.location) {
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->location);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip_address) {
    xfer += oprot->writeFieldBegin("ip_address", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->ip_address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hostname) {
    xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->hostname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableSplit &a, TableSplit &b) {
  using ::std::swap;
  swap(a.start_row, b.start_row);
  swap(a.end_row, b.end_row);
  swap(a.location, b.location);
  swap(a.ip_address, b.ip_address);
  swap(a.hostname, b.hostname);
  swap(a.__isset, b.__isset);
}

TableSplit::TableSplit(const TableSplit& other65) {
  start_row = other65.start_row;
  end_row = other65.end_row;
  location = other65.location;
  ip_address = other65.ip_address;
  hostname = other65.hostname;
  __isset = other65.__isset;
}
TableSplit& TableSplit::operator=(const TableSplit& other66) {
  start_row = other66.start_row;
  end_row = other66.end_row;
  location = other66.location;
  ip_address = other66.ip_address;
  hostname = other66.hostname;
  __isset = other66.__isset;
  return *this;
}
void TableSplit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TableSplit(";
  out << "start_row="; (__isset.start_row ? (out << to_string(start_row)) : (out << "<null>"));
  out << ", " << "end_row="; (__isset.end_row ? (out << to_string(end_row)) : (out << "<null>"));
  out << ", " << "location="; (__isset.location ? (out << to_string(location)) : (out << "<null>"));
  out << ", " << "ip_address="; (__isset.ip_address ? (out << to_string(ip_address)) : (out << "<null>"));
  out << ", " << "hostname="; (__isset.hostname ? (out << to_string(hostname)) : (out << "<null>"));
  out << ")";
}


ColumnFamilyOptions::~ColumnFamilyOptions() throw() {
}


void ColumnFamilyOptions::__set_max_versions(const int32_t val) {
  this->max_versions = val;
__isset.max_versions = true;
}

void ColumnFamilyOptions::__set_ttl(const int32_t val) {
  this->ttl = val;
__isset.ttl = true;
}

void ColumnFamilyOptions::__set_time_order_desc(const bool val) {
  this->time_order_desc = val;
__isset.time_order_desc = true;
}

void ColumnFamilyOptions::__set_counter(const bool val) {
  this->counter = val;
__isset.counter = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnFamilyOptions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnFamilyOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_versions);
          this->__isset.max_versions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ttl);
          this->__isset.ttl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->time_order_desc);
          this->__isset.time_order_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->counter);
          this->__isset.counter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnFamilyOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnFamilyOptions");

  if (this->__isset.max_versions) {
    xfer += oprot->writeFieldBegin("max_versions", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->max_versions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ttl) {
    xfer += oprot->writeFieldBegin("ttl", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->ttl);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.time_order_desc) {
    xfer += oprot->writeFieldBegin("time_order_desc", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->time_order_desc);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.counter) {
    xfer += oprot->writeFieldBegin("counter", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->counter);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnFamilyOptions &a, ColumnFamilyOptions &b) {
  using ::std::swap;
  swap(a.max_versions, b.max_versions);
  swap(a.ttl, b.ttl);
  swap(a.time_order_desc, b.time_order_desc);
  swap(a.counter, b.counter);
  swap(a.__isset, b.__isset);
}

ColumnFamilyOptions::ColumnFamilyOptions(const ColumnFamilyOptions& other67) {
  max_versions = other67.max_versions;
  ttl = other67.ttl;
  time_order_desc = other67.time_order_desc;
  counter = other67.counter;
  __isset = other67.__isset;
}
ColumnFamilyOptions& ColumnFamilyOptions::operator=(const ColumnFamilyOptions& other68) {
  max_versions = other68.max_versions;
  ttl = other68.ttl;
  time_order_desc = other68.time_order_desc;
  counter = other68.counter;
  __isset = other68.__isset;
  return *this;
}
void ColumnFamilyOptions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnFamilyOptions(";
  out << "max_versions="; (__isset.max_versions ? (out << to_string(max_versions)) : (out << "<null>"));
  out << ", " << "ttl="; (__isset.ttl ? (out << to_string(ttl)) : (out << "<null>"));
  out << ", " << "time_order_desc="; (__isset.time_order_desc ? (out << to_string(time_order_desc)) : (out << "<null>"));
  out << ", " << "counter="; (__isset.counter ? (out << to_string(counter)) : (out << "<null>"));
  out << ")";
}


ColumnFamilySpec::~ColumnFamilySpec() throw() {
}


void ColumnFamilySpec::__set_name(const std::string& val) {
  this->name = val;
}

void ColumnFamilySpec::__set_access_group(const std::string& val) {
  this->access_group = val;
}

void ColumnFamilySpec::__set_deleted(const bool val) {
  this->deleted = val;
}

void ColumnFamilySpec::__set_generation(const int64_t val) {
  this->generation = val;
__isset.generation = true;
}

void ColumnFamilySpec::__set_id(const int32_t val) {
  this->id = val;
__isset.id = true;
}

void ColumnFamilySpec::__set_value_index(const bool val) {
  this->value_index = val;
}

void ColumnFamilySpec::__set_qualifier_index(const bool val) {
  this->qualifier_index = val;
}

void ColumnFamilySpec::__set_options(const ColumnFamilyOptions& val) {
  this->options = val;
__isset.options = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnFamilySpec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnFamilySpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->access_group);
          this->__isset.access_group = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->deleted);
          this->__isset.deleted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->generation);
          this->__isset.generation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->value_index);
          this->__isset.value_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->qualifier_index);
          this->__isset.qualifier_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnFamilySpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnFamilySpec");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("access_group", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->access_group);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deleted", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->deleted);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.generation) {
    xfer += oprot->writeFieldBegin("generation", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->generation);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("value_index", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->value_index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qualifier_index", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->qualifier_index);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->options.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnFamilySpec &a, ColumnFamilySpec &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.access_group, b.access_group);
  swap(a.deleted, b.deleted);
  swap(a.generation, b.generation);
  swap(a.id, b.id);
  swap(a.value_index, b.value_index);
  swap(a.qualifier_index, b.qualifier_index);
  swap(a.options, b.options);
  swap(a.__isset, b.__isset);
}

ColumnFamilySpec::ColumnFamilySpec(const ColumnFamilySpec& other69) {
  name = other69.name;
  access_group = other69.access_group;
  deleted = other69.deleted;
  generation = other69.generation;
  id = other69.id;
  value_index = other69.value_index;
  qualifier_index = other69.qualifier_index;
  options = other69.options;
  __isset = other69.__isset;
}
ColumnFamilySpec& ColumnFamilySpec::operator=(const ColumnFamilySpec& other70) {
  name = other70.name;
  access_group = other70.access_group;
  deleted = other70.deleted;
  generation = other70.generation;
  id = other70.id;
  value_index = other70.value_index;
  qualifier_index = other70.qualifier_index;
  options = other70.options;
  __isset = other70.__isset;
  return *this;
}
void ColumnFamilySpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnFamilySpec(";
  out << "name=" << to_string(name);
  out << ", " << "access_group=" << to_string(access_group);
  out << ", " << "deleted=" << to_string(deleted);
  out << ", " << "generation="; (__isset.generation ? (out << to_string(generation)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "value_index=" << to_string(value_index);
  out << ", " << "qualifier_index=" << to_string(qualifier_index);
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ")";
}


AccessGroupOptions::~AccessGroupOptions() throw() {
}


void AccessGroupOptions::__set_replication(const int16_t val) {
  this->replication = val;
__isset.replication = true;
}

void AccessGroupOptions::__set_blocksize(const int32_t val) {
  this->blocksize = val;
__isset.blocksize = true;
}

void AccessGroupOptions::__set_compressor(const std::string& val) {
  this->compressor = val;
__isset.compressor = true;
}

void AccessGroupOptions::__set_bloom_filter(const std::string& val) {
  this->bloom_filter = val;
__isset.bloom_filter = true;
}

void AccessGroupOptions::__set_in_memory(const bool val) {
  this->in_memory = val;
__isset.in_memory = true;
}
std::ostream& operator<<(std::ostream& out, const AccessGroupOptions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AccessGroupOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->replication);
          this->__isset.replication = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blocksize);
          this->__isset.blocksize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->compressor);
          this->__isset.compressor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bloom_filter);
          this->__isset.bloom_filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->in_memory);
          this->__isset.in_memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccessGroupOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AccessGroupOptions");

  if (this->__isset.replication) {
    xfer += oprot->writeFieldBegin("replication", ::apache::thrift::protocol::T_I16, 1);
    xfer += oprot->writeI16(this->replication);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blocksize) {
    xfer += oprot->writeFieldBegin("blocksize", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->blocksize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compressor) {
    xfer += oprot->writeFieldBegin("compressor", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->compressor);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bloom_filter) {
    xfer += oprot->writeFieldBegin("bloom_filter", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->bloom_filter);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.in_memory) {
    xfer += oprot->writeFieldBegin("in_memory", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->in_memory);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AccessGroupOptions &a, AccessGroupOptions &b) {
  using ::std::swap;
  swap(a.replication, b.replication);
  swap(a.blocksize, b.blocksize);
  swap(a.compressor, b.compressor);
  swap(a.bloom_filter, b.bloom_filter);
  swap(a.in_memory, b.in_memory);
  swap(a.__isset, b.__isset);
}

AccessGroupOptions::AccessGroupOptions(const AccessGroupOptions& other71) {
  replication = other71.replication;
  blocksize = other71.blocksize;
  compressor = other71.compressor;
  bloom_filter = other71.bloom_filter;
  in_memory = other71.in_memory;
  __isset = other71.__isset;
}
AccessGroupOptions& AccessGroupOptions::operator=(const AccessGroupOptions& other72) {
  replication = other72.replication;
  blocksize = other72.blocksize;
  compressor = other72.compressor;
  bloom_filter = other72.bloom_filter;
  in_memory = other72.in_memory;
  __isset = other72.__isset;
  return *this;
}
void AccessGroupOptions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AccessGroupOptions(";
  out << "replication="; (__isset.replication ? (out << to_string(replication)) : (out << "<null>"));
  out << ", " << "blocksize="; (__isset.blocksize ? (out << to_string(blocksize)) : (out << "<null>"));
  out << ", " << "compressor="; (__isset.compressor ? (out << to_string(compressor)) : (out << "<null>"));
  out << ", " << "bloom_filter="; (__isset.bloom_filter ? (out << to_string(bloom_filter)) : (out << "<null>"));
  out << ", " << "in_memory="; (__isset.in_memory ? (out << to_string(in_memory)) : (out << "<null>"));
  out << ")";
}


AccessGroupSpec::~AccessGroupSpec() throw() {
}


void AccessGroupSpec::__set_name(const std::string& val) {
  this->name = val;
}

void AccessGroupSpec::__set_generation(const int64_t val) {
  this->generation = val;
__isset.generation = true;
}

void AccessGroupSpec::__set_options(const AccessGroupOptions& val) {
  this->options = val;
__isset.options = true;
}

void AccessGroupSpec::__set_defaults(const ColumnFamilyOptions& val) {
  this->defaults = val;
__isset.defaults = true;
}
std::ostream& operator<<(std::ostream& out, const AccessGroupSpec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AccessGroupSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->generation);
          this->__isset.generation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->defaults.read(iprot);
          this->__isset.defaults = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccessGroupSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AccessGroupSpec");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.generation) {
    xfer += oprot->writeFieldBegin("generation", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->generation);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->options.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.defaults) {
    xfer += oprot->writeFieldBegin("defaults", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->defaults.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AccessGroupSpec &a, AccessGroupSpec &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.generation, b.generation);
  swap(a.options, b.options);
  swap(a.defaults, b.defaults);
  swap(a.__isset, b.__isset);
}

AccessGroupSpec::AccessGroupSpec(const AccessGroupSpec& other73) {
  name = other73.name;
  generation = other73.generation;
  options = other73.options;
  defaults = other73.defaults;
  __isset = other73.__isset;
}
AccessGroupSpec& AccessGroupSpec::operator=(const AccessGroupSpec& other74) {
  name = other74.name;
  generation = other74.generation;
  options = other74.options;
  defaults = other74.defaults;
  __isset = other74.__isset;
  return *this;
}
void AccessGroupSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AccessGroupSpec(";
  out << "name=" << to_string(name);
  out << ", " << "generation="; (__isset.generation ? (out << to_string(generation)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ", " << "defaults="; (__isset.defaults ? (out << to_string(defaults)) : (out << "<null>"));
  out << ")";
}


Schema::~Schema() throw() {
}


void Schema::__set_access_groups(const std::map<std::string, AccessGroupSpec> & val) {
  this->access_groups = val;
__isset.access_groups = true;
}

void Schema::__set_column_families(const std::map<std::string, ColumnFamilySpec> & val) {
  this->column_families = val;
__isset.column_families = true;
}

void Schema::__set_generation(const int64_t val) {
  this->generation = val;
__isset.generation = true;
}

void Schema::__set_version(const int32_t val) {
  this->version = val;
__isset.version = true;
}

void Schema::__set_group_commit_interval(const int32_t val) {
  this->group_commit_interval = val;
__isset.group_commit_interval = true;
}

void Schema::__set_access_group_defaults(const AccessGroupOptions& val) {
  this->access_group_defaults = val;
__isset.access_group_defaults = true;
}

void Schema::__set_column_family_defaults(const ColumnFamilyOptions& val) {
  this->column_family_defaults = val;
__isset.column_family_defaults = true;
}
std::ostream& operator<<(std::ostream& out, const Schema& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Schema::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->access_groups.clear();
            uint32_t _size75;
            ::apache::thrift::protocol::TType _ktype76;
            ::apache::thrift::protocol::TType _vtype77;
            xfer += iprot->readMapBegin(_ktype76, _vtype77, _size75);
            uint32_t _i79;
            for (_i79 = 0; _i79 < _size75; ++_i79)
            {
              std::string _key80;
              xfer += iprot->readString(_key80);
              AccessGroupSpec& _val81 = this->access_groups[_key80];
              xfer += _val81.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.access_groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->column_families.clear();
            uint32_t _size82;
            ::apache::thrift::protocol::TType _ktype83;
            ::apache::thrift::protocol::TType _vtype84;
            xfer += iprot->readMapBegin(_ktype83, _vtype84, _size82);
            uint32_t _i86;
            for (_i86 = 0; _i86 < _size82; ++_i86)
            {
              std::string _key87;
              xfer += iprot->readString(_key87);
              ColumnFamilySpec& _val88 = this->column_families[_key87];
              xfer += _val88.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.column_families = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->generation);
          this->__isset.generation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->group_commit_interval);
          this->__isset.group_commit_interval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->access_group_defaults.read(iprot);
          this->__isset.access_group_defaults = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->column_family_defaults.read(iprot);
          this->__isset.column_family_defaults = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Schema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Schema");

  if (this->__isset.access_groups) {
    xfer += oprot->writeFieldBegin("access_groups", ::apache::thrift::protocol::T_MAP, 1);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->access_groups.size()));
      std::map<std::string, AccessGroupSpec> ::const_iterator _iter89;
      for (_iter89 = this->access_groups.begin(); _iter89 != this->access_groups.end(); ++_iter89)
      {
        xfer += oprot->writeString(_iter89->first);
        xfer += _iter89->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_families) {
    xfer += oprot->writeFieldBegin("column_families", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_families.size()));
      std::map<std::string, ColumnFamilySpec> ::const_iterator _iter90;
      for (_iter90 = this->column_families.begin(); _iter90 != this->column_families.end(); ++_iter90)
      {
        xfer += oprot->writeString(_iter90->first);
        xfer += _iter90->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.generation) {
    xfer += oprot->writeFieldBegin("generation", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->generation);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.group_commit_interval) {
    xfer += oprot->writeFieldBegin("group_commit_interval", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->group_commit_interval);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.access_group_defaults) {
    xfer += oprot->writeFieldBegin("access_group_defaults", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->access_group_defaults.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_family_defaults) {
    xfer += oprot->writeFieldBegin("column_family_defaults", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->column_family_defaults.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Schema &a, Schema &b) {
  using ::std::swap;
  swap(a.access_groups, b.access_groups);
  swap(a.column_families, b.column_families);
  swap(a.generation, b.generation);
  swap(a.version, b.version);
  swap(a.group_commit_interval, b.group_commit_interval);
  swap(a.access_group_defaults, b.access_group_defaults);
  swap(a.column_family_defaults, b.column_family_defaults);
  swap(a.__isset, b.__isset);
}

Schema::Schema(const Schema& other91) {
  access_groups = other91.access_groups;
  column_families = other91.column_families;
  generation = other91.generation;
  version = other91.version;
  group_commit_interval = other91.group_commit_interval;
  access_group_defaults = other91.access_group_defaults;
  column_family_defaults = other91.column_family_defaults;
  __isset = other91.__isset;
}
Schema& Schema::operator=(const Schema& other92) {
  access_groups = other92.access_groups;
  column_families = other92.column_families;
  generation = other92.generation;
  version = other92.version;
  group_commit_interval = other92.group_commit_interval;
  access_group_defaults = other92.access_group_defaults;
  column_family_defaults = other92.column_family_defaults;
  __isset = other92.__isset;
  return *this;
}
void Schema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Schema(";
  out << "access_groups="; (__isset.access_groups ? (out << to_string(access_groups)) : (out << "<null>"));
  out << ", " << "column_families="; (__isset.column_families ? (out << to_string(column_families)) : (out << "<null>"));
  out << ", " << "generation="; (__isset.generation ? (out << to_string(generation)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "group_commit_interval="; (__isset.group_commit_interval ? (out << to_string(group_commit_interval)) : (out << "<null>"));
  out << ", " << "access_group_defaults="; (__isset.access_group_defaults ? (out << to_string(access_group_defaults)) : (out << "<null>"));
  out << ", " << "column_family_defaults="; (__isset.column_family_defaults ? (out << to_string(column_family_defaults)) : (out << "<null>"));
  out << ")";
}


Status::~Status() throw() {
}


void Status::__set_code(const int32_t val) {
  this->code = val;
}

void Status::__set_text(const std::string& val) {
  this->text = val;
}
std::ostream& operator<<(std::ostream& out, const Status& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Status::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;
  bool isset_text = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          isset_text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_text)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Status::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Status");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Status &a, Status &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.text, b.text);
}

Status::Status(const Status& other93) {
  code = other93.code;
  text = other93.text;
}
Status& Status::operator=(const Status& other94) {
  code = other94.code;
  text = other94.text;
  return *this;
}
void Status::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Status(";
  out << "code=" << to_string(code);
  out << ", " << "text=" << to_string(text);
  out << ")";
}


ClientException::~ClientException() throw() {
}


void ClientException::__set_code(const int32_t val) {
  this->code = val;
}

void ClientException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const ClientException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ClientException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientException");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ClientException &a, ClientException &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

ClientException::ClientException(const ClientException& other95) : TException() {
  code = other95.code;
  message = other95.message;
  __isset = other95.__isset;
}
ClientException& ClientException::operator=(const ClientException& other96) {
  code = other96.code;
  message = other96.message;
  __isset = other96.__isset;
  return *this;
}
void ClientException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ClientException(";
  out << "code=" << to_string(code);
  out << ", " << "message=" << to_string(message);
  out << ")";
}

const char* ClientException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: ClientException";
  }
}

}} // namespace
