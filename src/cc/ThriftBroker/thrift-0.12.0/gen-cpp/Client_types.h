/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Client_TYPES_H
#define Client_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>


namespace Hypertable { namespace ThriftGen {

struct ColumnPredicateOperation {
  enum type {
    EXACT_MATCH = 1,
    PREFIX_MATCH = 2,
    REGEX_MATCH = 4,
    VALUE_MATCH = 7,
    QUALIFIER_EXACT_MATCH = 256,
    QUALIFIER_PREFIX_MATCH = 512,
    QUALIFIER_REGEX_MATCH = 1024,
    QUALIFIER_MATCH = 1792
  };
};

extern const std::map<int, const char*> _ColumnPredicateOperation_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const ColumnPredicateOperation::type& val);

struct KeyFlag {
  enum type {
    DELETE_ROW = 0,
    DELETE_CF = 1,
    DELETE_CELL = 2,
    DELETE_CELL_VERSION = 3,
    INSERT = 255
  };
};

extern const std::map<int, const char*> _KeyFlag_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const KeyFlag::type& val);

struct MutatorFlag {
  enum type {
    NO_LOG_SYNC = 1,
    IGNORE_UNKNOWN_CFS = 2,
    NO_LOG = 4
  };
};

extern const std::map<int, const char*> _MutatorFlag_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const MutatorFlag::type& val);

struct StatusCode {
  enum type {
    OK = 0,
    WARNING = 1,
    CRITICAL = 2,
    UNKNOWN = 3
  };
};

extern const std::map<int, const char*> _StatusCode_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const StatusCode::type& val);

typedef int64_t Future;

typedef int64_t Namespace;

typedef int64_t Scanner;

typedef int64_t ScannerAsync;

typedef int64_t Mutator;

typedef int64_t MutatorAsync;

typedef std::string Value;

typedef std::vector<std::string>  CellAsArray;

typedef std::string CellsSerialized;

class RowInterval;

class CellInterval;

class ColumnPredicate;

class ScanSpec;

class Key;

class MutateSpec;

class Cell;

class Result;

class ResultAsArrays;

class ResultSerialized;

class NamespaceListing;

class TableSplit;

class ColumnFamilyOptions;

class ColumnFamilySpec;

class AccessGroupOptions;

class AccessGroupSpec;

class Schema;

class Status;

class ClientException;

typedef struct _RowInterval__isset {
  _RowInterval__isset() : start_row(false), start_inclusive(true), end_row(false), end_inclusive(true), start_row_binary(false), end_row_binary(false) {}
  bool start_row :1;
  bool start_inclusive :1;
  bool end_row :1;
  bool end_inclusive :1;
  bool start_row_binary :1;
  bool end_row_binary :1;
} _RowInterval__isset;

class RowInterval : public virtual ::apache::thrift::TBase {
 public:

  RowInterval(const RowInterval&);
  RowInterval& operator=(const RowInterval&);
  RowInterval() : start_row(), start_inclusive(true), end_row(), end_inclusive(true), start_row_binary(), end_row_binary() {
  }

  virtual ~RowInterval() throw();
  std::string start_row;
  bool start_inclusive;
  std::string end_row;
  bool end_inclusive;
  std::string start_row_binary;
  std::string end_row_binary;

  _RowInterval__isset __isset;

  void __set_start_row(const std::string& val);

  void __set_start_inclusive(const bool val);

  void __set_end_row(const std::string& val);

  void __set_end_inclusive(const bool val);

  void __set_start_row_binary(const std::string& val);

  void __set_end_row_binary(const std::string& val);

  bool operator == (const RowInterval & rhs) const
  {
    if (__isset.start_row != rhs.__isset.start_row)
      return false;
    else if (__isset.start_row && !(start_row == rhs.start_row))
      return false;
    if (__isset.start_inclusive != rhs.__isset.start_inclusive)
      return false;
    else if (__isset.start_inclusive && !(start_inclusive == rhs.start_inclusive))
      return false;
    if (__isset.end_row != rhs.__isset.end_row)
      return false;
    else if (__isset.end_row && !(end_row == rhs.end_row))
      return false;
    if (__isset.end_inclusive != rhs.__isset.end_inclusive)
      return false;
    else if (__isset.end_inclusive && !(end_inclusive == rhs.end_inclusive))
      return false;
    if (__isset.start_row_binary != rhs.__isset.start_row_binary)
      return false;
    else if (__isset.start_row_binary && !(start_row_binary == rhs.start_row_binary))
      return false;
    if (__isset.end_row_binary != rhs.__isset.end_row_binary)
      return false;
    else if (__isset.end_row_binary && !(end_row_binary == rhs.end_row_binary))
      return false;
    return true;
  }
  bool operator != (const RowInterval &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RowInterval & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RowInterval &a, RowInterval &b);

std::ostream& operator<<(std::ostream& out, const RowInterval& obj);

typedef struct _CellInterval__isset {
  _CellInterval__isset() : start_row(false), start_column(false), start_inclusive(true), end_row(false), end_column(false), end_inclusive(true) {}
  bool start_row :1;
  bool start_column :1;
  bool start_inclusive :1;
  bool end_row :1;
  bool end_column :1;
  bool end_inclusive :1;
} _CellInterval__isset;

class CellInterval : public virtual ::apache::thrift::TBase {
 public:

  CellInterval(const CellInterval&);
  CellInterval& operator=(const CellInterval&);
  CellInterval() : start_row(), start_column(), start_inclusive(true), end_row(), end_column(), end_inclusive(true) {
  }

  virtual ~CellInterval() throw();
  std::string start_row;
  std::string start_column;
  bool start_inclusive;
  std::string end_row;
  std::string end_column;
  bool end_inclusive;

  _CellInterval__isset __isset;

  void __set_start_row(const std::string& val);

  void __set_start_column(const std::string& val);

  void __set_start_inclusive(const bool val);

  void __set_end_row(const std::string& val);

  void __set_end_column(const std::string& val);

  void __set_end_inclusive(const bool val);

  bool operator == (const CellInterval & rhs) const
  {
    if (__isset.start_row != rhs.__isset.start_row)
      return false;
    else if (__isset.start_row && !(start_row == rhs.start_row))
      return false;
    if (__isset.start_column != rhs.__isset.start_column)
      return false;
    else if (__isset.start_column && !(start_column == rhs.start_column))
      return false;
    if (__isset.start_inclusive != rhs.__isset.start_inclusive)
      return false;
    else if (__isset.start_inclusive && !(start_inclusive == rhs.start_inclusive))
      return false;
    if (__isset.end_row != rhs.__isset.end_row)
      return false;
    else if (__isset.end_row && !(end_row == rhs.end_row))
      return false;
    if (__isset.end_column != rhs.__isset.end_column)
      return false;
    else if (__isset.end_column && !(end_column == rhs.end_column))
      return false;
    if (__isset.end_inclusive != rhs.__isset.end_inclusive)
      return false;
    else if (__isset.end_inclusive && !(end_inclusive == rhs.end_inclusive))
      return false;
    return true;
  }
  bool operator != (const CellInterval &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CellInterval & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CellInterval &a, CellInterval &b);

std::ostream& operator<<(std::ostream& out, const CellInterval& obj);

typedef struct _ColumnPredicate__isset {
  _ColumnPredicate__isset() : column_family(false), column_qualifier(false), operation(false), value(false) {}
  bool column_family :1;
  bool column_qualifier :1;
  bool operation :1;
  bool value :1;
} _ColumnPredicate__isset;

class ColumnPredicate : public virtual ::apache::thrift::TBase {
 public:

  ColumnPredicate(const ColumnPredicate&);
  ColumnPredicate& operator=(const ColumnPredicate&);
  ColumnPredicate() : column_family(), column_qualifier(), operation(0), value() {
  }

  virtual ~ColumnPredicate() throw();
  std::string column_family;
  std::string column_qualifier;
  int32_t operation;
  std::string value;

  _ColumnPredicate__isset __isset;

  void __set_column_family(const std::string& val);

  void __set_column_qualifier(const std::string& val);

  void __set_operation(const int32_t val);

  void __set_value(const std::string& val);

  bool operator == (const ColumnPredicate & rhs) const
  {
    if (__isset.column_family != rhs.__isset.column_family)
      return false;
    else if (__isset.column_family && !(column_family == rhs.column_family))
      return false;
    if (__isset.column_qualifier != rhs.__isset.column_qualifier)
      return false;
    else if (__isset.column_qualifier && !(column_qualifier == rhs.column_qualifier))
      return false;
    if (!(operation == rhs.operation))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const ColumnPredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnPredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnPredicate &a, ColumnPredicate &b);

std::ostream& operator<<(std::ostream& out, const ColumnPredicate& obj);

typedef struct _ScanSpec__isset {
  _ScanSpec__isset() : row_intervals(false), cell_intervals(false), return_deletes(true), versions(true), row_limit(true), start_time(false), end_time(false), columns(false), keys_only(true), cell_limit(true), cell_limit_per_family(true), row_regexp(false), value_regexp(false), scan_and_filter_rows(true), row_offset(true), cell_offset(true), column_predicates(false), do_not_cache(true), and_column_predicates(true) {}
  bool row_intervals :1;
  bool cell_intervals :1;
  bool return_deletes :1;
  bool versions :1;
  bool row_limit :1;
  bool start_time :1;
  bool end_time :1;
  bool columns :1;
  bool keys_only :1;
  bool cell_limit :1;
  bool cell_limit_per_family :1;
  bool row_regexp :1;
  bool value_regexp :1;
  bool scan_and_filter_rows :1;
  bool row_offset :1;
  bool cell_offset :1;
  bool column_predicates :1;
  bool do_not_cache :1;
  bool and_column_predicates :1;
} _ScanSpec__isset;

class ScanSpec : public virtual ::apache::thrift::TBase {
 public:

  ScanSpec(const ScanSpec&);
  ScanSpec& operator=(const ScanSpec&);
  ScanSpec() : return_deletes(false), versions(0), row_limit(0), start_time(0), end_time(0), keys_only(false), cell_limit(0), cell_limit_per_family(0), row_regexp(), value_regexp(), scan_and_filter_rows(false), row_offset(0), cell_offset(0), do_not_cache(false), and_column_predicates(false) {
  }

  virtual ~ScanSpec() throw();
  std::vector<RowInterval>  row_intervals;
  std::vector<CellInterval>  cell_intervals;
  bool return_deletes;
  int32_t versions;
  int32_t row_limit;
  int64_t start_time;
  int64_t end_time;
  std::vector<std::string>  columns;
  bool keys_only;
  int32_t cell_limit;
  int32_t cell_limit_per_family;
  std::string row_regexp;
  std::string value_regexp;
  bool scan_and_filter_rows;
  int32_t row_offset;
  int32_t cell_offset;
  std::vector<ColumnPredicate>  column_predicates;
  bool do_not_cache;
  bool and_column_predicates;

  _ScanSpec__isset __isset;

  void __set_row_intervals(const std::vector<RowInterval> & val);

  void __set_cell_intervals(const std::vector<CellInterval> & val);

  void __set_return_deletes(const bool val);

  void __set_versions(const int32_t val);

  void __set_row_limit(const int32_t val);

  void __set_start_time(const int64_t val);

  void __set_end_time(const int64_t val);

  void __set_columns(const std::vector<std::string> & val);

  void __set_keys_only(const bool val);

  void __set_cell_limit(const int32_t val);

  void __set_cell_limit_per_family(const int32_t val);

  void __set_row_regexp(const std::string& val);

  void __set_value_regexp(const std::string& val);

  void __set_scan_and_filter_rows(const bool val);

  void __set_row_offset(const int32_t val);

  void __set_cell_offset(const int32_t val);

  void __set_column_predicates(const std::vector<ColumnPredicate> & val);

  void __set_do_not_cache(const bool val);

  void __set_and_column_predicates(const bool val);

  bool operator == (const ScanSpec & rhs) const
  {
    if (__isset.row_intervals != rhs.__isset.row_intervals)
      return false;
    else if (__isset.row_intervals && !(row_intervals == rhs.row_intervals))
      return false;
    if (__isset.cell_intervals != rhs.__isset.cell_intervals)
      return false;
    else if (__isset.cell_intervals && !(cell_intervals == rhs.cell_intervals))
      return false;
    if (__isset.return_deletes != rhs.__isset.return_deletes)
      return false;
    else if (__isset.return_deletes && !(return_deletes == rhs.return_deletes))
      return false;
    if (__isset.versions != rhs.__isset.versions)
      return false;
    else if (__isset.versions && !(versions == rhs.versions))
      return false;
    if (__isset.row_limit != rhs.__isset.row_limit)
      return false;
    else if (__isset.row_limit && !(row_limit == rhs.row_limit))
      return false;
    if (__isset.start_time != rhs.__isset.start_time)
      return false;
    else if (__isset.start_time && !(start_time == rhs.start_time))
      return false;
    if (__isset.end_time != rhs.__isset.end_time)
      return false;
    else if (__isset.end_time && !(end_time == rhs.end_time))
      return false;
    if (__isset.columns != rhs.__isset.columns)
      return false;
    else if (__isset.columns && !(columns == rhs.columns))
      return false;
    if (__isset.keys_only != rhs.__isset.keys_only)
      return false;
    else if (__isset.keys_only && !(keys_only == rhs.keys_only))
      return false;
    if (__isset.cell_limit != rhs.__isset.cell_limit)
      return false;
    else if (__isset.cell_limit && !(cell_limit == rhs.cell_limit))
      return false;
    if (__isset.cell_limit_per_family != rhs.__isset.cell_limit_per_family)
      return false;
    else if (__isset.cell_limit_per_family && !(cell_limit_per_family == rhs.cell_limit_per_family))
      return false;
    if (__isset.row_regexp != rhs.__isset.row_regexp)
      return false;
    else if (__isset.row_regexp && !(row_regexp == rhs.row_regexp))
      return false;
    if (__isset.value_regexp != rhs.__isset.value_regexp)
      return false;
    else if (__isset.value_regexp && !(value_regexp == rhs.value_regexp))
      return false;
    if (__isset.scan_and_filter_rows != rhs.__isset.scan_and_filter_rows)
      return false;
    else if (__isset.scan_and_filter_rows && !(scan_and_filter_rows == rhs.scan_and_filter_rows))
      return false;
    if (__isset.row_offset != rhs.__isset.row_offset)
      return false;
    else if (__isset.row_offset && !(row_offset == rhs.row_offset))
      return false;
    if (__isset.cell_offset != rhs.__isset.cell_offset)
      return false;
    else if (__isset.cell_offset && !(cell_offset == rhs.cell_offset))
      return false;
    if (__isset.column_predicates != rhs.__isset.column_predicates)
      return false;
    else if (__isset.column_predicates && !(column_predicates == rhs.column_predicates))
      return false;
    if (__isset.do_not_cache != rhs.__isset.do_not_cache)
      return false;
    else if (__isset.do_not_cache && !(do_not_cache == rhs.do_not_cache))
      return false;
    if (__isset.and_column_predicates != rhs.__isset.and_column_predicates)
      return false;
    else if (__isset.and_column_predicates && !(and_column_predicates == rhs.and_column_predicates))
      return false;
    return true;
  }
  bool operator != (const ScanSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ScanSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ScanSpec &a, ScanSpec &b);

std::ostream& operator<<(std::ostream& out, const ScanSpec& obj);

typedef struct _Key__isset {
  _Key__isset() : row(false), column_family(false), column_qualifier(false), timestamp(false), revision(false), flag(true) {}
  bool row :1;
  bool column_family :1;
  bool column_qualifier :1;
  bool timestamp :1;
  bool revision :1;
  bool flag :1;
} _Key__isset;

class Key : public virtual ::apache::thrift::TBase {
 public:

  Key(const Key&);
  Key& operator=(const Key&);
  Key() : row(), column_family(), column_qualifier(), timestamp(0), revision(0), flag((KeyFlag::type)255) {
    flag = (KeyFlag::type)255;

  }

  virtual ~Key() throw();
  std::string row;
  std::string column_family;
  std::string column_qualifier;
  int64_t timestamp;
  int64_t revision;
  KeyFlag::type flag;

  _Key__isset __isset;

  void __set_row(const std::string& val);

  void __set_column_family(const std::string& val);

  void __set_column_qualifier(const std::string& val);

  void __set_timestamp(const int64_t val);

  void __set_revision(const int64_t val);

  void __set_flag(const KeyFlag::type val);

  bool operator == (const Key & rhs) const
  {
    if (!(row == rhs.row))
      return false;
    if (!(column_family == rhs.column_family))
      return false;
    if (!(column_qualifier == rhs.column_qualifier))
      return false;
    if (__isset.timestamp != rhs.__isset.timestamp)
      return false;
    else if (__isset.timestamp && !(timestamp == rhs.timestamp))
      return false;
    if (__isset.revision != rhs.__isset.revision)
      return false;
    else if (__isset.revision && !(revision == rhs.revision))
      return false;
    if (!(flag == rhs.flag))
      return false;
    return true;
  }
  bool operator != (const Key &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Key & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Key &a, Key &b);

std::ostream& operator<<(std::ostream& out, const Key& obj);


class MutateSpec : public virtual ::apache::thrift::TBase {
 public:

  MutateSpec(const MutateSpec&);
  MutateSpec& operator=(const MutateSpec&);
  MutateSpec() : appname(""), flush_interval(1000), flags(2) {
  }

  virtual ~MutateSpec() throw();
  std::string appname;
  int32_t flush_interval;
  int32_t flags;

  void __set_appname(const std::string& val);

  void __set_flush_interval(const int32_t val);

  void __set_flags(const int32_t val);

  bool operator == (const MutateSpec & rhs) const
  {
    if (!(appname == rhs.appname))
      return false;
    if (!(flush_interval == rhs.flush_interval))
      return false;
    if (!(flags == rhs.flags))
      return false;
    return true;
  }
  bool operator != (const MutateSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MutateSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MutateSpec &a, MutateSpec &b);

std::ostream& operator<<(std::ostream& out, const MutateSpec& obj);

typedef struct _Cell__isset {
  _Cell__isset() : key(false), value(false) {}
  bool key :1;
  bool value :1;
} _Cell__isset;

class Cell : public virtual ::apache::thrift::TBase {
 public:

  Cell(const Cell&);
  Cell& operator=(const Cell&);
  Cell() : value() {
  }

  virtual ~Cell() throw();
  Key key;
  Value value;

  _Cell__isset __isset;

  void __set_key(const Key& val);

  void __set_value(const Value& val);

  bool operator == (const Cell & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const Cell &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cell & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Cell &a, Cell &b);

std::ostream& operator<<(std::ostream& out, const Cell& obj);

typedef struct _Result__isset {
  _Result__isset() : error(false), error_msg(false), cells(false) {}
  bool error :1;
  bool error_msg :1;
  bool cells :1;
} _Result__isset;

class Result : public virtual ::apache::thrift::TBase {
 public:

  Result(const Result&);
  Result& operator=(const Result&);
  Result() : is_empty(0), id(0), is_scan(0), is_error(0), error(0), error_msg() {
  }

  virtual ~Result() throw();
  bool is_empty;
  int64_t id;
  bool is_scan;
  bool is_error;
  int32_t error;
  std::string error_msg;
  std::vector<Cell>  cells;

  _Result__isset __isset;

  void __set_is_empty(const bool val);

  void __set_id(const int64_t val);

  void __set_is_scan(const bool val);

  void __set_is_error(const bool val);

  void __set_error(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_cells(const std::vector<Cell> & val);

  bool operator == (const Result & rhs) const
  {
    if (!(is_empty == rhs.is_empty))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(is_scan == rhs.is_scan))
      return false;
    if (!(is_error == rhs.is_error))
      return false;
    if (__isset.error != rhs.__isset.error)
      return false;
    else if (__isset.error && !(error == rhs.error))
      return false;
    if (__isset.error_msg != rhs.__isset.error_msg)
      return false;
    else if (__isset.error_msg && !(error_msg == rhs.error_msg))
      return false;
    if (__isset.cells != rhs.__isset.cells)
      return false;
    else if (__isset.cells && !(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const Result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Result &a, Result &b);

std::ostream& operator<<(std::ostream& out, const Result& obj);

typedef struct _ResultAsArrays__isset {
  _ResultAsArrays__isset() : error(false), error_msg(false), cells(false) {}
  bool error :1;
  bool error_msg :1;
  bool cells :1;
} _ResultAsArrays__isset;

class ResultAsArrays : public virtual ::apache::thrift::TBase {
 public:

  ResultAsArrays(const ResultAsArrays&);
  ResultAsArrays& operator=(const ResultAsArrays&);
  ResultAsArrays() : is_empty(0), id(0), is_scan(0), is_error(0), error(0), error_msg() {
  }

  virtual ~ResultAsArrays() throw();
  bool is_empty;
  int64_t id;
  bool is_scan;
  bool is_error;
  int32_t error;
  std::string error_msg;
  std::vector<CellAsArray>  cells;

  _ResultAsArrays__isset __isset;

  void __set_is_empty(const bool val);

  void __set_id(const int64_t val);

  void __set_is_scan(const bool val);

  void __set_is_error(const bool val);

  void __set_error(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_cells(const std::vector<CellAsArray> & val);

  bool operator == (const ResultAsArrays & rhs) const
  {
    if (!(is_empty == rhs.is_empty))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(is_scan == rhs.is_scan))
      return false;
    if (!(is_error == rhs.is_error))
      return false;
    if (__isset.error != rhs.__isset.error)
      return false;
    else if (__isset.error && !(error == rhs.error))
      return false;
    if (__isset.error_msg != rhs.__isset.error_msg)
      return false;
    else if (__isset.error_msg && !(error_msg == rhs.error_msg))
      return false;
    if (__isset.cells != rhs.__isset.cells)
      return false;
    else if (__isset.cells && !(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const ResultAsArrays &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResultAsArrays & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ResultAsArrays &a, ResultAsArrays &b);

std::ostream& operator<<(std::ostream& out, const ResultAsArrays& obj);

typedef struct _ResultSerialized__isset {
  _ResultSerialized__isset() : error(false), error_msg(false), cells(false) {}
  bool error :1;
  bool error_msg :1;
  bool cells :1;
} _ResultSerialized__isset;

class ResultSerialized : public virtual ::apache::thrift::TBase {
 public:

  ResultSerialized(const ResultSerialized&);
  ResultSerialized& operator=(const ResultSerialized&);
  ResultSerialized() : is_empty(0), id(0), is_scan(0), is_error(0), error(0), error_msg(), cells() {
  }

  virtual ~ResultSerialized() throw();
  bool is_empty;
  int64_t id;
  bool is_scan;
  bool is_error;
  int32_t error;
  std::string error_msg;
  CellsSerialized cells;

  _ResultSerialized__isset __isset;

  void __set_is_empty(const bool val);

  void __set_id(const int64_t val);

  void __set_is_scan(const bool val);

  void __set_is_error(const bool val);

  void __set_error(const int32_t val);

  void __set_error_msg(const std::string& val);

  void __set_cells(const CellsSerialized& val);

  bool operator == (const ResultSerialized & rhs) const
  {
    if (!(is_empty == rhs.is_empty))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(is_scan == rhs.is_scan))
      return false;
    if (!(is_error == rhs.is_error))
      return false;
    if (__isset.error != rhs.__isset.error)
      return false;
    else if (__isset.error && !(error == rhs.error))
      return false;
    if (__isset.error_msg != rhs.__isset.error_msg)
      return false;
    else if (__isset.error_msg && !(error_msg == rhs.error_msg))
      return false;
    if (__isset.cells != rhs.__isset.cells)
      return false;
    else if (__isset.cells && !(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const ResultSerialized &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResultSerialized & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ResultSerialized &a, ResultSerialized &b);

std::ostream& operator<<(std::ostream& out, const ResultSerialized& obj);


class NamespaceListing : public virtual ::apache::thrift::TBase {
 public:

  NamespaceListing(const NamespaceListing&);
  NamespaceListing& operator=(const NamespaceListing&);
  NamespaceListing() : name(), is_namespace(0) {
  }

  virtual ~NamespaceListing() throw();
  std::string name;
  bool is_namespace;

  void __set_name(const std::string& val);

  void __set_is_namespace(const bool val);

  bool operator == (const NamespaceListing & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(is_namespace == rhs.is_namespace))
      return false;
    return true;
  }
  bool operator != (const NamespaceListing &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NamespaceListing & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NamespaceListing &a, NamespaceListing &b);

std::ostream& operator<<(std::ostream& out, const NamespaceListing& obj);

typedef struct _TableSplit__isset {
  _TableSplit__isset() : start_row(false), end_row(false), location(false), ip_address(false), hostname(false) {}
  bool start_row :1;
  bool end_row :1;
  bool location :1;
  bool ip_address :1;
  bool hostname :1;
} _TableSplit__isset;

class TableSplit : public virtual ::apache::thrift::TBase {
 public:

  TableSplit(const TableSplit&);
  TableSplit& operator=(const TableSplit&);
  TableSplit() : start_row(), end_row(), location(), ip_address(), hostname() {
  }

  virtual ~TableSplit() throw();
  std::string start_row;
  std::string end_row;
  std::string location;
  std::string ip_address;
  std::string hostname;

  _TableSplit__isset __isset;

  void __set_start_row(const std::string& val);

  void __set_end_row(const std::string& val);

  void __set_location(const std::string& val);

  void __set_ip_address(const std::string& val);

  void __set_hostname(const std::string& val);

  bool operator == (const TableSplit & rhs) const
  {
    if (__isset.start_row != rhs.__isset.start_row)
      return false;
    else if (__isset.start_row && !(start_row == rhs.start_row))
      return false;
    if (__isset.end_row != rhs.__isset.end_row)
      return false;
    else if (__isset.end_row && !(end_row == rhs.end_row))
      return false;
    if (__isset.location != rhs.__isset.location)
      return false;
    else if (__isset.location && !(location == rhs.location))
      return false;
    if (__isset.ip_address != rhs.__isset.ip_address)
      return false;
    else if (__isset.ip_address && !(ip_address == rhs.ip_address))
      return false;
    if (__isset.hostname != rhs.__isset.hostname)
      return false;
    else if (__isset.hostname && !(hostname == rhs.hostname))
      return false;
    return true;
  }
  bool operator != (const TableSplit &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TableSplit & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TableSplit &a, TableSplit &b);

std::ostream& operator<<(std::ostream& out, const TableSplit& obj);

typedef struct _ColumnFamilyOptions__isset {
  _ColumnFamilyOptions__isset() : max_versions(false), ttl(false), time_order_desc(false), counter(false) {}
  bool max_versions :1;
  bool ttl :1;
  bool time_order_desc :1;
  bool counter :1;
} _ColumnFamilyOptions__isset;

class ColumnFamilyOptions : public virtual ::apache::thrift::TBase {
 public:

  ColumnFamilyOptions(const ColumnFamilyOptions&);
  ColumnFamilyOptions& operator=(const ColumnFamilyOptions&);
  ColumnFamilyOptions() : max_versions(0), ttl(0), time_order_desc(0), counter(0) {
  }

  virtual ~ColumnFamilyOptions() throw();
  int32_t max_versions;
  int32_t ttl;
  bool time_order_desc;
  bool counter;

  _ColumnFamilyOptions__isset __isset;

  void __set_max_versions(const int32_t val);

  void __set_ttl(const int32_t val);

  void __set_time_order_desc(const bool val);

  void __set_counter(const bool val);

  bool operator == (const ColumnFamilyOptions & rhs) const
  {
    if (__isset.max_versions != rhs.__isset.max_versions)
      return false;
    else if (__isset.max_versions && !(max_versions == rhs.max_versions))
      return false;
    if (__isset.ttl != rhs.__isset.ttl)
      return false;
    else if (__isset.ttl && !(ttl == rhs.ttl))
      return false;
    if (__isset.time_order_desc != rhs.__isset.time_order_desc)
      return false;
    else if (__isset.time_order_desc && !(time_order_desc == rhs.time_order_desc))
      return false;
    if (__isset.counter != rhs.__isset.counter)
      return false;
    else if (__isset.counter && !(counter == rhs.counter))
      return false;
    return true;
  }
  bool operator != (const ColumnFamilyOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnFamilyOptions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnFamilyOptions &a, ColumnFamilyOptions &b);

std::ostream& operator<<(std::ostream& out, const ColumnFamilyOptions& obj);

typedef struct _ColumnFamilySpec__isset {
  _ColumnFamilySpec__isset() : name(false), access_group(false), deleted(false), generation(false), id(false), value_index(false), qualifier_index(false), options(false) {}
  bool name :1;
  bool access_group :1;
  bool deleted :1;
  bool generation :1;
  bool id :1;
  bool value_index :1;
  bool qualifier_index :1;
  bool options :1;
} _ColumnFamilySpec__isset;

class ColumnFamilySpec : public virtual ::apache::thrift::TBase {
 public:

  ColumnFamilySpec(const ColumnFamilySpec&);
  ColumnFamilySpec& operator=(const ColumnFamilySpec&);
  ColumnFamilySpec() : name(), access_group(), deleted(0), generation(0), id(0), value_index(0), qualifier_index(0) {
  }

  virtual ~ColumnFamilySpec() throw();
  std::string name;
  std::string access_group;
  bool deleted;
  int64_t generation;
  int32_t id;
  bool value_index;
  bool qualifier_index;
  ColumnFamilyOptions options;

  _ColumnFamilySpec__isset __isset;

  void __set_name(const std::string& val);

  void __set_access_group(const std::string& val);

  void __set_deleted(const bool val);

  void __set_generation(const int64_t val);

  void __set_id(const int32_t val);

  void __set_value_index(const bool val);

  void __set_qualifier_index(const bool val);

  void __set_options(const ColumnFamilyOptions& val);

  bool operator == (const ColumnFamilySpec & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(access_group == rhs.access_group))
      return false;
    if (!(deleted == rhs.deleted))
      return false;
    if (__isset.generation != rhs.__isset.generation)
      return false;
    else if (__isset.generation && !(generation == rhs.generation))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (!(value_index == rhs.value_index))
      return false;
    if (!(qualifier_index == rhs.qualifier_index))
      return false;
    if (__isset.options != rhs.__isset.options)
      return false;
    else if (__isset.options && !(options == rhs.options))
      return false;
    return true;
  }
  bool operator != (const ColumnFamilySpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnFamilySpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnFamilySpec &a, ColumnFamilySpec &b);

std::ostream& operator<<(std::ostream& out, const ColumnFamilySpec& obj);

typedef struct _AccessGroupOptions__isset {
  _AccessGroupOptions__isset() : replication(false), blocksize(false), compressor(false), bloom_filter(false), in_memory(false) {}
  bool replication :1;
  bool blocksize :1;
  bool compressor :1;
  bool bloom_filter :1;
  bool in_memory :1;
} _AccessGroupOptions__isset;

class AccessGroupOptions : public virtual ::apache::thrift::TBase {
 public:

  AccessGroupOptions(const AccessGroupOptions&);
  AccessGroupOptions& operator=(const AccessGroupOptions&);
  AccessGroupOptions() : replication(0), blocksize(0), compressor(), bloom_filter(), in_memory(0) {
  }

  virtual ~AccessGroupOptions() throw();
  int16_t replication;
  int32_t blocksize;
  std::string compressor;
  std::string bloom_filter;
  bool in_memory;

  _AccessGroupOptions__isset __isset;

  void __set_replication(const int16_t val);

  void __set_blocksize(const int32_t val);

  void __set_compressor(const std::string& val);

  void __set_bloom_filter(const std::string& val);

  void __set_in_memory(const bool val);

  bool operator == (const AccessGroupOptions & rhs) const
  {
    if (__isset.replication != rhs.__isset.replication)
      return false;
    else if (__isset.replication && !(replication == rhs.replication))
      return false;
    if (__isset.blocksize != rhs.__isset.blocksize)
      return false;
    else if (__isset.blocksize && !(blocksize == rhs.blocksize))
      return false;
    if (__isset.compressor != rhs.__isset.compressor)
      return false;
    else if (__isset.compressor && !(compressor == rhs.compressor))
      return false;
    if (__isset.bloom_filter != rhs.__isset.bloom_filter)
      return false;
    else if (__isset.bloom_filter && !(bloom_filter == rhs.bloom_filter))
      return false;
    if (__isset.in_memory != rhs.__isset.in_memory)
      return false;
    else if (__isset.in_memory && !(in_memory == rhs.in_memory))
      return false;
    return true;
  }
  bool operator != (const AccessGroupOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccessGroupOptions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AccessGroupOptions &a, AccessGroupOptions &b);

std::ostream& operator<<(std::ostream& out, const AccessGroupOptions& obj);

typedef struct _AccessGroupSpec__isset {
  _AccessGroupSpec__isset() : name(false), generation(false), options(false), defaults(false) {}
  bool name :1;
  bool generation :1;
  bool options :1;
  bool defaults :1;
} _AccessGroupSpec__isset;

class AccessGroupSpec : public virtual ::apache::thrift::TBase {
 public:

  AccessGroupSpec(const AccessGroupSpec&);
  AccessGroupSpec& operator=(const AccessGroupSpec&);
  AccessGroupSpec() : name(), generation(0) {
  }

  virtual ~AccessGroupSpec() throw();
  std::string name;
  int64_t generation;
  AccessGroupOptions options;
  ColumnFamilyOptions defaults;

  _AccessGroupSpec__isset __isset;

  void __set_name(const std::string& val);

  void __set_generation(const int64_t val);

  void __set_options(const AccessGroupOptions& val);

  void __set_defaults(const ColumnFamilyOptions& val);

  bool operator == (const AccessGroupSpec & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.generation != rhs.__isset.generation)
      return false;
    else if (__isset.generation && !(generation == rhs.generation))
      return false;
    if (__isset.options != rhs.__isset.options)
      return false;
    else if (__isset.options && !(options == rhs.options))
      return false;
    if (__isset.defaults != rhs.__isset.defaults)
      return false;
    else if (__isset.defaults && !(defaults == rhs.defaults))
      return false;
    return true;
  }
  bool operator != (const AccessGroupSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccessGroupSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AccessGroupSpec &a, AccessGroupSpec &b);

std::ostream& operator<<(std::ostream& out, const AccessGroupSpec& obj);

typedef struct _Schema__isset {
  _Schema__isset() : access_groups(false), column_families(false), generation(false), version(false), group_commit_interval(false), access_group_defaults(false), column_family_defaults(false) {}
  bool access_groups :1;
  bool column_families :1;
  bool generation :1;
  bool version :1;
  bool group_commit_interval :1;
  bool access_group_defaults :1;
  bool column_family_defaults :1;
} _Schema__isset;

class Schema : public virtual ::apache::thrift::TBase {
 public:

  Schema(const Schema&);
  Schema& operator=(const Schema&);
  Schema() : generation(0), version(0), group_commit_interval(0) {
  }

  virtual ~Schema() throw();
  std::map<std::string, AccessGroupSpec>  access_groups;
  std::map<std::string, ColumnFamilySpec>  column_families;
  int64_t generation;
  int32_t version;
  int32_t group_commit_interval;
  AccessGroupOptions access_group_defaults;
  ColumnFamilyOptions column_family_defaults;

  _Schema__isset __isset;

  void __set_access_groups(const std::map<std::string, AccessGroupSpec> & val);

  void __set_column_families(const std::map<std::string, ColumnFamilySpec> & val);

  void __set_generation(const int64_t val);

  void __set_version(const int32_t val);

  void __set_group_commit_interval(const int32_t val);

  void __set_access_group_defaults(const AccessGroupOptions& val);

  void __set_column_family_defaults(const ColumnFamilyOptions& val);

  bool operator == (const Schema & rhs) const
  {
    if (__isset.access_groups != rhs.__isset.access_groups)
      return false;
    else if (__isset.access_groups && !(access_groups == rhs.access_groups))
      return false;
    if (__isset.column_families != rhs.__isset.column_families)
      return false;
    else if (__isset.column_families && !(column_families == rhs.column_families))
      return false;
    if (__isset.generation != rhs.__isset.generation)
      return false;
    else if (__isset.generation && !(generation == rhs.generation))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.group_commit_interval != rhs.__isset.group_commit_interval)
      return false;
    else if (__isset.group_commit_interval && !(group_commit_interval == rhs.group_commit_interval))
      return false;
    if (__isset.access_group_defaults != rhs.__isset.access_group_defaults)
      return false;
    else if (__isset.access_group_defaults && !(access_group_defaults == rhs.access_group_defaults))
      return false;
    if (__isset.column_family_defaults != rhs.__isset.column_family_defaults)
      return false;
    else if (__isset.column_family_defaults && !(column_family_defaults == rhs.column_family_defaults))
      return false;
    return true;
  }
  bool operator != (const Schema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Schema & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Schema &a, Schema &b);

std::ostream& operator<<(std::ostream& out, const Schema& obj);


class Status : public virtual ::apache::thrift::TBase {
 public:

  Status(const Status&);
  Status& operator=(const Status&);
  Status() : code(0), text() {
  }

  virtual ~Status() throw();
  int32_t code;
  std::string text;

  void __set_code(const int32_t val);

  void __set_text(const std::string& val);

  bool operator == (const Status & rhs) const
  {
    if (!(code == rhs.code))
      return false;
    if (!(text == rhs.text))
      return false;
    return true;
  }
  bool operator != (const Status &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Status & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Status &a, Status &b);

std::ostream& operator<<(std::ostream& out, const Status& obj);

typedef struct _ClientException__isset {
  _ClientException__isset() : code(false), message(false) {}
  bool code :1;
  bool message :1;
} _ClientException__isset;

class ClientException : public ::apache::thrift::TException {
 public:

  ClientException(const ClientException&);
  ClientException& operator=(const ClientException&);
  ClientException() : code(0), message() {
  }

  virtual ~ClientException() throw();
  int32_t code;
  std::string message;

  _ClientException__isset __isset;

  void __set_code(const int32_t val);

  void __set_message(const std::string& val);

  bool operator == (const ClientException & rhs) const
  {
    if (!(code == rhs.code))
      return false;
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const ClientException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(ClientException &a, ClientException &b);

std::ostream& operator<<(std::ostream& out, const ClientException& obj);

}} // namespace

#endif
